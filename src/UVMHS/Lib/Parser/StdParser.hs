module UVMHS.Lib.Parser.StdParser where

import UVMHS.Core

import UVMHS.Lib.Pretty

import UVMHS.Lib.Parser.Blockify
import UVMHS.Lib.Parser.GenParser
import UVMHS.Lib.Parser.GenLexer
import UVMHS.Lib.Parser.Mixfix
import UVMHS.Lib.Parser.Regex
import UVMHS.Lib.Parser.ParserInput
import UVMHS.Lib.Parser.ParserContext
import UVMHS.Lib.Annotated

-----------
-- REGEX --
-----------

data StdCharClass = 
    Letter_SCC 
  | Number_SCC 
  | Space_SCC 
  | Newline_SCC 
  | Other_SCC
  deriving (Eq,Ord,Show)
makePrettySum ''StdCharClass

instance All StdCharClass where 
  all = iter [Letter_SCC,Number_SCC,Space_SCC,Newline_SCC,Other_SCC]

instance Classified StdCharClass ‚ÑÇ where
  classify c
    | isLetter c = Letter_SCC
    | isNumber c = Number_SCC
    | isSpace c ‚©ì c ‚â¢ '\n' = Space_SCC
    | c ‚â° '\n' = Newline_SCC
    | otherwise = Other_SCC

lWord ‚à∑ (Zero u,Ord o,Ord u,Additive u) ‚áí ùïä ‚Üí Regex StdCharClass ‚ÑÇ o u
lWord = fold eps $ \ c r ‚Üí r ‚ñ∑ tokRegex c

lSpaceOrNL ‚à∑ (Zero u,Ord o,Ord u,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lSpaceOrNL = oom $ classRegex Space_SCC ‚ß∫ classRegex Newline_SCC

lSpace ‚à∑ (Zero u,Ord o,Ord u,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lSpace = oom $ classRegex Space_SCC

lNL ‚à∑ (Zero u,Ord o,Ord u,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lNL = oom $ classRegex Newline_SCC

lName ‚à∑ (Zero u,Ord u,Ord o,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lName =
  let begTok = concat
        [ classRegex Letter_SCC
        , concat $ map tokRegex $ iter $ ùï§ "_'‚Ä≤‚Ä≥‚Ä¥"
        ]
      endTok = concat
        [ begTok
        , classRegex Number_SCC
        ]
      midTok = begTok ‚ß∫ endTok ‚ß∫ tokRegex '-'
  in
  sequence
    [ begTok
    , opt $ sequence
        [ star midTok
        , endTok
        ]
    ]

lNatPre ‚à∑ (Zero u,Ord u,Ord o,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lNatPre = sequence
  [ concat $ map tokRegex ['0'..'9']
  , star $ concat
      [ concat $ map tokRegex ['0'..'9']
      , tokRegex '_'
      ]
  , fepsRegex $ formats [FG red]
  ]

lNat ‚à∑ (Zero u,Ord u,Ord o,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lNat = sequence
  [ lNatPre
  , lepsRegex $ ùïü64 102
  ]

lNatCoded ‚à∑ (Zero u,Ord u,Ord o,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lNatCoded = sequence
  [ lNatPre
  , tokRegex 'n'
  , lepsRegex $ ùïü64 102
  ]

lIntPre ‚à∑ (Zero u,Ord o,Ord u,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lIntPre = sequence
  [ opt $ tokRegex '-'
  , lNatPre
  ]

lInt ‚à∑ (Zero u,Ord o,Ord u,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lInt = sequence
  [ lIntPre
  , lepsRegex $ ùïü64 101
  ]

lDbl ‚à∑ (Zero u,Ord o,Ord u,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lDbl = sequence
  [ lIntPre
  , opt $ sequence
    [ tokRegex '.'
    , lNatPre
    ]
  , opt $ sequence
    [ tokRegex 'e'
    , lIntPre
    ]
  , lepsRegex $ ùïü64 100
  ]

lString ‚à∑ (Zero u,Ord o,Ord u,Additive u) ‚áí Regex StdCharClass ‚ÑÇ o u
lString = sequence
  [ tokRegex '"'
  , star $ concat
      [ ntokRegex $ pow ['\\','"']
      , lWord "\\\\"
      , lWord "\\\""
      , lWord "\\n"
      ]
  , tokRegex '"'
  , fepsRegex $ formats [FG red]
  ]

lComment ‚à∑ (Ord o) ‚áí Regex StdCharClass ‚ÑÇ o ‚Ñ§64
lComment = sequence
  [ lWord "--"
  , star $ ntokRegex $ single '\n'
  -- , opt $ tokRegex '\n'
  , fepsRegex $ formats [IT,FG grayLight]
  , lepsRegex $ ùïü64 100
  ]

lCommentMLOpen ‚à∑ (Ord o) ‚áí Regex StdCharClass ‚ÑÇ o ‚Ñ§64
lCommentMLOpen = sequence
  [ lWord "{-"
  , uepsRegex one
  , fepsRegex $ formats [IT,FG grayLight]
  , lepsRegex $ ùïü64 100
  ]

lCommentMLBodyOpen ‚à∑ (Ord o) ‚áí Regex StdCharClass ‚ÑÇ o ‚Ñ§64
lCommentMLBodyOpen = sequence
  [ oom (tokRegex '{') ‚ñ∑ tokRegex '-'
  , uepsRegex one
  ]

lCommentMLBodyClose ‚à∑ (Ord o) ‚áí Regex StdCharClass ‚ÑÇ o ‚Ñ§64
lCommentMLBodyClose = sequence
  [ oom (tokRegex '-') ‚ñ∑ tokRegex '}'
  , uepsRegex $ neg one
  ]

lCommentMLBody ‚à∑ (Ord o) ‚áí Regex StdCharClass ‚ÑÇ o ‚Ñ§64
lCommentMLBody = sequence
  [ star $ concat
      [ ntokRegex $ pow ['-','{']
      , oom (tokRegex '-') ‚ñ∑ ntokRegex (pow ['-','}'])
      , oom (tokRegex '{') ‚ñ∑ ntokRegex (pow ['{','-'])
      ]
  , lCommentMLBodyOpen ‚ß∫ lCommentMLBodyClose
  , fepsRegex $ formats [IT,FG grayLight]
  ]

-----------
-- LEXER --
-----------

data TokenClass =
    Space_TC
  | Newline_TC
  | Comment_TC
  | Block_TC
  | String_TC
  | Name_TC
  | Nat_TC
  | Int_TC
  | Dbl_TC
  | Char_TC
  | Syntax_TC
  deriving (Eq,Ord,Show)
makePrisms ''TokenClass
makePrettySum ''TokenClass

data Token =
    Space_T ùïä
  | Newline_T ùïä
  | Comment_T ùïä
  | Block_T ùïä
  | String_T ùïä
  | Name_T ùïä
  | Nat_T ‚Ñï
  | Int_T ‚Ñ§
  | Dbl_T ùîª
  | Char_T ‚ÑÇ
  | Syntax_T ùïä
  | BlockOpen_T
  | BlockClose_T
  | BlockSep_T
  deriving (Eq,Ord,Show)
makePrisms ''Token
makePrettySum ''Token

mkToken ‚à∑ ùêºC ‚ÑÇ ‚Üí ùëÇ TokenClass ‚Üí ùîπ ‚àß Token
mkToken cs = \case
  None ‚Üí error "no token class"
  Some Space_TC ‚Üí (:*) True $ Space_T $ stringCS cs
  Some Newline_TC ‚Üí (:*) True $ Newline_T $ stringCS cs
  Some Comment_TC ‚Üí (:*) True $ Comment_T $ stringCS cs
  Some Block_TC ‚Üí (:*) False $ Block_T $ stringCS cs
  Some String_TC ‚Üí (:*) False $ String_T $ readùïä $ stringCS cs
  Some Name_TC ‚Üí (:*) False $ Name_T $ stringCS cs
  Some Nat_TC ‚Üí (:*) False $ Nat_T $ readùïä $ string $ filter (\ c ‚Üí c ‚àâ powùëÉ ['_','n']) cs
  Some Int_TC ‚Üí (:*) False $ Int_T $ readùïä $ string $ filter ((‚â¢) '_') cs
  Some Dbl_TC ‚Üí (:*) False $ Dbl_T $ readùïä $ string $ filter ((‚â¢) '_') cs
  Some Char_TC ‚Üí (:*) False $ Char_T $ readùïä $ stringCS cs
  Some Syntax_TC ‚Üí (:*) False $ Syntax_T $ stringCS cs

data Syntax = Syntax
  { syntaxBrkss ‚à∑ ùïä ‚á∞ ùëÉ ùïä ‚àß ùëÉ ùïä  -- ^ brackets       (default color gray)
  , syntaxPunss ‚à∑ ùëÉ ùïä            -- ^ punctuation    (default color gray)
  , syntaxKeyss ‚à∑ ùëÉ ùïä            -- ^ keywords       (default color bold yellow)
  , syntaxPrmss ‚à∑ ùëÉ ùïä            -- ^ primitives     (default color blue)
  , syntaxOprss ‚à∑ ùëÉ ùïä            -- ^ operators      (default color teal)
  , syntaxBlkss ‚à∑ ùëÉ ùïä            -- ^ block keywords (default color bold yellow)
  } deriving (Eq,Ord,Show)
makeLenses ''Syntax

instance Null Syntax where 
  null = Syntax null null null null null null
instance Append Syntax where 
  Syntax brks‚ÇÅ puns‚ÇÅ keys‚ÇÅ prms‚ÇÅ oprs‚ÇÅ blks‚ÇÅ ‚ß∫ Syntax brks‚ÇÇ puns‚ÇÇ keys‚ÇÇ prms‚ÇÇ oprs‚ÇÇ blks‚ÇÇ =
    Syntax (brks‚ÇÅ ‚ß∫ brks‚ÇÇ) (puns‚ÇÅ ‚ß∫ puns‚ÇÇ) (keys‚ÇÅ ‚ß∫ keys‚ÇÇ) (prms‚ÇÅ ‚ß∫ prms‚ÇÇ) (oprs‚ÇÅ ‚ß∫ oprs‚ÇÇ) $ blks‚ÇÅ ‚ß∫ blks‚ÇÇ
instance Monoid Syntax

syntaxBrks ‚à∑ (ToIter ùïä t) ‚áí ùïä ‚á∞ t ‚àß t ‚Üí Syntax
syntaxBrks blks = null { syntaxBrkss = map (mapPair pow pow) blks }

syntaxPuns ‚à∑ (ToIter ùïä t) ‚áí t ‚Üí Syntax
syntaxPuns puns = null { syntaxPunss = pow puns }

syntaxKeys ‚à∑ (ToIter ùïä t) ‚áí t ‚Üí Syntax
syntaxKeys keys = null { syntaxKeyss = pow keys }

syntaxPrms ‚à∑ (ToIter ùïä t) ‚áí t ‚Üí Syntax
syntaxPrms prms = null { syntaxPrmss = pow prms }

syntaxOprs ‚à∑ (ToIter ùïä t) ‚áí t ‚Üí Syntax
syntaxOprs oprs = null { syntaxOprss = pow oprs }

syntaxBlks ‚à∑ (ToIter ùïä t) ‚áí t ‚Üí Syntax
syntaxBlks blks = null { syntaxBlkss = pow blks }

regexSyntax ‚à∑ (Ord u,Additive u) ‚áí Syntax ‚Üí Regex StdCharClass ‚ÑÇ TokenClass u
regexSyntax (Syntax brks puns keys prms oprs blks) = 
  concat
  -- punctuation and brackets
  [ sequence
    [ concat $ map lWord $ concat
        [ iter puns
        , iter $ unions $ mapOn (iter brks) $ uncurry $ \ open (seps :* closes) ‚Üí 
            unions [single open,seps,closes]
        ]
    , fepsRegex $ formats [FG grayDark]
    , oepsRegex Syntax_TC
    ]
  -- keywords
  , sequence
    [ concat $ map lWord $ iter keys
    , fepsRegex $ formats [FG yellow,BD]
    , oepsRegex Syntax_TC
    ]
  -- primitives
  , sequence
    [ concat $ map lWord $ iter prms
    , fepsRegex $ formats [FG blue]
    , oepsRegex Syntax_TC
    ]
  -- operators
  , sequence
    [ concat $ map lWord $ iter oprs
    , fepsRegex $ formats [FG teal]
    , oepsRegex Syntax_TC
    ]
  -- blocks
  , sequence
    [ concat $ map lWord $ iter blks
    , fepsRegex $ formats [BG white,FG yellow,BD]
    , oepsRegex Block_TC
    ]
  ]

lToken ‚à∑ Syntax ‚Üí Regex StdCharClass ‚ÑÇ TokenClass ‚Ñ§64
lToken syntax = 
  concat
  [ lNatCoded         ‚ñ∑ oepsRegex Nat_TC
  , lInt              ‚ñ∑ oepsRegex Int_TC
  , lDbl              ‚ñ∑ oepsRegex Dbl_TC
  , lString           ‚ñ∑ oepsRegex String_TC
  , lName             ‚ñ∑ oepsRegex Name_TC
  , lSpace            ‚ñ∑ oepsRegex Space_TC
  , lNL               ‚ñ∑ oepsRegex Newline_TC
  , lComment          ‚ñ∑ oepsRegex Comment_TC
  , lCommentMLOpen    ‚ñ∑ oepsRegex Comment_TC
  , regexSyntax syntax
  ]

lTokenCommentMLBody ‚à∑ Regex StdCharClass ‚ÑÇ TokenClass ‚Ñ§64
lTokenCommentMLBody = lCommentMLBody ‚ñ∑ oepsRegex Comment_TC

dfaSyntax ‚à∑ Syntax ‚Üí ‚Ñ§64 ‚Üí DFA StdCharClass ‚ÑÇ TokenClass ‚Ñ§64
dfaSyntax syntax =
  let dfaTokenBasic = compileRegex $ lToken syntax
      dfaCommentMLBasic = compileRegex lTokenCommentMLBody
      dfa n | n ‚â° 0 = dfaTokenBasic
            | n > 0 = dfaCommentMLBasic
            | otherwise = error "impossible"
  in dfa

data LexerArgs = LexerArgs
  { lexerArgsAnchorTL ‚à∑ ùîπ
  , lexerArgsSyntax ‚à∑ Syntax
  }

data Lexer = Lexer 
  { lexerLexerArgs ‚à∑ LexerArgs
  , lexerGenLexer ‚à∑ GenLexer StdCharClass ‚ÑÇ TokenClass ‚Ñ§64 Token 
  }

mkLexer ‚à∑ LexerArgs ‚Üí Lexer
mkLexer œÅ = Lexer œÅ $ GenLexer (dfaSyntax $ lexerArgsSyntax œÅ) mkToken zero

mkBlockifyToken ‚à∑ BlockifyToken ‚Üí Token
mkBlockifyToken = \case
  Open_BT ‚Üí BlockOpen_T
  Close_BT ‚Üí BlockClose_T
  Sep_BT ‚Üí BlockSep_T

blockifyArgsLexer ‚à∑ LexerArgs ‚Üí BlockifyArgs Token
blockifyArgsLexer œÅ = BlockifyArgs
  { blockifyArgsAnchorTL = lexerArgsAnchorTL œÅ
  , blockifyArgsMkBlockifyToken = mkBlockifyToken
  , blockifyArgsNewlineToken = Newline_T "\n"
  , blockifyArgsIsBlock = shape block_TL
  , blockifyArgsBrackets = 
      dictùê∑ $ 
      mapOn (iter $ syntaxBrkss $ lexerArgsSyntax œÅ) $ \ (open :* (seps :* closes)) ‚Üí 
        let seps' = dictùê∑ $ mapOn (iter seps) $ \ sep ‚Üí Syntax_T sep ‚Ü¶ sep
            closes' = dictùê∑ $ mapOn (iter closes) $ \ close ‚Üí Syntax_T close ‚Ü¶ close
        in Syntax_T open ‚Ü¶ (open :* seps' :* closes')
  }

lex ‚à∑ Lexer ‚Üí ùïä ‚Üí ùïä ‚Üí Doc ‚à® ùïç (ParserToken Token)
lex l so s = blockify (blockifyArgsLexer $ lexerLexerArgs l) so *$ glex (lexerGenLexer l) so $ tokens s

lexIO ‚à∑ Lexer ‚Üí ùïä ‚Üí ùïä ‚Üí IO (ùïç (ParserToken Token))
lexIO l so ts = case lex l so ts of
  Inl err ‚Üí do 
    pprint $ ppVertical
      [ ppErr "Failure"
      , pretty err
      ]
    abortIO
  Inr ts' ‚Üí return ts'

lexIOMain ‚à∑ Lexer ‚Üí ùïä ‚Üí ùïä ‚Üí IO ()
lexIOMain l so ts = do
  xs ‚Üê lexIO l so ts
  pprint $ ppVertical
    [ ppHeader "Success"
    , pretty $ renderParserTokens xs
    ]

----------------------------
-- Basic Language Parsing --
----------------------------

newtype Parser a = Parser { unParser ‚à∑ GenParser Token a }
  deriving 
  ( Return,Bind,Functor,Monad 
  , MonadFail
  , Null,Append,Monoid
  )

onParser ‚à∑ (GenParser Token a ‚Üí GenParser Token b) ‚Üí Parser a ‚Üí Parser b
onParser f = Parser ‚àò f ‚àò unParser

deriving instance Eps (Parser ())
deriving instance Seq (Parser ())
deriving instance Seqoid (Parser ())

pRender ‚à∑ Formats ‚Üí Parser a ‚Üí Parser a
pRender = onParser ‚àò gpRender

pErr ‚à∑ ùïä ‚Üí Parser a ‚Üí Parser a
pErr = onParser ‚àò gpErr

pFinal ‚à∑ Parser a ‚Üí Parser a
pFinal = onParser gpFinal

pTok ‚à∑ Token ‚Üí Parser ()
pTok = Parser ‚àò gpTok

pTokAny ‚à∑ (ToIter Token t) ‚áí t ‚Üí Parser ()
pTokAny = Parser ‚àò gpTokAny

pTokRet ‚à∑ Token ‚Üí Parser Token
pTokRet = Parser ‚àò gpTokRet

pTokShaped ‚à∑ (Token ‚Üí ùëÇ a) ‚Üí Parser a
pTokShaped = Parser ‚àò gpTokShaped

pTokSat ‚à∑ (Token ‚Üí ùîπ) ‚Üí Parser Token
pTokSat = Parser ‚àò gpTokSat

pAny ‚à∑ Parser Token
pAny = Parser gpAny

pDie ‚à∑ Parser a
pDie = Parser gpDie

pGuard ‚à∑ ùîπ ‚Üí Parser ()
pGuard = Parser ‚àò gpGuard

pFailEff ‚à∑ ùëÇ a ‚Üí Parser a
pFailEff = Parser ‚àò gpFailEff

pNewExpressionContext ‚à∑ Parser a ‚Üí Parser a
pNewExpressionContext = onParser gpNewExpressionContext

pNewErrContext ‚à∑ ùïä ‚Üí Parser a ‚Üí Parser a
pNewErrContext = onParser ‚àò gpNewErrContext

pNewContext ‚à∑ ùïä ‚Üí Parser a ‚Üí Parser a
pNewContext = onParser ‚àò gpNewContext

pWithContextRendered ‚à∑ Parser a ‚Üí Parser (ùê¥ SrcCxt a)
pWithContextRendered = onParser gpWithContextRendered

pNewWithContextRendered ‚à∑ ùïä ‚Üí Parser a ‚Üí Parser (ùê¥ SrcCxt a)
pNewWithContextRendered = onParser ‚àò gpNewWithContextRendered

pGetContextRendered ‚à∑ Parser SrcCxt
pGetContextRendered = Parser gpGetContextRendered

pNewGetContextRendered ‚à∑ Parser SrcCxt
pNewGetContextRendered = Parser gpNewGetContextRendered

pTokName ‚à∑ Parser ùïä
pTokName = Parser $ gpTokShaped $ view name_TL

pTokSyntax ‚à∑ ùïä ‚Üí Parser ()
pTokSyntax = Parser ‚àò gpTok ‚àò Syntax_T

pTokSyntaxAny ‚à∑ (ToIter ùïä t) ‚áí t ‚Üí Parser ()
pTokSyntaxAny = Parser ‚àò gpTokAny ‚àò map Syntax_T ‚àò iter

pTokNatN ‚à∑ Parser ‚Ñï
pTokNatN = Parser $ gpTokShaped $ view nat_TL

pTokNatN64 ‚à∑ Parser ‚Ñï64
pTokNatN64 = Parser ‚àò failEff ‚àò natO64 *$ pTokNatN

pTokInt ‚à∑ Parser ‚Ñ§
pTokInt = Parser $ gpTokShaped $ view int_TL

pTokInt64 ‚à∑ Parser ‚Ñ§64
pTokInt64 = failEff ‚àò intO64 *$ pTokInt

pTokNat ‚à∑ Parser ‚Ñï
pTokNat = failEff ‚àò natO *$ pTokInt

pTokNat64 ‚à∑ Parser ‚Ñï64
pTokNat64 = failEff ‚àò natO64 *$ pTokInt

pTokDouble ‚à∑ Parser ùîª
pTokDouble = Parser $ gpTokShaped $ view dbl_TL

pTokString ‚à∑ Parser ùïä
pTokString = Parser $ gpTokShaped $ view string_TL

pTokChar ‚à∑ Parser ‚ÑÇ
pTokChar = Parser $ gpTokShaped $ view char_TL

pTokBlock ‚à∑ ùïä ‚Üí Parser ()
pTokBlock = Parser ‚àò gpTok ‚àò Block_T

pTokOpen ‚à∑ Parser ()
pTokOpen = Parser $ gpTok BlockOpen_T

pTokClose ‚à∑ Parser ()
pTokClose = Parser $ gpTok BlockClose_T

pTokSep ‚à∑ Parser ()
pTokSep = Parser $ gpTok BlockSep_T

parse ‚à∑ (ToIter (ParserToken Token) ts) ‚áí Parser a ‚Üí ùïä ‚Üí ts ‚Üí Doc ‚à® a
parse p so ts = gparse (unParser p) so ts

parseIO ‚à∑ (ToIter (ParserToken Token) ts) ‚áí Parser a ‚Üí ùïä ‚Üí ts ‚Üí IO a
parseIO p so ts = gparseIO (unParser p) so ts

parseIOMain ‚à∑ (Pretty a,ToIter (ParserToken Token) ts) ‚áí Parser a ‚Üí ùïä ‚Üí ts ‚Üí IO ()
parseIOMain p so ts = gparseIOMain (unParser p) so ts

lexParse ‚à∑ Lexer ‚Üí Parser a ‚Üí ùïä ‚Üí ùïä ‚Üí Doc ‚à® Doc ‚à® a
lexParse l p so = (mapInl Inr ‚àò parse p so) *‚àò (mapInl Inl ‚àò lex l so)

lexParseIO ‚à∑ Lexer ‚Üí Parser a ‚Üí ùïä ‚Üí ùïä ‚Üí IO a
lexParseIO l p so s = parseIO p so *$ lexIO l so s

lexParseIOMain ‚à∑ (Pretty a) ‚áí Lexer ‚Üí Parser a ‚Üí ùïä ‚Üí ùïä ‚Üí IO ()
lexParseIOMain l p so s = parseIOMain p so *$ lexIO l so s

------------
-- MIXFIX --
------------

data Mixes c a = Mixes
  { mixesPrefix  ‚à∑ Parser (ùê¥ c a ‚Üí a)
  , mixesPostfix ‚à∑ Parser (ùê¥ c a ‚Üí a)
  , mixesInfix  ‚à∑ Parser (ùê¥ c a ‚Üí ùê¥ c a ‚Üí a)
  , mixesInfixL ‚à∑ Parser (ùê¥ c a ‚Üí ùê¥ c a ‚Üí a)
  , mixesInfixR ‚à∑ Parser (ùê¥ c a ‚Üí ùê¥ c a ‚Üí a)
  }

instance Null (Mixes c a) where null = Mixes null null null null null
instance Append (Mixes c a) where
  Mixes pre‚ÇÅ post‚ÇÅ inf‚ÇÅ infl‚ÇÅ infr‚ÇÅ ‚ß∫ Mixes pre‚ÇÇ post‚ÇÇ inf‚ÇÇ infl‚ÇÇ infr‚ÇÇ =
    Mixes (pre‚ÇÅ ‚ß∫ pre‚ÇÇ) (post‚ÇÅ ‚ß∫ post‚ÇÇ) (inf‚ÇÅ ‚ß∫ inf‚ÇÇ) (infl‚ÇÅ ‚ß∫ infl‚ÇÇ) $ infr‚ÇÅ ‚ß∫ infr‚ÇÇ
instance Monoid (Mixes c a)

data Mixfix c a = Mixfix
  { mixfixTerminals ‚à∑ Parser a
  , mixfixLevels ‚à∑ ‚Ñï64 ‚á∞ Mixes c a
  }
instance Null (Mixfix c a) where null = Mixfix null null
instance Append (Mixfix c a) where Mixfix ts‚ÇÅ ls‚ÇÅ ‚ß∫ Mixfix ts‚ÇÇ ls‚ÇÇ = Mixfix (ts‚ÇÅ ‚ß∫ ts‚ÇÇ) (ls‚ÇÅ ‚ß∫ ls‚ÇÇ)
instance Monoid (Mixfix c a)

mixOnlyTerms ‚à∑ Mixfix c a ‚Üí Mixfix c a
mixOnlyTerms m = Mixfix (mixfixTerminals m) null

mixPrefix ‚à∑ ‚Ñï64 ‚Üí Parser (ùê¥ c a ‚Üí a) ‚Üí Mixfix c a
mixPrefix l p = null { mixfixLevels = dict [ l ‚Ü¶ null { mixesPrefix = p } ] }

mixPostfix ‚à∑ ‚Ñï64 ‚Üí Parser (ùê¥ c a ‚Üí a) ‚Üí Mixfix c a
mixPostfix l p = null { mixfixLevels = dict [ l ‚Ü¶ null { mixesPostfix = p } ] }

mixInfix ‚à∑ ‚Ñï64 ‚Üí Parser (ùê¥ c a ‚Üí ùê¥ c a ‚Üí a) ‚Üí Mixfix c a
mixInfix l p = null { mixfixLevels = dict [ l ‚Ü¶ null { mixesInfix = p } ] }

mixInfixL ‚à∑ ‚Ñï64 ‚Üí Parser (ùê¥ c a ‚Üí ùê¥ c a ‚Üí a) ‚Üí Mixfix c a
mixInfixL l p = null { mixfixLevels = dict [ l ‚Ü¶ null { mixesInfixL = p } ] }

mixInfixR ‚à∑ ‚Ñï64 ‚Üí Parser (ùê¥ c a ‚Üí ùê¥ c a ‚Üí a) ‚Üí Mixfix c a
mixInfixR l p = null { mixfixLevels = dict [ l ‚Ü¶ null { mixesInfixR = p } ] }

mixTerminal ‚à∑ Parser a ‚Üí Mixfix c a
mixTerminal p = null { mixfixTerminals = p }

mixfix ‚à∑ (SrcCxt ‚Üí c) ‚Üí ùïä ‚Üí Mixfix c a ‚Üí Parser (ùê¥ c a)
mixfix f s m = 
  let m' = GenMixfixF
        { genMixfixFTerminals = unParser $ mixfixTerminals m
        , genMixfixFLevels = mapOn (mixfixLevels m) $ \ ms ‚Üí GenMixesF
            { genMixesFPrefix = unParser $ mixesPrefix ms
            , genMixesFPostfix = unParser $ mixesPostfix ms
            , genMixesFInfix = unParser $ mixesInfix ms
            , genMixesFInfixL = unParser $ mixesInfixL ms
            , genMixesFInfixR = unParser $ mixesInfixR ms
            }
        }
  in
  Parser $ gfmixfix (gpNewContext s) gpNewExpressionContext (map (mapATag f) ‚àò gpWithContextRendered) m'
