module UVMHS.Core.Matrix where

-- -- vectors --
--
-- data Bá´ (m âˆ· Tâ„•) (n âˆ· Tâ„•) a where
--   Bá´ âˆ· (Râ„• m,Râ„• n)
--      â‡’ { rowsBá´ âˆ· Sâ„•32 m
--        , colsBá´ âˆ· Sâ„•32 n
--        , dataBá´ âˆ· Repa.Array Repa.V (Repa.Z Repa.:. HS.Int Repa.:. HS.Int) a
--        }
--      â†’ Bá´ m n a
-- data Uá´ (m âˆ· Tâ„•) (n âˆ· Tâ„•) a where
--   Uá´ âˆ· (Râ„• m,Râ„• n,Repa.Unbox a)
--      â‡’ { rowsUá´ âˆ· Sâ„•32 m
--        , colsUá´ âˆ· Sâ„•32 n
--        , dataUá´ âˆ· Repa.Array Repa.U (Repa.Z Repa.:. HS.Int Repa.:. HS.Int) a
--        }
--      â†’ Uá´ m n a
-- data Vá´ (m âˆ· Tâ„•) (n âˆ· Tâ„•) a where
--   Vá´ âˆ· (Râ„• m,Râ„• n)
--      â‡’ { rowsVá´ âˆ· Sâ„•32 m
--        , colsVá´ âˆ· Sâ„•32 n
--        , dataVá´ âˆ· Repa.Array Repa.D (Repa.Z Repa.:. HS.Int Repa.:. HS.Int) a
--        }
--      â†’ Vá´ m n a
--
-- infixl 7 ğ„ª
-- class Matrix t where
--   xrows âˆ· t m n a â†’ Sâ„•32 m
--   xcols âˆ· t m n a â†’ Sâ„•32 n
--   (ğ„ª) âˆ· t m n a â†’ (ğ•€32 m,ğ•€32 n) â†’ a
--   xvirt âˆ· t m n a â†’ Vá´ m n a
--
-- -- boxed --
--
-- indexBá´ âˆ· ğ•€32 m â†’ ğ•€32 n â†’ Bá´ m n a â†’ a
-- indexBá´ i j xs = Repa.unsafeIndex (dataBá´ xs) (Repa.Z Repa.:. HS.fromIntegral (unğ•€32 i) Repa.:. HS.fromIntegral (unğ•€32 j))
--
-- virtBá´ âˆ· Bá´ m n a â†’ Vá´ m n a
-- virtBá´ (Bá´ m n xs) = Vá´ m n $ Repa.delay xs
--
-- instance Matrix Bá´ where
--   xrows = rowsBá´
--   xcols = colsBá´
--   xs ğ„ª (i,j) = indexBá´ i j xs
--   xvirt = virtBá´
--
-- -- unboxed --
--
-- indexUá´ âˆ· ğ•€32 m â†’ ğ•€32 n â†’ Uá´ m n a â†’ a
-- indexUá´ i j (Uá´ _ _ xs) = Repa.unsafeIndex xs (Repa.Z Repa.:. HS.fromIntegral (unğ•€32 i) Repa.:. HS.fromIntegral (unğ•€32 j))
--
-- virtUá´ âˆ· Uá´ m n a â†’ Vá´ m n a
-- virtUá´ (Uá´ m n xs) = Vá´ m n $ Repa.delay xs
--
-- instance Matrix Uá´ where
--   xrows = rowsUá´
--   xcols = colsUá´
--   xs ğ„ª (i,j) = indexUá´ i j xs
--   xvirt = virtUá´
--
-- -- virtual --
--
-- indexVá´ âˆ· ğ•€32 m â†’ ğ•€32 n â†’ Vá´ m n a â†’ a
-- indexVá´ i j xs = Repa.unsafeIndex (dataVá´ xs) (Repa.Z Repa.:. HS.fromIntegral (unğ•€32 i) Repa.:. HS.fromIntegral (unğ•€32 j))
--
-- instance Matrix Vá´ where
--   xrows = rowsVá´
--   xcols = colsVá´
--   xs ğ„ª (i,j) = indexVá´ i j xs
--   xvirt = id
--
-- matrix âˆ· (Râ„• m,Râ„• n) â‡’ Sâ„•32 m â†’ Sâ„•32 n â†’ (ğ•€32 m â†’ ğ•€32 n â†’ a) â†’ Vá´ m n a
-- matrix m n f =
--   Vá´ m n $ Repa.fromFunction (Repa.Z Repa.:. HS.fromIntegral (unSâ„•32 m) Repa.:. HS.fromIntegral (unSâ„•32 n)) $ \ (Repa.Z Repa.:. i Repa.:. j) â†’
--     dğ•Ÿ32 (HS.fromIntegral i) $ \ i' â†’
--       dğ•Ÿ32 (HS.fromIntegral j) $ \ j' â†’
--         f (ğ•€32 i' TRUSTME_LT) (ğ•€32 j' TRUSTME_LT)
--
-- xconst âˆ· (Râ„• m,Râ„• n) â‡’ Sâ„•32 m â†’ Sâ„•32 n â†’ a â†’ Vá´ m n a
-- xconst m n x = matrix m n $ \ _ _ â†’ x
--
-- xbs âˆ· Vá´ m n a â†’ Bá´ m n a
-- xbs (Vá´ m n xs) = Bá´ m n $ Repa.computeS xs
--
-- xbp âˆ· Vá´ m n a â†’ Bá´ m n a
-- xbp (Vá´ m n xs) = Bá´ m n $ HS.runIdentity $ Repa.computeP xs
--
-- xus âˆ· (Repa.Unbox a) â‡’ Vá´ m n a â†’ Uá´ m n a
-- xus (Vá´ m n xs) = Uá´ m n $ Repa.computeS xs
--
-- xup âˆ· (Repa.Unbox a) â‡’ Vá´ m n a â†’ Uá´ m n a
-- xup (Vá´ m n xs) = Uá´ m n $ HS.runIdentity $ Repa.computeP xs
--
-- xiter âˆ· Vá´ m n a â†’ ğ¼ a
-- xiter xs = iter $ Repa.toList $ dataVá´ xs
--
-- instance ToIter a (Bá´ m n a) where iter = iter âˆ˜ xvirt
-- instance ToIter a (Uá´ m n a) where iter = iter âˆ˜ xvirt
-- instance ToIter a (Vá´ m n a) where iter = xiter
--
-- -------------
-- -- DERIVED --
-- -------------
--
-- xtranspose âˆ· Vá´ m n a â†’ Vá´ n m a
-- xtranspose xs@(Vá´ _ _ _) = matrix (xcols xs) (xrows xs) $ \ j i â†’ xs ğ„ª (i,j)
--
-- xmap âˆ· (a â†’ b) â†’ Vá´ m n a â†’ Vá´ m n b
-- xmap f xs@(Vá´ _ _ _) = matrix (xrows xs) (xcols xs) $ \ i j â†’ f $ xs ğ„ª (i,j)
--
-- instance Functor (Vá´ m n) where map = xmap
--
-- xmap2 âˆ· (a â†’ b â†’ c) â†’ Vá´ m n a â†’ Vá´ m n b â†’ Vá´ m n c
-- xmap2 f xs@(Vá´ _ _ _) ys@(Vá´ _ _ _) = matrix (xrows xs) (xcols xs) $ \ i j â†’ f (xs ğ„ª (i,j)) (ys ğ„ª (i,j))
--
-- xmeld âˆ· (Râ„• n) â‡’ Sâ„•32 n â†’ Vá´ m 1 (Vá´ 1 n a) â†’ Vá´ m n a
-- xmeld n xys@(Vá´ _ _ _) = matrix (xrows xys) n $ \ i j â†’ indexVá´ (sğ•š @ 0 P) j $ indexVá´ i (sğ•š @ 0 P) xys
--
-- xsplit âˆ· Vá´ m n a â†’ Vá´ m 1 (Vá´ 1 n a)
-- xsplit xys@(Vá´ _ _ _) = matrix (xrows xys) (sğ•Ÿ32 @ 1) $ \ i _ â†’ matrix (sğ•Ÿ32 @ 1) (colsVá´ xys) $ \ _ j â†’ indexVá´ i j xys
--
-- xrow âˆ· ğ•€32 m â†’ Vá´ m n a â†’ Vá´ 1 n a
-- xrow i xs@(Vá´ _ _ _) = matrix (sğ•Ÿ32 @ 1) (colsVá´ xs) $ \ _ j â†’ indexVá´ i j xs
--
-- xcol âˆ· ğ•€32 n â†’ Vá´ m n a â†’ Vá´ 1 m a
-- xcol i xs = xrow i $ xtranspose xs
--
-- xproduct âˆ· (Additive a,Times a) â‡’ Vá´ m n a â†’ Vá´ n o a â†’ Vá´ m o a
-- xproduct xs@(Vá´ _ _ _) ys@(Vá´ _ _ _) =
--   matrix (xrows xs) (xcols ys) $ \ i k â†’
--     let râ‚ = xrow i xs
--         râ‚‚ = xcol k ys
--     in sum $ iter $ xmap2 (Ã—) râ‚ râ‚‚
--
-- xbmapM âˆ· (Monad m) â‡’ (a â†’ m b) â†’ Vá´ n o a â†’ m (Bá´ n o b)
-- xbmapM f xs@(Vá´ _ _ _) = do
--   xs' â† mapM (mapM f) $ xlist2 xs
--   return $ xb xs' $ \ (Bá´ _ _ xs'') â†’ Bá´ (xrows xs) (xcols xs) xs''
--
-- xumapM âˆ· (Monad m,Repa.Unbox a,Repa.Unbox b) â‡’ (a â†’ m b) â†’ Vá´ n o a â†’ m (Uá´ n o b)
-- xumapM f xs@(Vá´ _ _ _) = do
--   xs' â† mapM (mapM f) $ xlist2 xs
--   return $ xu xs' $ \ (Uá´ _ _ xs'') â†’ Uá´ (xrows xs) (xcols xs) xs''
--
-- xindirect âˆ· Vá´ m n a â†’ Vá´ 1 o (ğ•€32 m) â†’ Vá´ o n a
-- xindirect xs@(Vá´ _ _ _) is@(Vá´ _ _ _) = matrix (xcols is) (xcols xs) $ \ o n â†’ xs ğ„ª (is ğ„ª (sğ•š @ 0 P,o),n)
--
-- xiter2 âˆ· Vá´ m n a â†’ ğ¼ (ğ¼ a)
-- xiter2 = map iter âˆ˜ iter âˆ˜ xsplit
--
-- xlist2 âˆ· Vá´ m n a â†’ ğ¿ (ğ¿ a)
-- xlist2 = list âˆ˜ map list âˆ˜ xiter2
--
-- xbğ¼ âˆ· ğ¼ (ğ¼ a) â†’ (âˆ€ m n. (Râ„• m,Râ„• n) â‡’ Bá´ m n a â†’ b) â†’ b
-- xbğ¼ xs f =
--   let uc = joins $ map (natÎ©32 âˆ˜ count) xs
--       lc = meets $ map (AddTop âˆ˜ natÎ©32 âˆ˜ count) xs
--   in case AddTop uc â‰¡ lc of
--     True â†’
--       dğ•Ÿ32 uc $ \ n â†’
--       dğ•Ÿ32 (natÎ©32 $ count xs) $ \ m â†’
--         f $ Bá´ m n $ Repa.fromList (Repa.Z Repa.:. HS.fromIntegral (unSâ„•32 m) Repa.:. HS.fromIntegral (unSâ„•32 n)) $ lazyList $ concat xs
--     False â†’ error "`xbğ¿`: bad input list: input list is either empty (no columns) or has columns of different length"
--
-- xb âˆ· (ToIter a t,ToIter t u) â‡’ u â†’ (âˆ€ m n. (Râ„• m,Râ„• n) â‡’ Bá´ m n a â†’ b) â†’ b
-- xb xs f = xbğ¼ (map iter (iter xs)) f
--
-- xuğ¼ âˆ· (Repa.Unbox a) â‡’ ğ¼ (ğ¼ a) â†’ (âˆ€ m n. (Râ„• m,Râ„• n) â‡’ Uá´ m n a â†’ b) â†’ b
-- xuğ¼ xs f =
--   let uc = joins $ map (natÎ©32 âˆ˜ count) xs
--       lc = meets $ map (AddTop âˆ˜ natÎ©32 âˆ˜ count) xs
--   in case AddTop uc â‰¡ lc of
--     True â†’
--       dğ•Ÿ32 uc $ \ n â†’
--       dğ•Ÿ32 (natÎ©32 $ count xs) $ \ m â†’
--         f $ Uá´ m n $ Repa.fromList (Repa.Z Repa.:. HS.fromIntegral (unSâ„•32 m) Repa.:. HS.fromIntegral (unSâ„•32 n)) $ lazyList $ concat xs
--     False â†’ error "`xbğ¿`: bad input list: input list is either empty (no columns) or has columns of different length"
--
-- xu âˆ· (Repa.Unbox a,ToIter a t,ToIter t u) â‡’ u â†’ (âˆ€ m n. (Râ„• m,Râ„• n) â‡’ Uá´ m n a â†’ b) â†’ b
-- xu xs f = xuğ¼ (map iter (iter xs)) f
--
-- instance (Times a) â‡’ Times (Vá´ m n a) where (Ã—) = xmap2 (Ã—)
--
-- (âœ–) âˆ· (Additive a,Times a) â‡’ Vá´ m n a â†’ Vá´ n o a â†’ Vá´ m o a
-- (âœ–) = xproduct
--
-- testMatrix1 âˆ· IO ()
-- testMatrix1 = do
--   let xs = list [list [1,2,3],list [4,5,6],list [7,8,9]]
--   shout xs
--   xb xs $ \ xs' â†’ do
--     let ys = xlist2 $ xtranspose $ xvirt xs'
--     shout ys
--
