-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient Arrays
--   
--   . An efficient implementation of <tt>Int</tt>-indexed arrays (both
--   mutable and immutable), with a powerful loop optimisation framework .
--   . It is structured as follows: . [<a>Data.Vector</a>] Boxed vectors of
--   arbitrary types. . [<a>Data.Vector.Unboxed</a>] Unboxed vectors with
--   an adaptive representation based on data type families. .
--   [<a>Data.Vector.Storable</a>] Unboxed vectors of <a>Storable</a>
--   types. . [<a>Data.Vector.Primitive</a>] Unboxed vectors of primitive
--   types as defined by the <tt>primitive</tt> package.
--   <a>Data.Vector.Unboxed</a> is more flexible at no performance cost. .
--   [<a>Data.Vector.Generic</a>] Generic interface to the vector types. .
--   There is also a (draft) tutorial on common uses of vector. . *
--   <a>http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial</a>
@package vector
@version 0.13.2.0

module Bench.Vector.Algo.AwShCC
awshcc :: (Int, Vector Int, Vector Int) -> Vector Int

module Bench.Vector.Algo.FindIndexR
findIndexR :: (Double -> Bool, Vector Double) -> Maybe Int
findIndexR_naive :: (Double -> Bool, Vector Double) -> Maybe Int
findIndexR_manual :: (Double -> Bool, Vector Double) -> Maybe Int

module Bench.Vector.Algo.HybCC
hybcc :: (Int, Vector Int, Vector Int) -> Vector Int

module Bench.Vector.Algo.Leaffix
leaffix :: (Vector Int, Vector Int) -> Vector Int

module Bench.Vector.Algo.ListRank
listRank :: Int -> Vector Int

module Bench.Vector.Algo.MutableSet
mutableSet :: IOVector Int -> IO Int

module Bench.Vector.Algo.NextPermutation

-- | Generate a list of benchmarks for permutation algorithms. The list
--   contains pairs of benchmark names and corresponding actions. The
--   actions are to be executed by the benchmarking framework.
--   
--   The list contains the following benchmarks: -
--   <tt>(next|prev)Permutation</tt> on a small vector repeated until the
--   end of the permutation cycle - Bijective versions of
--   <tt>(next|prev)Permutation</tt> on a vector of size <tt>n</tt>,
--   repeated <tt>n</tt> times - ascending permutation - descending
--   permutation - random permutation - Baseline for bijective versions:
--   just copying a vector of size <tt>n</tt>. Note that the tests for
--   bijective versions begins with copying a vector.
generatePermTests :: StatefulGen g IO => g -> Int -> IO [(String, IO ())]

module Bench.Vector.Algo.Quickhull
quickhull :: (Vector Double, Vector Double) -> (Vector Double, Vector Double)

module Bench.Vector.Algo.Rootfix
rootfix :: (Vector Int, Vector Int) -> Vector Int

module Bench.Vector.Algo.Spectral
spectral :: Vector Double -> Vector Double

module Bench.Vector.Algo.Tridiag
tridiag :: (Vector Double, Vector Double, Vector Double, Vector Double) -> Vector Double


-- | Tasty integration for vector benchmarks.
module Bench.Vector.Tasty

-- | Size of vector used in benchmarks
newtype VectorSize
VectorSize :: Int -> VectorSize

-- | Random seed used for generation of the test data
newtype RandomSeed
RandomSeed :: Int -> RandomSeed
instance Test.Tasty.Options.IsOption Bench.Vector.Tasty.RandomSeed
instance Test.Tasty.Options.IsOption Bench.Vector.Tasty.VectorSize

module Bench.Vector.TestData.Graph
randomGraph :: (StatefulGen g m, PrimMonad m) => g -> Int -> m (Int, Vector Int, Vector Int)

module Bench.Vector.TestData.ParenTree
parenTree :: Int -> (Vector Int, Vector Int)
