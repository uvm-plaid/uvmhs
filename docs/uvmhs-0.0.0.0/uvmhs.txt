-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package uvmhs
@version 0.0.0.0

module UVMHS.Core.Init
data ℝ
Integer :: ℤ -> ℝ
Rational :: ℚ -> ℝ
Double :: 𝔻 -> ℝ
data ℝᴾ
Natural :: ℕ -> ℝᴾ
Rationalᴾ :: ℚᴾ -> ℝᴾ
Doubleᴾ :: 𝔻ᴾ -> ℝᴾ
data Void
assert :: 𝔹 -> ()
data Nat
Z :: Nat
S :: Nat -> Nat
fromRational :: Rational -> 𝔻
($) :: (a -> b) -> a -> b
infixr 0 $
fail :: forall a m. STACK => [ℂ] -> m a
error :: STACK => 𝕊 -> a
uncurry :: ((a ∧ b) -> c) -> a -> b -> c
id :: a -> a
with :: W c -> (c => a) -> a
const :: a -> b -> a
negate :: ℕ -> ℤ
not :: 𝔹 -> 𝔹
flip :: (a -> b -> c) -> b -> a -> c
rotateL :: (a -> b -> c -> d) -> b -> c -> a -> d
rotateR :: (a -> b -> c -> d) -> c -> a -> b -> d
curry :: (a -> b -> c) -> (a ∧ b) -> c
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
data (a :: k) ≟ (b :: k)
[Refl] :: forall k (a :: k). a ≟ a
data 𝐿 a
Nil :: 𝐿 a
(:&) :: a -> 𝐿 a -> 𝐿 a
infixr 8 :&
data W c
[W] :: forall c. c => W c
data P (a :: k)
P :: P (a :: k)
unpack :: Ex t -> (forall (a :: k). () => t a -> b) -> b
data Lazy a
Lazy :: ~a -> Lazy a
[unLazy] :: Lazy a -> ~a
data 𝑂 a
None :: 𝑂 a
Some :: a -> 𝑂 a
type 𝔹 = Bool
type ℕ64 = Word64
newtype 𝑄 a
𝑄 :: Seq a -> 𝑄 a
[un𝑄] :: 𝑄 a -> Seq a
type 𝕊 = Text
newtype k ⇰ v
𝐷 :: Map k v -> (⇰) k v
[un𝐷] :: (⇰) k v -> Map k v
infixr 1 ⇰
(⩔) :: 𝔹 -> 𝔹 -> 𝔹
infixl 2 ⩔
(⩓) :: 𝔹 -> 𝔹 -> 𝔹
infixl 3 ⩓
data a ∨ b
Inl :: a -> (∨) a b
Inr :: b -> (∨) a b
infixl 5 ∨
data a ∧ b
(:*) :: a -> b -> (∧) a b
infixl 6 ∧
infixl 8 :*
(∘) :: (b -> c) -> (a -> b) -> a -> c
infixl 7 ∘
type ℕ = Natural
type ℕ32 = Word32
type ℕ16 = Word16
type ℕ8 = Word8
type ℤ = Integer
type ℤ64 = Int64
type ℤ32 = Int32
type ℤ16 = Int16
type ℤ8 = Int8
type ℚ = Rational
type ℚᴾ = Ratio ℕ
type 𝔻 = Double
newtype 𝔻ᴾ
𝔻ᴾ :: 𝔻 -> 𝔻ᴾ
[un𝔻ᴾ] :: 𝔻ᴾ -> 𝔻
cond :: 𝔹 -> a -> a -> a
elim𝔹 :: a -> a -> 𝔹 -> a
type ℂ = Char
exfalso :: Void -> a
newtype 𝐼 a
𝐼 :: (forall b. () => (a -> b -> (b -> b) -> b) -> b -> (b -> b) -> b) -> 𝐼 a
[un𝐼] :: 𝐼 a -> forall b. () => (a -> b -> (b -> b) -> b) -> b -> (b -> b) -> b
run𝐼 :: (b -> b) -> b -> (a -> b -> (b -> b) -> b) -> 𝐼 a -> b
run𝐼On :: 𝐼 a -> (b -> b) -> b -> (a -> b -> (b -> b) -> b) -> b
foldk𝐼 :: b -> (a -> b -> (b -> b) -> b) -> 𝐼 a -> b
fold𝐼 :: b -> (a -> b -> b) -> 𝐼 a -> b
foldr𝐼 :: b -> (a -> b -> b) -> 𝐼 a -> b
map𝐼 :: (a -> b) -> 𝐼 a -> 𝐼 b
null𝐼 :: 𝐼 a
single𝐼 :: a -> 𝐼 a
list𝐼 :: 𝐼 a -> 𝐿 a
iter𝐿 :: 𝐿 a -> 𝐼 a
lazyList𝐼 :: 𝐼 a -> [a]
iterLL :: [a] -> 𝐼 a
newtype 𝑆 a
𝑆 :: (() -> 𝑂 (a ∧ 𝑆 a)) -> 𝑆 a
[un𝑆] :: 𝑆 a -> () -> 𝑂 (a ∧ 𝑆 a)
newtype 𝑃 a
𝑃 :: Set a -> 𝑃 a
[un𝑃] :: 𝑃 a -> Set a
coerce_UNSAFE :: a -> b
weq_UNSAFE :: forall {k} (a :: k) (b :: k). P a -> P b -> W (a ~ b)
void_UNSAFE :: Void
data Ex (t :: k -> Type)
[Ex] :: forall k (t :: k -> Type) (a :: k). t a -> Ex t
data Ex_C (c :: k -> Constraint) (t :: k -> Type)
[Ex_C] :: forall k (c :: k -> Constraint) (t :: k -> Type) (a :: k). c a => t a -> Ex_C c t
unpack_C :: Ex_C c t -> (forall (a :: k). c a => t a -> b) -> b
type STACK = HasCallStack
ifThenElse :: 𝔹 -> a -> a -> a
𝕤 :: [ℂ] -> 𝕊
𝕟 :: ℕ -> ℕ
𝕟64 :: ℕ -> ℕ64
𝕟32 :: ℕ -> ℕ32
𝕟16 :: ℕ -> ℕ16
𝕟8 :: ℕ -> ℕ8
𝕫 :: ℕ -> ℤ
𝕫64 :: ℕ -> ℤ64
𝕫32 :: ℕ -> ℤ32
𝕫16 :: ℕ -> ℤ16
𝕫8 :: ℕ -> ℤ8
𝕢 :: ℕ -> ℚ
𝕢ᴾ :: ℕ -> ℚᴾ
𝕕ᴾ :: 𝔻 -> 𝔻ᴾ
tohsChars :: 𝕊 -> [ℂ]
frhsChars :: [ℂ] -> 𝕊
appto :: a -> (a -> b) -> b
(∘∘) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
(∘∘∘) :: (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
mirror :: (a -> b -> c -> d) -> c -> b -> a -> d
tohs𝑂F :: (a -> b) -> 𝑂 a -> Maybe b
tohs𝑂 :: 𝑂 a -> Maybe a
frhs𝑂F :: (a -> b) -> Maybe a -> 𝑂 b
frhs𝑂 :: Maybe a -> 𝑂 a
class CHS a b | b -> a
tohs :: CHS a b => a -> b
frhs :: CHS a b => b -> a

-- | The kind of lifted constraints
type Constraint = CONSTRAINT LiftedRep

-- | Return the current <a>CallStack</a>.
--   
--   Does *not* include the call-site of <a>callStack</a>.
callStack :: HasCallStack => CallStack

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | Perform some computation without adding new entries to the
--   <a>CallStack</a>.
withFrozenCallStack :: HasCallStack => (HasCallStack => a) -> a
data Bool
False :: Bool
True :: Bool
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
infix 4 ==

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: HasCallStack => a
fromString :: IsString a => String -> a
instance UVMHS.Core.Init.CHS UVMHS.Core.Init.ℤ64 GHC.Types.Int
instance (UVMHS.Core.Init.CHS a₁ b₁, UVMHS.Core.Init.CHS a₂ b₂) => UVMHS.Core.Init.CHS (a₁ UVMHS.Core.Init.∧ a₂) (b₁, b₂)
instance (UVMHS.Core.Init.CHS a₁ b₁, UVMHS.Core.Init.CHS a₂ b₂, UVMHS.Core.Init.CHS a₃ b₃) => UVMHS.Core.Init.CHS ((a₁ UVMHS.Core.Init.∧ a₂) UVMHS.Core.Init.∧ a₃) (b₁, b₂, b₃)
instance (UVMHS.Core.Init.CHS a₁ b₁, UVMHS.Core.Init.CHS a₂ b₂, UVMHS.Core.Init.CHS a₃ b₃, UVMHS.Core.Init.CHS a₄ b₄) => UVMHS.Core.Init.CHS (((a₁ UVMHS.Core.Init.∧ a₂) UVMHS.Core.Init.∧ a₃) UVMHS.Core.Init.∧ a₄) (b₁, b₂, b₃, b₄)
instance (UVMHS.Core.Init.CHS a₁ b₁, UVMHS.Core.Init.CHS a₂ b₂) => UVMHS.Core.Init.CHS (a₁ UVMHS.Core.Init.∨ a₂) (Data.Either.Either b₁ b₂)
instance UVMHS.Core.Init.CHS a b => UVMHS.Core.Init.CHS (UVMHS.Core.Init.𝐿 a) [b]
instance UVMHS.Core.Init.CHS a b => UVMHS.Core.Init.CHS (UVMHS.Core.Init.𝑂 a) (GHC.Maybe.Maybe b)
instance (a GHC.Types.~ b) => UVMHS.Core.Init.CHS a b
instance GHC.Classes.Eq UVMHS.Core.Init.Nat
instance forall k (a :: k). GHC.Classes.Eq (UVMHS.Core.Init.P a)
instance GHC.Classes.Eq (UVMHS.Core.Init.W c)
instance GHC.Classes.Eq UVMHS.Core.Init.ℝ
instance GHC.Classes.Eq UVMHS.Core.Init.ℝᴾ
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (k UVMHS.Core.Init.⇰ v)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a UVMHS.Core.Init.∧ b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a UVMHS.Core.Init.∨ b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Init.𝐿 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Init.𝑂 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Init.𝑄 a)
instance GHC.Classes.Eq UVMHS.Core.Init.𝔻ᴾ
instance GHC.Float.Floating UVMHS.Core.Init.𝔻ᴾ
instance GHC.Real.Fractional UVMHS.Core.Init.𝔻ᴾ
instance GHC.Generics.Generic (UVMHS.Core.Init.𝑂 a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (UVMHS.Core.Init.𝐿 a)
instance GHC.Num.Num UVMHS.Core.Init.𝔻ᴾ
instance GHC.Classes.Ord UVMHS.Core.Init.Nat
instance forall k (a :: k). GHC.Classes.Ord (UVMHS.Core.Init.P a)
instance GHC.Classes.Ord (UVMHS.Core.Init.W c)
instance GHC.Classes.Ord UVMHS.Core.Init.ℝ
instance GHC.Classes.Ord UVMHS.Core.Init.ℝᴾ
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (k UVMHS.Core.Init.⇰ v)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (a UVMHS.Core.Init.∧ b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (a UVMHS.Core.Init.∨ b)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Init.𝐿 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Init.𝑂 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Init.𝑄 a)
instance GHC.Classes.Ord UVMHS.Core.Init.𝔻ᴾ
instance GHC.Real.Real UVMHS.Core.Init.𝔻ᴾ
instance forall k (t :: k -> *). (forall (a :: k). GHC.Show.Show (t a)) => GHC.Show.Show (UVMHS.Core.Init.Ex t)
instance forall k (c :: k -> GHC.Types.Constraint) (t :: k -> *). (forall (a :: k). c a => GHC.Show.Show (t a)) => GHC.Show.Show (UVMHS.Core.Init.Ex_C c t)
instance GHC.Show.Show UVMHS.Core.Init.Nat
instance forall k (a :: k). GHC.Show.Show (UVMHS.Core.Init.P a)
instance GHC.Show.Show (UVMHS.Core.Init.W c)
instance GHC.Show.Show UVMHS.Core.Init.ℝ
instance GHC.Show.Show UVMHS.Core.Init.ℝᴾ
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a UVMHS.Core.Init.∧ b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a UVMHS.Core.Init.∨ b)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Init.𝑂 a)
instance GHC.Show.Show UVMHS.Core.Init.𝔻ᴾ

module UVMHS.Core.Data.Char
toLower :: ℂ -> ℂ
toUpper :: ℂ -> ℂ
isSpace :: ℂ -> 𝔹
isAlphaNum :: ℂ -> 𝔹
isLetter :: ℂ -> 𝔹
isNumber :: ℂ -> 𝔹
isDigit :: ℂ -> 𝔹
chrFrNat :: ℕ64 -> ℂ
natFrChr :: ℂ -> ℕ64
isLower :: ℂ -> 𝔹
isUpper :: ℂ -> 𝔹

module UVMHS.Core.Classes.Order
(≡) :: Eq a => a -> a -> 𝔹
infix 4 ≡
(≢) :: Eq a => a -> a -> 𝔹
infix 4 ≢
(⋚) :: Ord a => a -> a -> Ordering
infix 4 ⋚
(≤) :: Ord a => a -> a -> 𝔹
infix 4 ≤
(≥) :: Ord a => a -> a -> 𝔹
infix 4 ≥
(<) :: Ord a => a -> a -> 𝔹
infix 4 <
(>) :: Ord a => a -> a -> 𝔹
infix 4 >
(⩏) :: Ord a => a -> a -> a
(⩎) :: Ord a => a -> a -> a
minBy :: Ord b => (a -> b) -> a -> a -> a
maxBy :: Ord b => (a -> b) -> a -> a -> a

module UVMHS.Core.Classes.Morphism
type (m :: Type -> Type) →⁻ (n :: Type -> Type) = forall a. () => m a -> n a
infixr 1 →⁻
type (t :: Type -> Type -> Type -> Type) →⁼ (u :: Type -> Type -> Type -> Type) = forall (m :: Type -> Type). () => t m →⁻ u m
infixr 1 →⁼
class a ⇄ b | a -> b
isoto :: (⇄) a b => a -> b
isofr :: (⇄) a b => b -> a
infixr 1 ⇄
data Iso a b
Iso :: (a -> b) -> (b -> a) -> Iso a b
[ito] :: Iso a b -> a -> b
[ifr] :: Iso a b -> b -> a
toiso :: a ⇄ b => Iso a b
friso :: a ⇄ b => Iso b a
class (t :: Type -> Type) ⇄⁻ (u :: Type -> Type) | t -> u
isoto2 :: (⇄⁻) t u => t →⁻ u
isofr2 :: (⇄⁻) t u => u →⁻ t
infixr 1 ⇄⁻
data Iso2 (t :: Type -> Type) (u :: Type -> Type)
Iso2 :: (t →⁻ u) -> (u →⁻ t) -> Iso2 (t :: Type -> Type) (u :: Type -> Type)
[ito2] :: Iso2 (t :: Type -> Type) (u :: Type -> Type) -> t →⁻ u
[ifr2] :: Iso2 (t :: Type -> Type) (u :: Type -> Type) -> u →⁻ t
toiso2 :: forall (t :: Type -> Type) (u :: Type -> Type). t ⇄⁻ u => Iso2 t u
friso2 :: forall (t :: Type -> Type) (u :: Type -> Type). t ⇄⁻ u => Iso2 u t
class (v :: Type -> Type -> Type -> Type) ⇄⁼ (w :: Type -> Type -> Type -> Type) | v -> w
isoto3 :: (⇄⁼) v w => v →⁼ w
isofr3 :: (⇄⁼) v w => w →⁼ v
infixr 1 ⇄⁼
data Iso3 (v :: Type -> Type -> Type -> Type) (w :: Type -> Type -> Type -> Type)
Iso3 :: (v →⁼ w) -> (w →⁼ v) -> Iso3 (v :: (Type -> Type) -> Type -> Type) (w :: (Type -> Type) -> Type -> Type)
[ito3] :: Iso3 (v :: (Type -> Type) -> Type -> Type) (w :: (Type -> Type) -> Type -> Type) -> v →⁼ w
[ifr3] :: Iso3 (v :: (Type -> Type) -> Type -> Type) (w :: (Type -> Type) -> Type -> Type) -> w →⁼ v
toiso3 :: forall (v :: (Type -> Type) -> Type -> Type) (w :: (Type -> Type) -> Type -> Type). v ⇄⁼ w => Iso3 v w
friso3 :: forall (v :: (Type -> Type) -> Type -> Type) (w :: (Type -> Type) -> Type -> Type). v ⇄⁼ w => Iso3 w v
class Reflexive (t :: k -> k -> Type)
refl :: forall (a :: k). Reflexive t => t a a
class Transitive (t :: k -> k -> Type)
(⊚) :: forall (b :: k) (c :: k) (a :: k). Transitive t => t b c -> t a b -> t a c
infixl 7 ⊚
class (Reflexive t, Transitive t) => Category (t :: k -> k -> Type)
class Symmetric (t :: k -> k -> Type)
sym :: forall (a :: k) (b :: k). Symmetric t => t a b -> t b a
instance UVMHS.Core.Classes.Morphism.Category UVMHS.Core.Classes.Morphism.Iso2
instance UVMHS.Core.Classes.Morphism.Category UVMHS.Core.Classes.Morphism.Iso3
instance UVMHS.Core.Classes.Morphism.Category (->)
instance UVMHS.Core.Classes.Morphism.Category UVMHS.Core.Classes.Morphism.Iso
instance UVMHS.Core.Classes.Morphism.Reflexive UVMHS.Core.Classes.Morphism.Iso2
instance UVMHS.Core.Classes.Morphism.Reflexive UVMHS.Core.Classes.Morphism.Iso3
instance UVMHS.Core.Classes.Morphism.Reflexive (->)
instance UVMHS.Core.Classes.Morphism.Reflexive UVMHS.Core.Classes.Morphism.Iso
instance UVMHS.Core.Classes.Morphism.Symmetric UVMHS.Core.Classes.Morphism.Iso2
instance UVMHS.Core.Classes.Morphism.Symmetric UVMHS.Core.Classes.Morphism.Iso3
instance UVMHS.Core.Classes.Morphism.Symmetric UVMHS.Core.Classes.Morphism.Iso
instance UVMHS.Core.Classes.Morphism.Transitive UVMHS.Core.Classes.Morphism.Iso2
instance UVMHS.Core.Classes.Morphism.Transitive UVMHS.Core.Classes.Morphism.Iso3
instance UVMHS.Core.Classes.Morphism.Transitive (->)
instance UVMHS.Core.Classes.Morphism.Transitive UVMHS.Core.Classes.Morphism.Iso

module UVMHS.Core.Classes.Lattice
class POrd a
(⊑) :: POrd a => a -> a -> 𝔹
infix 4 ⊑
class Bot a
bot :: Bot a => a
class Join a
(⊔) :: Join a => a -> a -> a
infixl 5 ⊔
class (Bot a, Join a) => JoinLattice a
class Top a
top :: Top a => a
class Meet a
(⊓) :: Meet a => a -> a -> a
infixl 6 ⊓
class (Top a, Meet a) => MeetLattice a
class (JoinLattice a, MeetLattice a) => Lattice a
class Dual a
dual :: Dual a => a -> a
class Difference a
(⊟) :: Difference a => a -> a -> a
infixl 5 ⊟
data PartialOrdering
PLT :: PartialOrdering
PEQ :: PartialOrdering
PGT :: PartialOrdering
PUN :: PartialOrdering
(∇) :: POrd a => a -> a -> PartialOrdering
infix 4 ∇
(⊒) :: POrd a => a -> a -> 𝔹
infix 4 ⊒
(⪤) :: POrd a => a -> a -> 𝔹
infix 4 ⪤

module UVMHS.Core.Classes.Functors
newtype NoCostID a
NoCostID :: a -> NoCostID a
class FunctorM (t :: Type -> Type)
mapM :: (FunctorM t, Monad m) => (a -> m b) -> t a -> m (t b)
($dmmapM) :: (FunctorM t, OFunctorM t, Monad m) => (a -> m b) -> t a -> m (t b)
class OFunctorM (t :: Type -> Type)
omapM :: (OFunctorM t, Monad m) => (a -> m (𝑂 b)) -> t a -> m (t b)
class KFunctorM k (t :: Type -> Type) | t -> k
kmapM :: (KFunctorM k t, Monad m) => (k -> a -> m b) -> t a -> m (t b)
($dmkmapM) :: (KFunctorM k t, OKFunctorM k t, Monad m) => (k -> a -> m b) -> t a -> m (t b)
kmapAtM :: (KFunctorM k t, Monad m) => k -> (a -> m a) -> t a -> m (t a)
($dmkmapAtM) :: (KFunctorM k t, OKFunctorM k t, Monad m) => k -> (a -> m a) -> t a -> m (t a)
class OKFunctorM k (t :: Type -> Type) | t -> k
okmapM :: (OKFunctorM k t, Monad m) => (k -> a -> m (𝑂 b)) -> t a -> m (t b)
okmapAtM :: (OKFunctorM k t, Monad m) => k -> (𝑂 a -> m (𝑂 a)) -> t a -> m (t a)
class BiFunctorM (t :: Type -> Type)
bimapM :: forall m a b c. (BiFunctorM t, Monad m) => (a -> m c) -> (b -> m c) -> (a -> b -> m c) -> t a -> t b -> m (t c)
($dmbimapM) :: (BiFunctorM t, OBiFunctorM t, Monad m) => (a -> m c) -> (b -> m c) -> (a -> b -> m c) -> t a -> t b -> m (t c)
class OBiFunctorM (t :: Type -> Type)
obimapM :: forall m a b c. (OBiFunctorM t, Monad m) => (a -> m (𝑂 c)) -> (b -> m (𝑂 c)) -> (a -> b -> m (𝑂 c)) -> t a -> t b -> m (t c)
class KBiFunctorM k (t :: Type -> Type) | t -> k
kbimapM :: forall m a b c. (KBiFunctorM k t, Monad m) => (k -> a -> m c) -> (k -> b -> m c) -> (k -> a -> b -> m c) -> t a -> t b -> m (t c)
($dmkbimapM) :: (KBiFunctorM k t, OKBiFunctorM k t, Monad m) => (k -> a -> m c) -> (k -> b -> m c) -> (k -> a -> b -> m c) -> t a -> t b -> m (t c)
class OKBiFunctorM k (t :: Type -> Type) | t -> k
okbimapM :: forall m a b c. (OKBiFunctorM k t, Monad m) => (k -> a -> m (𝑂 c)) -> (k -> b -> m (𝑂 c)) -> (k -> a -> b -> m (𝑂 c)) -> t a -> t b -> m (t c)
class Functor (t :: Type -> Type)
map :: Functor t => (a -> b) -> t a -> t b
($dmmap) :: (Functor t, FunctorM t) => (a -> b) -> t a -> t b
class OFunctor (t :: Type -> Type)
omap :: OFunctor t => (a -> 𝑂 b) -> t a -> t b
($dmomap) :: (OFunctor t, OFunctorM t) => (a -> 𝑂 b) -> t a -> t b
class KFunctor k (t :: Type -> Type) | t -> k
kmap :: KFunctor k t => (k -> a -> b) -> t a -> t b
($dmkmap) :: (KFunctor k t, KFunctorM k t) => (k -> a -> b) -> t a -> t b
kmapAt :: KFunctor k t => k -> (a -> a) -> t a -> t a
($dmkmapAt) :: (KFunctor k t, KFunctorM k t) => k -> (a -> a) -> t a -> t a
class OKFunctor k (t :: Type -> Type) | t -> k
okmap :: OKFunctor k t => (k -> a -> 𝑂 b) -> t a -> t b
($dmokmap) :: (OKFunctor k t, OKFunctorM k t) => (k -> a -> 𝑂 b) -> t a -> t b
okmapAt :: OKFunctor k t => k -> (𝑂 a -> 𝑂 a) -> t a -> t a
($dmokmapAt) :: (OKFunctor k t, OKFunctorM k t) => k -> (𝑂 a -> 𝑂 a) -> t a -> t a
class BiFunctor (t :: Type -> Type)
bimap :: BiFunctor t => (a -> c) -> (b -> c) -> (a -> b -> c) -> t a -> t b -> t c
($dmbimap) :: forall a b c. (BiFunctor t, BiFunctorM t) => (a -> c) -> (b -> c) -> (a -> b -> c) -> t a -> t b -> t c
class OBiFunctor (t :: Type -> Type)
obimap :: OBiFunctor t => (a -> 𝑂 c) -> (b -> 𝑂 c) -> (a -> b -> 𝑂 c) -> t a -> t b -> t c
($dmobimap) :: forall a b c. (OBiFunctor t, OBiFunctorM t) => (a -> 𝑂 c) -> (b -> 𝑂 c) -> (a -> b -> 𝑂 c) -> t a -> t b -> t c
class KBiFunctor k (t :: Type -> Type)
kbimap :: KBiFunctor k t => (k -> a -> c) -> (k -> b -> c) -> (k -> a -> b -> c) -> t a -> t b -> t c
($dmkbimap) :: forall a b c. (KBiFunctor k t, KBiFunctorM k t) => (k -> a -> c) -> (k -> b -> c) -> (k -> a -> b -> c) -> t a -> t b -> t c
class OKBiFunctor k (t :: Type -> Type)
okbimap :: OKBiFunctor k t => (k -> a -> 𝑂 c) -> (k -> b -> 𝑂 c) -> (k -> a -> b -> 𝑂 c) -> t a -> t b -> t c
($dmokbimap) :: forall a b c. (OKBiFunctor k t, OKBiFunctorM k t) => (k -> a -> 𝑂 c) -> (k -> b -> 𝑂 c) -> (k -> a -> b -> 𝑂 c) -> t a -> t b -> t c
mapMOn :: (FunctorM t, Monad m) => t a -> (a -> m b) -> m (t b)
exchange :: (FunctorM t, Monad m) => t (m a) -> m (t a)
omapMOn :: (OFunctorM t, Monad m) => t a -> (a -> m (𝑂 b)) -> m (t b)
kmapMOn :: (KFunctorM k t, Monad m) => t a -> (k -> a -> m b) -> m (t b)
kmapAtMOn :: (KFunctorM k t, Monad m) => k -> t a -> (a -> m a) -> m (t a)
okmapMOn :: (OKFunctorM k t, Monad m) => t a -> (k -> a -> m (𝑂 b)) -> m (t b)
okmapAtMOn :: (OKFunctorM k t, Monad m) => k -> t a -> (𝑂 a -> m (𝑂 a)) -> m (t a)
bimapMOn :: (BiFunctorM t, Monad m) => t a -> t b -> (a -> m c) -> (b -> m c) -> (a -> b -> m c) -> m (t c)
obimapMOn :: (OBiFunctorM t, Monad m) => t a -> t b -> (a -> m (𝑂 c)) -> (b -> m (𝑂 c)) -> (a -> b -> m (𝑂 c)) -> m (t c)
kbimapMOn :: (KBiFunctorM k t, Monad m) => t a -> t b -> (k -> a -> m c) -> (k -> b -> m c) -> (k -> a -> b -> m c) -> m (t c)
okbimapMOn :: (OKBiFunctorM k t, Monad m) => t a -> t b -> (k -> a -> m (𝑂 c)) -> (k -> b -> m (𝑂 c)) -> (k -> a -> b -> m (𝑂 c)) -> m (t c)
mapOn :: Functor t => t a -> (a -> b) -> t b
mapp :: (Functor t, Functor u) => (a -> b) -> t (u a) -> t (u b)
mappOn :: (Functor t, Functor u) => t (u a) -> (a -> b) -> t (u b)
mappp :: (Functor t, Functor u, Functor v) => (a -> b) -> t (u (v a)) -> t (u (v b))
mapppOn :: (Functor t, Functor u, Functor v) => t (u (v a)) -> (a -> b) -> t (u (v b))
(^$) :: Functor t => (a -> b) -> t a -> t b
infixr 0 ^$
(^^$) :: (Functor t, Functor u) => (a -> b) -> t (u a) -> t (u b)
infixr 0 ^^$
(^∘) :: Functor t => (b -> c) -> (a -> t b) -> a -> t c
infixl 7 ^∘
(^^∘) :: (Functor t, Functor u) => (b -> c) -> (a -> t (u b)) -> a -> t (u c)
infixl 7 ^^∘
omapOn :: OFunctor t => t a -> (a -> 𝑂 b) -> t b
kmapOn :: KFunctor k t => t a -> (k -> a -> b) -> t b
kmapAtOn :: KFunctor k t => k -> t a -> (a -> a) -> t a
okmapOn :: OKFunctor k t => t a -> (k -> a -> 𝑂 b) -> t b
okmapAtOn :: OKFunctor k t => k -> t a -> (𝑂 a -> 𝑂 a) -> t a
bimapOn :: BiFunctor t => t a -> t b -> (a -> c) -> (b -> c) -> (a -> b -> c) -> t c
obimapOn :: OBiFunctor t => t a -> t b -> (a -> 𝑂 c) -> (b -> 𝑂 c) -> (a -> b -> 𝑂 c) -> t c
kbimapOn :: KBiFunctor k t => t a -> t b -> (k -> a -> c) -> (k -> b -> c) -> (k -> a -> b -> c) -> t c
okbimapOn :: OKBiFunctor k t => t a -> t b -> (k -> a -> 𝑂 c) -> (k -> b -> 𝑂 c) -> (k -> a -> b -> 𝑂 c) -> t c
class Functor2 (w :: Type -> Type -> Type -> Type)
map2 :: forall (t :: Type -> Type) (u :: Type -> Type). Functor2 w => (t →⁻ u) -> w t →⁻ w u
class Functor2Iso (w :: Type -> Type -> Type -> Type)
map2iso :: forall (t :: Type -> Type) (u :: Type -> Type). Functor2Iso w => Iso2 t u -> w t →⁻ w u
(>>=) :: Bind m => m a -> (a -> m b) -> m b
(>>) :: Bind m => m a -> m b -> m b
class Return (m :: Type -> Type)
return :: Return m => a -> m a
class Bind (m :: Type -> Type)
(≫=) :: Bind m => m a -> (a -> m b) -> m b
infixl 1 ≫=
class (Functor m, Return m, Bind m) => Monad (m :: Type -> Type)
class Transformer (t :: Type -> Type -> Type -> Type)
lift :: (Transformer t, Monad m) => m a -> t m a
(*⋅) :: Bind m => (a -> m b) -> m a -> m b
(*$) :: Bind m => (a -> m b) -> m a -> m b
infixr 0 *$
(*∘) :: Bind m => (b -> m c) -> (a -> m b) -> a -> m c
infixl 7 *∘
kreturn :: Return m => (a -> b) -> a -> m b
extend :: Bind m => (a -> m b) -> m a -> m b
(≫) :: Bind m => m a -> m b -> m b
infixl 1 ≫
void :: Functor m => m a -> m ()
mjoin :: Bind m => m (m a) -> m a
mmap :: Monad m => (a -> b) -> m a -> m b
(⧆) :: Monad m => m a -> m b -> m (a ∧ b)
infixl 6 ⧆
(⊡) :: Monad m => m (a -> b) -> m a -> m b
skip :: Return m => m ()
when :: Return m => 𝔹 -> (() -> m ()) -> m ()
whenM :: Monad m => m 𝔹 -> (() -> m ()) -> m ()
newtype ToHSM (m :: Type -> Type) a
ToHSM :: m a -> ToHSM (m :: Type -> Type) a
[unToHSM] :: ToHSM (m :: Type -> Type) a -> m a
tohsMonad :: forall (m :: Type -> Type). Monad m => W (Monad m)
newtype FrHSM (m :: Type -> Type) a
FrHSM :: m a -> FrHSM (m :: Type -> Type) a
[unFrHSM] :: FrHSM (m :: Type -> Type) a -> m a
frhsMonad :: forall (m :: Type -> Type). Monad m => W (Monad m)
instance UVMHS.Core.Classes.Functors.Monad m => GHC.Base.Applicative (UVMHS.Core.Classes.Functors.ToHSM m)
instance GHC.Base.Monad m => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Classes.Functors.FrHSM m)
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Classes.Functors.NoCostID
instance GHC.Base.Functor t => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Classes.Functors.FrHSM t)
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Classes.Functors.NoCostID
instance UVMHS.Core.Classes.Functors.Functor t => GHC.Base.Functor (UVMHS.Core.Classes.Functors.ToHSM t)
instance GHC.Base.Monad m => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Classes.Functors.FrHSM m)
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Classes.Functors.NoCostID
instance UVMHS.Core.Classes.Functors.Monad m => GHC.Base.Monad (UVMHS.Core.Classes.Functors.ToHSM m)
instance GHC.Base.Monad m => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Classes.Functors.FrHSM m)
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Classes.Functors.NoCostID

module UVMHS.Core.Classes.Monoid
class Null a
null :: Null a => a
class Append a
(⧺) :: Append a => a -> a -> a
infixl 5 ⧺
class (Null a, Append a) => Monoid a
prepend :: Append a => a -> a -> a
pospend :: Append a => a -> a -> a
class Unit a
unit :: Unit a => a
class Cross a
(⨳) :: Cross a => a -> a -> a
infixl 6 ⨳
class (Monoid a, Unit a, Cross a) => Prodoid a
class Eps a
eps :: Eps a => a
class Seq a
(▷) :: Seq a => a -> a -> a
infixl 7 ▷
class (Eps a, Seq a) => Seqoid a
opt :: (Append a, Eps a) => a -> a
class Star a
star :: Star a => a -> a
class (Seqoid a, Star a) => Kleene a
oom :: Kleene a => a -> a
newtype Compose a
Compose :: (a -> a) -> Compose a
[unCompose] :: Compose a -> a -> a
newtype MCompose (m :: Type -> Type) a
MCompose :: (a -> m a) -> MCompose (m :: Type -> Type) a
[unMCompose] :: MCompose (m :: Type -> Type) a -> a -> m a
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Classes.Monoid.Compose a)
instance UVMHS.Core.Classes.Functors.Bind m => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Classes.Monoid.MCompose m a)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Classes.Monoid.Compose a)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Classes.Monoid.MCompose m a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Classes.Monoid.Compose a)
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Classes.Monoid.MCompose m a)

module UVMHS.Core.Classes.Constraints
class U (a :: k)
class (c₁ a, c₂ a) => ( (c₁ :: k -> Constraint) :∧: (c₂ :: k -> Constraint) ) (a :: k)
infixl 3 :∧:
class t u a => ( (t :: k -> Constraint) :∘: (u :: k1 -> k) ) (a :: k1)
infixl 7 :∘:
class c₁ :⇒: c₂
impl :: (:⇒:) c₁ c₂ => W c₁ -> W c₂
infixr 1 :⇒:
type FCoercibleRel (t :: k -> k1) (t' :: k -> k1) = forall (x :: k) (x' :: k). Coercible x x' => Coercible t x t' x'
type FCoercible (t :: k -> k1) = FCoercibleRel t t
fcoercibleW_UNSAFE :: forall {k1} {k2} (m :: k1 -> k2). W (FCoercible m)
type Func (c :: Type -> Constraint) (t :: Type -> Type) = forall x. c x => c t x
type Const (c :: Type -> Constraint) (t :: Type -> Type) = forall x. () => c t x
instance forall k1 k2 (t :: k1 -> GHC.Types.Constraint) (u :: k2 -> k1) (a :: k2). t (u a) => (UVMHS.Core.Classes.Constraints.:∘:) t u a
instance forall k (c₁ :: k -> GHC.Types.Constraint) (a :: k) (c₂ :: k -> GHC.Types.Constraint). (c₁ a, c₂ a) => (UVMHS.Core.Classes.Constraints.:∧:) c₁ c₂ a
instance forall k (a :: k). UVMHS.Core.Classes.Constraints.U a

module UVMHS.Core.Classes.Comonad
class Extract (w :: Type -> Type)
extract :: Extract w => w a -> a
class Cobind (w :: Type -> Type)
(=≫) :: Cobind w => w a -> (w a -> b) -> w b
infixr 1 =≫
class (Functor w, Extract w, Cobind w) => Comonad (w :: Type -> Type)
wextend :: Cobind w => (w a -> b) -> w a -> w b
(%⋅) :: Cobind w => (w a -> b) -> w a -> w b
(%$) :: Cobind w => (w a -> b) -> w a -> w b
(%∘) :: Cobind w => (w b -> c) -> (w a -> b) -> w a -> c
kextract :: Extract w => (a -> b) -> w a -> b
kextract2 :: Extract w => (a -> b -> c) -> w a -> w b -> c
siphon :: Cobind w => w a -> b -> w b
submerge :: (Functor m, Comonad w) => w (m a) -> m (w a)
wmap :: Comonad w => (a -> b) -> w a -> w b

module UVMHS.Core.Classes.Collections
class All a
all :: All a => 𝐼 a
class ASized a
asize :: ASized a => a -> ℕ64
class CSized a
csize :: CSized a => a -> ℕ64
class Single a t | t -> a
single :: Single a t => a -> t
class Lookup k v t | t -> k, t -> v
(⋕?) :: Lookup k v t => t -> k -> 𝑂 v
infixl 7 ⋕?
class Access k v t | t -> k, t -> v
(⋕) :: Access k v t => t -> k -> v
infixl 7 ⋕
class ToIter a t | t -> a
iter :: ToIter a t => t -> 𝐼 a
lup :: Lookup k v t => k -> t -> 𝑂 v
(⋕!) :: (Lookup k v t, STACK) => t -> k -> v
infixl 7 ⋕!
lupΩ :: Lookup k v t => k -> t -> v

module UVMHS.Core.Classes.DSL
class Arrow a
(⇨) :: Arrow a => a -> a -> a
infixr 1 ⇨
class Apply a
(⊙) :: Apply a => a -> a -> a
infixl 7 ⊙
class Tup a
tup :: (Tup a, ToIter a t) => t -> a
(⊙$) :: Apply e => e -> e -> e
infixr 0 ⊙$
(⊙⋆) :: (Apply e, ToIter e t) => e -> t -> e
infixl 7 ⊙⋆

module UVMHS.Core.Classes.Bitty
class BitZero a
bzero :: BitZero a => a
class BitOne a
bone :: BitOne a => a
class BitComp a
comp :: BitComp a => a -> a
class BitAnd a
(⟑) :: BitAnd a => a -> a -> a
infixl 6 ⟑
class BitOr a
(⟇) :: BitOr a => a -> a -> a
infixl 5 ⟇
class BitXor a
(⊻) :: BitXor a => a -> a -> a
infixl 5 ⊻
class BitShiftL a
(⋘) :: BitShiftL a => a -> ℕ64 -> a
infixl 7 ⋘
class BitShiftR a
(⋙) :: BitShiftR a => a -> ℕ64 -> a
infixl 7 ⋙
class BitSize (a :: k)
bsize :: BitSize a => P a -> ℕ64
class (BitZero a, BitOne a, BitComp a, BitAnd a, BitOr a, BitXor a, BitShiftL a, BitShiftR a, BitSize a) => Bitty a
bit :: (BitOne a, BitShiftL a) => ℕ64 -> a
bget :: (Eq a, BitZero a, BitOne a, BitAnd a, BitShiftL a) => ℕ64 -> a -> Bool
bset :: (BitOne a, BitOr a, BitShiftL a) => ℕ64 -> a -> a
bflp :: (BitOne a, BitXor a, BitShiftL a) => ℕ64 -> a -> a
bclr :: (BitOne a, BitComp a, BitAnd a, BitShiftL a) => ℕ64 -> a -> a

module UVMHS.Core.Classes.Arithmetic
class Zero a
zero :: Zero a => a
class Plus a
(+) :: Plus a => a -> a -> a
infixl 5 +
class Minus a
(-) :: Minus a => a -> a -> a
infixl 5 -
class One a
one :: One a => a
class Times a
(×) :: Times a => a -> a -> a
infixl 6 ×
class Divide a
(/) :: Divide a => a -> a -> a
infixl 6 /
class DivMod a
(⌿) :: DivMod a => a -> a -> a
(÷) :: DivMod a => a -> a -> a
infixl 6 ⌿
infixl 6 ÷
class Pon a
(^^) :: Pon a => a -> ℕ -> a
class Pow a
(^) :: Pow a => a -> a -> a
infixl 7 ^
class Root a
root :: Root a => a -> a
class Log a
log :: Log a => a -> a
class Efn a
efn :: Efn a => a -> a
class Sin a
sin :: Sin a => a -> a
class Cos a
cos :: Cos a => a -> a
class (Zero a, Plus a) => Additive a
class (Additive a, One a, Times a) => Multiplicative a
succ :: (One a, Plus a) => a -> a
pred :: (One a, Minus a) => a -> a
even :: (Eq a, Additive a, One a, DivMod a) => a -> 𝔹
odd :: (Eq a, Additive a, One a, DivMod a) => a -> 𝔹
neg :: (Zero a, Minus a) => a -> a
(⨵) :: (Functor f, Multiplicative a) => a -> f a -> f a
infixl 6 ⨵
(⨴) :: (Functor f, Multiplicative a) => f a -> a -> f a
class ToNat a
nat :: ToNat a => a -> ℕ
class ToNat64 a
nat64 :: ToNat64 a => a -> ℕ64
class ToNat32 a
nat32 :: ToNat32 a => a -> ℕ32
class ToNat16 a
nat16 :: ToNat16 a => a -> ℕ16
class ToNat8 a
nat8 :: ToNat8 a => a -> ℕ8
class ToNatO a
natO :: ToNatO a => a -> 𝑂 ℕ
class ToNatO64 a
natO64 :: ToNatO64 a => a -> 𝑂 ℕ64
class ToNatO32 a
natO32 :: ToNatO32 a => a -> 𝑂 ℕ32
class ToNatO16 a
natO16 :: ToNatO16 a => a -> 𝑂 ℕ16
class ToNatO8 a
natO8 :: ToNatO8 a => a -> 𝑂 ℕ8
natΩ :: (ToNatO a, STACK) => a -> ℕ
natΩ64 :: (ToNatO64 a, STACK) => a -> ℕ64
natΩ32 :: (ToNatO32 a, STACK) => a -> ℕ32
natΩ16 :: (ToNatO16 a, STACK) => a -> ℕ16
natΩ8 :: (ToNatO8 a, STACK) => a -> ℕ8
class ToInt a
int :: ToInt a => a -> ℤ
class ToInt64 a
int64 :: ToInt64 a => a -> ℤ64
class ToInt32 a
int32 :: ToInt32 a => a -> ℤ32
class ToInt16 a
int16 :: ToInt16 a => a -> ℤ16
class ToInt8 a
int8 :: ToInt8 a => a -> ℤ8
class ToIntO a
intO :: ToIntO a => a -> 𝑂 ℤ
class ToIntO64 a
intO64 :: ToIntO64 a => a -> 𝑂 ℤ64
class ToIntO32 a
intO32 :: ToIntO32 a => a -> 𝑂 ℤ32
class ToIntO16 a
intO16 :: ToIntO16 a => a -> 𝑂 ℤ16
class ToIntO8 a
intO8 :: ToIntO8 a => a -> 𝑂 ℤ8
intΩ :: (ToIntO a, STACK) => a -> ℤ
intΩ64 :: (ToIntO64 a, STACK) => a -> ℤ64
intΩ32 :: (ToIntO32 a, STACK) => a -> ℤ32
intΩ16 :: (ToIntO16 a, STACK) => a -> ℤ16
intΩ8 :: (ToIntO8 a, STACK) => a -> ℤ8
class ToRational a
rat :: ToRational a => a -> ℚ
class ToRationalO a
ratO :: ToRationalO a => a -> 𝑂 ℚ
class ToRationalᴾ a
ratᴾ :: ToRationalᴾ a => a -> ℚᴾ
class ToRationalᴾO a
ratᴾO :: ToRationalᴾO a => a -> 𝑂 ℚᴾ
class ToDouble a
dbl :: ToDouble a => a -> 𝔻
class ToDoubleO a
dblO :: ToDoubleO a => a -> 𝑂 𝔻
class ToDoubleᴾ a
dblᴾ :: ToDoubleᴾ a => a -> 𝔻ᴾ
class ToDoubleᴾO a
dblᴾO :: ToDoubleᴾO a => a -> 𝑂 𝔻ᴾ
class ToNumber a
num :: ToNumber a => a -> ℝ
class ToNumberᴾ a
numᴾ :: ToNumberᴾ a => a -> ℝᴾ
class ToNumberᴾO a
numᴾO :: ToNumberᴾO a => a -> 𝑂 ℝᴾ
ratΩ :: (ToRationalO a, STACK) => a -> ℚ
ratᴾΩ :: (ToRationalᴾO a, STACK) => a -> ℚᴾ
dblΩ :: (ToDoubleO a, STACK) => a -> 𝔻
dblᴾΩ :: (ToDoubleᴾO a, STACK) => a -> 𝔻ᴾ
numᴾΩ :: (ToNumberᴾO a, STACK) => a -> ℝᴾ

module UVMHS.Core.Classes

module UVMHS.Core.Data.Unit
instance UVMHS.Core.Classes.Arithmetic.Additive ()
instance UVMHS.Core.Classes.Monoid.Append ()
instance UVMHS.Core.Classes.Monoid.Monoid ()
instance UVMHS.Core.Classes.Monoid.Null ()
instance UVMHS.Core.Classes.Arithmetic.Plus ()
instance UVMHS.Core.Classes.Arithmetic.Zero ()

module UVMHS.Core.Data.Stream
eq𝑆 :: Eq a => 𝑆 a -> 𝑆 a -> 𝔹
compare𝑆 :: Ord a => 𝑆 a -> 𝑆 a -> Ordering
stream𝐼 :: 𝐼 a -> 𝑆 a
iter𝑆 :: 𝑆 a -> 𝐼 a
zipWith𝑆 :: (a -> b -> c) -> 𝑆 a -> 𝑆 b -> 𝑆 c
map𝑆 :: (a -> b) -> 𝑆 a -> 𝑆 b
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Init.𝑆 a)
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Init.𝑆
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Init.𝑆 a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Init.𝑆 a)

module UVMHS.Core.Data.Option
iter𝑂 :: 𝑂 a -> 𝐼 a
elim𝑂 :: (() -> b) -> (a -> b) -> 𝑂 a -> b
isNone :: 𝑂 a -> 𝔹
isSome :: 𝑂 a -> 𝔹
ifNone :: a -> 𝑂 a -> a
ifNoneZ :: a -> 𝑂 a -> a
ifNoneM :: Return m => m a -> 𝑂 a -> m a
ifNoneMZ :: Return m => m a -> 𝑂 a -> m a
first :: 𝑂 a -> 𝑂 a -> 𝑂 a
last :: 𝑂 a -> 𝑂 a -> 𝑂 a
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Init.𝑂 a)
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Init.𝑂
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Init.𝑂
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Init.𝑂
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Init.𝑂
instance UVMHS.Core.Classes.Monoid.Monoid a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Init.𝑂 a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Init.𝑂 a)
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Init.𝑂
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Init.𝑂 a)
instance UVMHS.Core.Init.𝑂 a UVMHS.Core.Classes.Morphism.⇄ (() UVMHS.Core.Init.∨ a)

module UVMHS.Core.Data.LazyList
emptyLL :: [a]
singleLL :: a -> [a]
consLL :: a -> [a] -> [a]
snocLL :: [a] -> a -> [a]
appendLL :: [a] -> [a] -> [a]
mapLL :: (a -> b) -> [a] -> [b]
bindLL :: [a] -> (a -> [b]) -> [b]
mapMLL :: Monad m => (a -> m b) -> [a] -> m [b]
instance UVMHS.Core.Classes.Monoid.Append [a]
instance UVMHS.Core.Classes.Functors.Bind []
instance UVMHS.Core.Classes.Functors.Functor []
instance UVMHS.Core.Classes.Functors.FunctorM []
instance UVMHS.Core.Classes.Functors.Monad []
instance UVMHS.Core.Classes.Monoid.Monoid [a]
instance UVMHS.Core.Classes.Monoid.Null [a]
instance UVMHS.Core.Classes.Functors.Return []
instance UVMHS.Core.Classes.Collections.Single a [a]
instance UVMHS.Core.Classes.Collections.ToIter a [a]

module UVMHS.Core.Data.Function
pipe :: (a -> b) -> (b -> c) -> a -> c
iterateWith :: (a -> 𝑂 a) -> a -> a
iterateFrom :: a -> (a -> 𝑂 a) -> a
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (r -> a)
instance UVMHS.Core.Classes.Functors.Bind ((->) r)
instance GHC.Classes.Eq a => GHC.Classes.Eq (() -> a)
instance UVMHS.Core.Classes.Functors.Functor ((->) r)
instance UVMHS.Core.Classes.Functors.Monad ((->) r)
instance UVMHS.Core.Classes.Monoid.Monoid a => UVMHS.Core.Classes.Monoid.Monoid (r -> a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Null (r -> a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (() -> a)
instance UVMHS.Core.Classes.Functors.Return ((->) r)
instance GHC.Show.Show a => GHC.Show.Show (() -> a)

module UVMHS.Core.Data.Choice
elimChoice :: (a -> c) -> (b -> c) -> (a ∨ b) -> c
mapChoice :: (a₁ -> a₂) -> (b₁ -> b₂) -> (a₁ ∨ b₁) -> a₂ ∨ b₂
mapInl :: (a₁ -> a₂) -> (a₁ ∨ b) -> a₂ ∨ b
mapInr :: (b₁ -> b₂) -> (a ∨ b₁) -> a ∨ b₂
mapMChoice :: Monad m => (a -> m a') -> (b -> m b') -> (a ∨ b) -> m (a' ∨ b')
mapMInl :: Monad m => (a -> m a') -> (a ∨ b) -> m (a' ∨ b)
mapMInr :: Monad m => (b -> m b') -> (a ∨ b) -> m (a ∨ b')
instance (UVMHS.Core.Classes.Monoid.Append a, UVMHS.Core.Classes.Monoid.Append b) => UVMHS.Core.Classes.Monoid.Append (a UVMHS.Core.Init.∨ b)
instance UVMHS.Core.Classes.Functors.Bind ((UVMHS.Core.Init.∨) a)
instance UVMHS.Core.Classes.Functors.FunctorM ((UVMHS.Core.Init.∨) a)
instance UVMHS.Core.Classes.Functors.Functor ((UVMHS.Core.Init.∨) a)
instance UVMHS.Core.Classes.Functors.Monad ((UVMHS.Core.Init.∨) a)
instance (UVMHS.Core.Classes.Monoid.Append a, UVMHS.Core.Classes.Monoid.Monoid b) => UVMHS.Core.Classes.Monoid.Monoid (a UVMHS.Core.Init.∨ b)
instance UVMHS.Core.Classes.Monoid.Null b => UVMHS.Core.Classes.Monoid.Null (a UVMHS.Core.Init.∨ b)
instance UVMHS.Core.Classes.Functors.Return ((UVMHS.Core.Init.∨) a)

module UVMHS.Core.Data.Bool
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.Dual UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.Lattice UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.POrd UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.𝔹

module UVMHS.Core.Data.Arithmetic
zabs :: ℤ -> ℕ
qabs :: ℚ -> ℚᴾ
numer :: ℚ -> ℤ
denom :: ℚ -> ℕ
numerᴾ :: ℚᴾ -> ℕ
denomᴾ :: ℚᴾ -> ℕ
truncate :: 𝔻 -> ℤ
ceiling :: 𝔻 -> ℤ
floor :: 𝔻 -> ℤ
truncateᴾ :: 𝔻ᴾ -> ℕ
ceilingᴾ :: 𝔻ᴾ -> ℕ
floorᴾ :: 𝔻ᴾ -> ℕ
minus𝔻ᴾ :: 𝔻ᴾ -> 𝔻ᴾ -> 𝔻ᴾ
numberBOp :: (ℤ -> ℤ -> ℝ) -> (ℚ -> ℚ -> ℝ) -> (𝔻 -> 𝔻 -> ℝ) -> ℝ -> ℝ -> ℝ
numberBOpᴾ :: (ℕ -> ℕ -> ℝᴾ) -> (ℚᴾ -> ℚᴾ -> ℝᴾ) -> (𝔻ᴾ -> 𝔻ᴾ -> ℝᴾ) -> ℝᴾ -> ℝᴾ -> ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Cos UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Cos UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Cos UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.DivMod UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Divide UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Divide UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.Divide UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.Divide UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Divide UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Divide UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Efn UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Efn UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Efn UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Log UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Log UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Log UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Log UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Minus UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Pow UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Root UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Root UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Root UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Root UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Sin UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Sin UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Sin UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾO UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾO UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾO UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾO UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾO UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾO UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾO UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾO UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾ UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾ UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾ UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾ UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾ UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾ UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾ UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToDoubleᴾ UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToDouble UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToInt16 UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToInt16 UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToInt16 UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToInt32 UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToInt32 UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToInt32 UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToInt32 UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToInt32 UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToInt64 UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToInt64 UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToInt64 UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToInt64 UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToInt64 UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToInt64 UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToInt64 UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToInt8 UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO16 UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO32 UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO64 UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO8 UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToIntO UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToIntO UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToIntO UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToIntO UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToInt UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToNat16 UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToNat16 UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToNat32 UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToNat32 UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToNat32 UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToNat64 UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToNat64 UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToNat64 UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToNat64 UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToNat8 UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO16 UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO32 UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO64 UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO8 UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNatO UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNat UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToNat UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToNat UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToNat UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToNat UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾO UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾO UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾO UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾO UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾO UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾO UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾO UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾ UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾ UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾ UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾ UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾ UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾ UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToNumberᴾ UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToNumber UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾO UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾ UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾ UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾ UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾ UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾ UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToRationalᴾ UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.ToRational UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Core.Init.𝔻ᴾ
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.𝔻
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℤ
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℕ
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℚ
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℚᴾ
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℝ
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.ℝᴾ
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Init.𝔻ᴾ

module UVMHS.Core.Data.String
empty𝕊 :: 𝕊 -> 𝔹
single𝕊 :: ℂ -> 𝕊
build𝕊C :: ToIter ℂ t => t -> 𝕊
build𝕊S :: ToIter 𝕊 t => t -> 𝕊
build𝕊CN :: ToIter ℂ t => ℕ64 -> t -> 𝕊
build𝕊SN :: ToIter 𝕊 t => ℕ64 -> t -> 𝕊
show𝕊 :: Show a => a -> 𝕊
read𝕊 :: Read a => 𝕊 -> a
lower𝕊 :: 𝕊 -> 𝕊
upper𝕊 :: 𝕊 -> 𝕊
isEmpty𝕊 :: 𝕊 -> 𝔹
length𝕊 :: 𝕊 -> ℕ
length64𝕊 :: 𝕊 -> ℕ64
splitOn𝕊 :: 𝕊 -> 𝕊 -> 𝐼 𝕊
replace𝕊 :: 𝕊 -> 𝕊 -> 𝕊 -> 𝕊
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.Init.𝕊
instance UVMHS.Core.Classes.Collections.Lookup UVMHS.Core.Init.ℕ UVMHS.Core.Init.ℂ UVMHS.Core.Init.𝕊
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.Init.𝕊
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.Init.𝕊
instance UVMHS.Core.Classes.Collections.Single UVMHS.Core.Init.ℂ UVMHS.Core.Init.𝕊
instance UVMHS.Core.Classes.Collections.ToIter UVMHS.Core.Init.ℂ UVMHS.Core.Init.𝕊

module UVMHS.Core.Data.Pair
fst :: (a ∧ b) -> a
snd :: (a ∧ b) -> b
swap :: (a ∧ b) -> b ∧ a
mapPair :: (a₁ -> a₂) -> (b₁ -> b₂) -> (a₁ ∧ b₁) -> a₂ ∧ b₂
mapBoth :: (a -> a') -> (a ∧ a) -> a' ∧ a'
mapFst :: (a₁ -> a₂) -> (a₁ ∧ b) -> a₂ ∧ b
mapSnd :: (b₁ -> b₂) -> (a ∧ b₁) -> a ∧ b₂
mapMPair :: Monad m => (a -> m a') -> (b -> m b') -> (a ∧ b) -> m (a' ∧ b')
mapMBoth :: Monad m => (a -> m a) -> (a ∧ a) -> m (a ∧ a)
mapMFst :: Monad m => (a -> m a') -> (a ∧ b) -> m (a' ∧ b)
mapMSnd :: Monad m => (b -> m b') -> (a ∧ b) -> m (a ∧ b')
instance (UVMHS.Core.Classes.Monoid.Append a, UVMHS.Core.Classes.Monoid.Append b) => UVMHS.Core.Classes.Monoid.Append (a UVMHS.Core.Init.∧ b)
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Functors.Bind ((UVMHS.Core.Init.∧) a)
instance (UVMHS.Core.Classes.Lattice.Bot a, UVMHS.Core.Classes.Lattice.Bot b) => UVMHS.Core.Classes.Lattice.Bot (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Lattice.Difference a, UVMHS.Core.Classes.Lattice.Difference b) => UVMHS.Core.Classes.Lattice.Difference (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Lattice.Dual a, UVMHS.Core.Classes.Lattice.Dual b) => UVMHS.Core.Classes.Lattice.Dual (a UVMHS.Core.Init.∧ b)
instance UVMHS.Core.Classes.Functors.FunctorM ((UVMHS.Core.Init.∧) a)
instance UVMHS.Core.Classes.Functors.Functor ((UVMHS.Core.Init.∧) a)
instance (UVMHS.Core.Classes.Lattice.JoinLattice a, UVMHS.Core.Classes.Lattice.JoinLattice b) => UVMHS.Core.Classes.Lattice.JoinLattice (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Lattice.Join a, UVMHS.Core.Classes.Lattice.Join b) => UVMHS.Core.Classes.Lattice.Join (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Lattice.Lattice a, UVMHS.Core.Classes.Lattice.Lattice b) => UVMHS.Core.Classes.Lattice.Lattice (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Lattice.MeetLattice a, UVMHS.Core.Classes.Lattice.MeetLattice b) => UVMHS.Core.Classes.Lattice.MeetLattice (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Lattice.Meet a, UVMHS.Core.Classes.Lattice.Meet b) => UVMHS.Core.Classes.Lattice.Meet (a UVMHS.Core.Init.∧ b)
instance UVMHS.Core.Classes.Monoid.Monoid a => UVMHS.Core.Classes.Functors.Monad ((UVMHS.Core.Init.∧) a)
instance (UVMHS.Core.Classes.Monoid.Monoid a, UVMHS.Core.Classes.Monoid.Monoid b) => UVMHS.Core.Classes.Monoid.Monoid (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Monoid.Null a, UVMHS.Core.Classes.Monoid.Null b) => UVMHS.Core.Classes.Monoid.Null (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Lattice.POrd a, UVMHS.Core.Classes.Lattice.POrd b) => UVMHS.Core.Classes.Lattice.POrd (a UVMHS.Core.Init.∧ b)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Functors.Return ((UVMHS.Core.Init.∧) a)
instance (UVMHS.Core.Classes.Lattice.Top a, UVMHS.Core.Classes.Lattice.Top b) => UVMHS.Core.Classes.Lattice.Top (a UVMHS.Core.Init.∧ b)

module UVMHS.Core.Data.List
empty𝐿 :: 𝐿 a
single𝐿 :: a -> 𝐿 a
lookup𝐿 :: ℕ64 -> 𝐿 a -> 𝑂 a
cons𝐿 :: a -> 𝐿 a -> 𝐿 a
uncons𝐿 :: 𝐿 a -> 𝑂 (a ∧ 𝐿 a)
snoc𝐿 :: 𝐿 a -> a -> 𝐿 a
unsnoc𝐿 :: 𝐿 a -> 𝑂 (𝐿 a ∧ a)
append𝐿 :: 𝐿 a -> 𝐿 a -> 𝐿 a
map𝐿 :: (a -> b) -> 𝐿 a -> 𝐿 b
bind𝐿 :: 𝐿 a -> (a -> 𝐿 b) -> 𝐿 b
mapM𝐿 :: Monad m => (a -> m b) -> 𝐿 a -> m (𝐿 b)
cart :: 𝐿 (𝐿 a) -> 𝐿 (𝐿 a)
swivelL :: 𝐿 a -> a -> a ∧ 𝐿 a
swivelR :: a -> 𝐿 a -> 𝐿 a ∧ a
iswivelL :: 𝐿 (a ∧ i) -> a -> a ∧ 𝐿 (i ∧ a)
iswivelR :: a -> 𝐿 (i ∧ a) -> 𝐿 (a ∧ i) ∧ a
zipSameLength :: 𝐿 a -> 𝐿 b -> 𝑂 (𝐿 (a ∧ b))
split :: 𝐿 (a ∧ b) -> 𝐿 a ∧ 𝐿 b
firstSome :: 𝐿 (𝑂 a) -> 𝑂 a
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Init.𝐿 a)
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Init.𝐿
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Init.𝐿
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Init.𝐿
instance UVMHS.Core.Classes.Collections.Lookup UVMHS.Core.Init.ℕ64 a (UVMHS.Core.Init.𝐿 a)
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Init.𝐿
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Init.𝐿 a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Init.𝐿 a)
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Init.𝐿
instance UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Init.𝐿 a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Init.𝐿 a)

module UVMHS.Core.Data.Lattice
lfp :: POrd a => a -> (a -> a) -> a
lfpN :: POrd a => ℕ -> a -> (a -> a) -> a
gfp :: POrd a => a -> (a -> a) -> a
gfpN :: POrd a => ℕ -> a -> (a -> a) -> a

module UVMHS.Core.Data.Iter
empty𝐼 :: 𝐼 a
cons𝐼 :: a -> 𝐼 a -> 𝐼 a
stream :: ToIter a t => t -> 𝑆 a
zipWith :: (ToIter a t₁, ToIter b t₂) => (a -> b -> c) -> t₁ -> t₂ -> 𝐼 c
zip :: (ToIter a t₁, ToIter b t₂) => t₁ -> t₂ -> 𝐼 (a ∧ b)
snoc𝐼 :: 𝐼 a -> a -> 𝐼 a
isEmpty :: ToIter a t => t -> 𝔹
firstElem :: ToIter a t => t -> 𝑂 a
append𝐼 :: 𝐼 a -> 𝐼 a -> 𝐼 a
bind𝐼 :: 𝐼 a -> (a -> 𝐼 b) -> 𝐼 b
mjoin𝐼 :: 𝐼 (𝐼 a) -> 𝐼 a
mapM𝐼 :: Monad m => (a -> m b) -> 𝐼 a -> m (𝐼 b)
fold :: ToIter a t => b -> (a -> b -> b) -> t -> b
foldFromWith :: ToIter a t => b -> (a -> b -> b) -> t -> b
foldFromOn :: ToIter a t => b -> t -> (a -> b -> b) -> b
foldOnFrom :: ToIter a t => t -> b -> (a -> b -> b) -> b
foldOnWith :: ToIter a t => t -> (a -> b -> b) -> b -> b
foldWithOn :: ToIter a t => (a -> b -> b) -> t -> b -> b
foldWithFrom :: ToIter a t => (a -> b -> b) -> b -> t -> b
foldk :: ToIter a t => b -> (a -> b -> (b -> b) -> b) -> t -> b
foldkFromWith :: ToIter a t => b -> (a -> b -> (b -> b) -> b) -> t -> b
foldkFromOn :: ToIter a t => b -> t -> (a -> b -> (b -> b) -> b) -> b
foldkOnFrom :: ToIter a t => t -> b -> (a -> b -> (b -> b) -> b) -> b
foldkOnWith :: ToIter a t => t -> (a -> b -> (b -> b) -> b) -> b -> b
foldkWithOn :: ToIter a t => (a -> b -> (b -> b) -> b) -> t -> b -> b
foldkWithFrom :: ToIter a t => (a -> b -> (b -> b) -> b) -> b -> t -> b
foldr :: ToIter a t => b -> (a -> b -> b) -> t -> b
foldrFromWith :: ToIter a t => b -> (a -> b -> b) -> t -> b
foldrFromOn :: ToIter a t => b -> t -> (a -> b -> b) -> b
foldrOnFrom :: ToIter a t => t -> b -> (a -> b -> b) -> b
foldrOnWith :: ToIter a t => t -> (a -> b -> b) -> b -> b
foldrWithOn :: ToIter a t => (a -> b -> b) -> t -> b -> b
foldrWithFrom :: ToIter a t => (a -> b -> b) -> b -> t -> b
mfold :: (Monad m, ToIter a t) => b -> (a -> b -> m b) -> t -> m b
mfoldFromWith :: (Monad m, ToIter a t) => b -> (a -> b -> m b) -> t -> m b
mfoldFromOn :: (Monad m, ToIter a t) => b -> t -> (a -> b -> m b) -> m b
mfoldOnFrom :: (Monad m, ToIter a t) => t -> b -> (a -> b -> m b) -> m b
mfoldOnWith :: (Monad m, ToIter a t) => t -> (a -> b -> m b) -> b -> m b
mfoldWithOn :: (Monad m, ToIter a t) => (a -> b -> m b) -> t -> b -> m b
mfoldWithFrom :: (Monad m, ToIter a t) => (a -> b -> m b) -> b -> t -> m b
mfoldk :: (Monad m, ToIter a t) => b -> (a -> b -> (m b -> m b) -> m b) -> t -> m b
mfoldkFromWith :: (Monad m, ToIter a t) => b -> (a -> b -> (m b -> m b) -> m b) -> t -> m b
mfoldkFromOn :: (Monad m, ToIter a t) => b -> t -> (a -> b -> (m b -> m b) -> m b) -> m b
mfoldkOnFrom :: (Monad m, ToIter a t) => t -> b -> (a -> b -> (m b -> m b) -> m b) -> m b
mfoldkOnWith :: (Monad m, ToIter a t) => t -> (a -> b -> (m b -> m b) -> m b) -> b -> m b
mfoldkWithOn :: (Monad m, ToIter a t) => (a -> b -> (m b -> m b) -> m b) -> t -> b -> m b
mfoldkWithFrom :: (Monad m, ToIter a t) => (a -> b -> (m b -> m b) -> m b) -> b -> t -> m b
mfoldr :: (Monad m, ToIter a t) => b -> (a -> b -> m b) -> t -> m b
mfoldrFromWith :: (Monad m, ToIter a t) => b -> (a -> b -> m b) -> t -> m b
mfoldrFromOn :: (Monad m, ToIter a t) => b -> t -> (a -> b -> m b) -> m b
mfoldrOnFrom :: (Monad m, ToIter a t) => t -> b -> (a -> b -> m b) -> m b
mfoldrOnWith :: (Monad m, ToIter a t) => t -> (a -> b -> m b) -> b -> m b
mfoldrWithOn :: (Monad m, ToIter a t) => (a -> b -> m b) -> t -> b -> m b
mfoldrWithFrom :: (Monad m, ToIter a t) => (a -> b -> m b) -> b -> t -> m b
eachWith :: (Monad m, ToIter a t) => (a -> m ()) -> t -> m ()
eachOn :: (Monad m, ToIter a t) => t -> (a -> m ()) -> m ()
eachkWith :: (Monad m, ToIter a t) => (a -> (m () -> m ()) -> m ()) -> t -> m ()
eachkOn :: (Monad m, ToIter a t) => t -> (a -> (m () -> m ()) -> m ()) -> m ()
exec :: (Monad m, ToIter (m ()) t) => t -> m ()
sum :: (ToIter a t, Additive a) => t -> a
product :: (ToIter a t, Multiplicative a) => t -> a
concat :: (Monoid a, ToIter a t) => t -> a
sequence :: (Seqoid a, ToIter a t) => t -> a
compose :: ToIter (a -> a) t => t -> a -> a
mcompose :: (Monad m, ToIter (a -> m a) t) => t -> a -> m a
wcompose :: (Comonad w, ToIter (w a -> a) t) => t -> w a -> a
minsFrom :: (ToIter a t, Ord a) => a -> t -> a
maxsFrom :: (ToIter a t, Ord a) => a -> t -> a
joinsFrom :: (ToIter a t, Join a) => a -> t -> a
joins :: (JoinLattice a, ToIter a t) => t -> a
meetsFrom :: (ToIter a t, Meet a) => a -> t -> a
meets :: (MeetLattice a, ToIter a t) => t -> a
or :: ToIter 𝔹 t => t -> 𝔹
orf :: ToIter (a -> 𝔹) t => t -> a -> 𝔹
andf :: ToIter (a -> 𝔹) t => t -> a -> 𝔹
and :: ToIter 𝔹 t => t -> 𝔹
eqs :: (Eq a, ToIter a t) => t -> 𝔹
count :: forall n t a. (Zero n, One n, Plus n, ToIter a t) => t -> n
countWith :: forall n t a. (Zero n, One n, Plus n, ToIter a t) => (a -> 𝔹) -> t -> n
reverse :: ToIter a t => t -> 𝐼 a
replicateI :: (Eq n, Zero n, One n, Plus n) => n -> (n -> a) -> 𝐼 a
replicate :: (Eq n, Zero n, One n, Plus n) => n -> a -> 𝐼 a
build :: (Eq n, Zero n, One n, Plus n) => n -> a -> (a -> a) -> 𝐼 a
range :: (Eq n, Additive n, One n, Minus n) => n -> n -> 𝐼 n
upto :: (Eq n, Additive n, One n) => n -> 𝐼 n
uptoStep :: ℕ64 -> ℕ64 -> 𝐼 ℕ64
mapState𝐼 :: forall t a b s. ToIter a t => s -> (a -> s -> s ∧ b) -> t -> 𝐼 b
mapStateOnFrom𝐼 :: forall t a b s. ToIter a t => t -> s -> (a -> s -> s ∧ b) -> 𝐼 b
mapCont𝐼 :: forall t a b. ToIter a t => (forall i. () => a -> i -> (b -> i -> (i -> i) -> i) -> (i -> i) -> (i -> i) -> i) -> t -> 𝐼 b
mapContOn𝐼 :: forall t a b. ToIter a t => t -> (forall i. () => a -> i -> (b -> i -> (i -> i) -> i) -> (i -> i) -> (i -> i) -> i) -> 𝐼 b
withIndex :: forall n t a. (Zero n, One n, Plus n, ToIter a t) => t -> 𝐼 (n ∧ a)
withFirst :: ToIter a t => t -> 𝐼 (𝔹 ∧ a)
mapFirst :: ToIter a t => (a -> a) -> t -> 𝐼 a
mapAfterFirst :: ToIter a t => (a -> a) -> t -> 𝐼 a
keepN :: (ToIter a t, Ord n, Zero n, One n, Plus n) => n -> t -> 𝐼 a
dropN :: (ToIter a t, Ord n, Zero n, One n, Plus n) => n -> t -> 𝐼 a
withLast :: ToIter a t => t -> 𝐼 (𝔹 ∧ a)
mapLast :: ToIter a t => (a -> a) -> t -> 𝐼 a
mapLastOn :: ToIter a t => t -> (a -> a) -> 𝐼 a
mapBeforeLast :: ToIter a t => (a -> a) -> t -> 𝐼 a
filter :: ToIter a t => (a -> 𝔹) -> t -> 𝐼 a
filterOn :: ToIter a t => t -> (a -> 𝔹) -> 𝐼 a
filterO :: ToIter (𝑂 a) t => t -> 𝐼 a
filterMap :: ToIter a t => (a -> 𝑂 b) -> t -> 𝐼 b
filterMapOn :: ToIter a t => t -> (a -> 𝑂 b) -> 𝐼 b
filterM :: (ToIter a t, Monad m) => (a -> m 𝔹) -> t -> m (𝐼 a)
filterMOn :: (ToIter a t, Monad m) => t -> (a -> m 𝔹) -> m (𝐼 a)
filterMapM :: (ToIter a t, Monad m) => (a -> m (𝑂 b)) -> t -> m (𝐼 b)
filterMapMOn :: (ToIter a t, Monad m) => t -> (a -> m (𝑂 b)) -> m (𝐼 b)
inbetween :: ToIter a t => a -> t -> 𝐼 a
alignLeftFill :: ℂ -> ℕ -> 𝕊 -> 𝕊
alignLeft :: ℕ -> 𝕊 -> 𝕊
alignRightFill :: ℂ -> ℕ -> 𝕊 -> 𝕊
alignRight :: ℕ -> 𝕊 -> 𝕊
list :: ToIter a t => t -> 𝐿 a
lazyList :: ToIter a t => t -> [a]
string :: ToIter ℂ t => t -> 𝕊
stringS :: ToIter 𝕊 t => t -> 𝕊
truncate𝕊 :: ℕ64 -> 𝕊 -> 𝕊 -> 𝕊
showCollection :: ToIter a t => 𝕊 -> 𝕊 -> 𝕊 -> (a -> 𝕊) -> t -> 𝕊
showWith𝐼 :: (a -> 𝕊) -> 𝐼 a -> 𝕊
firstMaxByLT :: ToIter a t => (a -> a -> 𝔹) -> t -> 𝑂 a
sortWith :: ToIter a t => (a -> a -> Ordering) -> t -> 𝐿 a
sortOn :: (ToIter a t, Ord b) => (a -> b) -> t -> 𝐿 a
sort :: (ToIter a t, Ord a) => t -> 𝐿 a
materialize :: ToIter a t => t -> 𝐼 a
mapWhile :: (a -> a) -> (a -> 𝔹) -> 𝐼 a -> 𝐼 a
dropWhile :: (a -> 𝔹) -> 𝐼 a -> 𝐼 a
takeWhile :: (a -> 𝔹) -> 𝐼 a -> 𝐼 a
lookup𝐼 :: ℕ64 -> 𝐼 a -> 𝑂 a
partition :: (a -> b ∨ c) -> 𝐿 a -> 𝐿 b ∧ 𝐿 c
partition𝔹 :: (a -> 𝔹) -> 𝐿 a -> 𝐿 a ∧ 𝐿 a
instance UVMHS.Core.Classes.Collections.All UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Collections.All ()
instance (UVMHS.Core.Classes.Collections.All a, UVMHS.Core.Classes.Collections.All b) => UVMHS.Core.Classes.Collections.All (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Collections.All a, UVMHS.Core.Classes.Collections.All b) => UVMHS.Core.Classes.Collections.All (a UVMHS.Core.Init.∨ b)
instance UVMHS.Core.Classes.Collections.All a => UVMHS.Core.Classes.Collections.All (UVMHS.Core.Init.𝑂 a)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Init.𝐼
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Init.𝐼
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Init.𝐼
instance UVMHS.Core.Classes.Collections.Lookup UVMHS.Core.Init.ℕ64 a (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Init.𝐼
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Init.𝐼 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Init.𝐼
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Init.𝐼 a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Init.𝐿 a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Init.𝑆 a)
instance UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Core.Init.𝕊 UVMHS.Core.Classes.Morphism.⇄ UVMHS.Core.Init.𝐼 UVMHS.Core.Init.ℂ

module UVMHS.Core.Data.Set
class (CSized s, Ord s, ToIter e s, Single e s, Monoid s, POrd s, JoinLattice s, Meet s, Difference s) => Set e s | s -> e
pø :: Set e s => s
psingle :: Set e s => e -> s
padd :: Set e s => e -> s -> s
prem :: Set e s => e -> s -> s
(∈) :: Set e s => e -> s -> 𝔹
(⊆) :: Set e s => s -> s -> 𝔹
(∪) :: Set e s => s -> s -> s
(∩) :: Set e s => s -> s -> s
(∖) :: Set e s => s -> s -> s
pminView :: Set e s => s -> 𝑂 (e ∧ s)
pmaxView :: Set e s => s -> 𝑂 (e ∧ s)
pminElem :: Set e s => s -> 𝑂 e
pmaxElem :: Set e s => s -> 𝑂 e
pow𝐼 :: Set e s => 𝐼 e -> s
pvals :: Set e s => s -> 𝐼 e
infix 4 ∈
infix 4 ⊆
infixl 5 ∪
infixl 6 ∩
infixl 5 ∖
(⊇) :: Set e s => s -> s -> 𝔹
infix 4 ⊇
(∉) :: Set e s => e -> s -> 𝔹
infix 4 ∉
pow :: forall s t e. (ToIter e t, Set e s) => t -> s
unions :: (Set e s, ToIter s t) => t -> s
intersFrom :: (Set e s, ToIter s t) => s -> t -> s
sdiffsFrom :: (Set e s, ToIter s t) => s -> t -> s
pø𝑃 :: 𝑃 a
psingle𝑃 :: a -> 𝑃 a
padd𝑃 :: Ord a => a -> 𝑃 a -> 𝑃 a
prem𝑃 :: Ord a => a -> 𝑃 a -> 𝑃 a
(∈♭) :: Ord a => a -> 𝑃 a -> 𝔹
(⊆♭) :: Ord a => 𝑃 a -> 𝑃 a -> 𝔹
(∪♭) :: Ord a => 𝑃 a -> 𝑃 a -> 𝑃 a
(∩♭) :: Ord a => 𝑃 a -> 𝑃 a -> 𝑃 a
(∖♭) :: Ord a => 𝑃 a -> 𝑃 a -> 𝑃 a
pminView𝑃 :: 𝑃 a -> 𝑂 (a ∧ 𝑃 a)
pmaxView𝑃 :: 𝑃 a -> 𝑂 (a ∧ 𝑃 a)
pminElem𝑃 :: 𝑃 a -> 𝑂 a
pmaxElem𝑃 :: 𝑃 a -> 𝑂 a
pow𝐼𝑃 :: Ord a => 𝐼 a -> 𝑃 a
pvals𝑃 :: 𝑃 a -> 𝐼 a
csize𝑃 :: 𝑃 a -> ℕ64
show𝑃 :: Show a => 𝑃 a -> 𝕊
iter𝑃 :: 𝑃 a -> 𝐼 a
single𝑃 :: a -> 𝑃 a
null𝑃 :: 𝑃 a
append𝑃 :: Ord a => 𝑃 a -> 𝑃 a -> 𝑃 a
unit𝑃 :: (Ord a, Null a) => 𝑃 a
cross𝑃 :: (Ord a, Append a) => 𝑃 a -> 𝑃 a -> 𝑃 a
zero𝑃 :: 𝑃 a
plus𝑃 :: Ord a => 𝑃 a -> 𝑃 a -> 𝑃 a
one𝑃 :: (Ord a, Zero a) => 𝑃 a
times𝑃 :: (Ord a, Plus a) => 𝑃 a -> 𝑃 a -> 𝑃 a
plte𝑃 :: Ord a => 𝑃 a -> 𝑃 a -> 𝔹
bot𝑃 :: 𝑃 a
join𝑃 :: Ord a => 𝑃 a -> 𝑃 a -> 𝑃 a
meet𝑃 :: Ord a => 𝑃 a -> 𝑃 a -> 𝑃 a
diff𝑃 :: Ord a => 𝑃 a -> 𝑃 a -> 𝑃 a
all𝑃 :: (Ord a, All a) => 𝐼 (𝑃 a)
pow𝑃 :: (Ord a, ToIter a t) => t -> 𝑃 a
map𝑃 :: Ord b => (a -> b) -> 𝑃 a -> 𝑃 b
uniques𝑃 :: (Ord a, ToIter a t) => t -> 𝐼 a
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Arithmetic.Additive (UVMHS.Core.Init.𝑃 a)
instance (GHC.Classes.Ord a, UVMHS.Core.Classes.Collections.All a) => UVMHS.Core.Classes.Collections.All (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Init.𝑃 a)
instance UVMHS.Core.Classes.Lattice.Bot (UVMHS.Core.Init.𝑃 a)
instance UVMHS.Core.Classes.Collections.CSized (UVMHS.Core.Init.𝑃 a)
instance (GHC.Classes.Ord a, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Cross (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Lattice.Difference (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Init.𝑃 a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Init.𝑃 a)
instance (GHC.Classes.Ord a, UVMHS.Core.Classes.Arithmetic.Zero a) => UVMHS.Core.Classes.Arithmetic.One (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Lattice.POrd (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Arithmetic.Plus (UVMHS.Core.Init.𝑃 a)
instance (GHC.Classes.Ord a, UVMHS.Core.Classes.Monoid.Monoid a) => UVMHS.Core.Classes.Monoid.Prodoid (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord e => UVMHS.Core.Data.Set.Set e (UVMHS.Core.Init.𝑃 e)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Init.𝑃 a)
instance GHC.Classes.Ord a => UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Init.𝑃 a)
instance (GHC.Classes.Ord a, UVMHS.Core.Classes.Arithmetic.Plus a) => UVMHS.Core.Classes.Arithmetic.Times (UVMHS.Core.Init.𝑃 a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Init.𝑃 a)
instance (GHC.Classes.Ord a, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Unit (UVMHS.Core.Init.𝑃 a)
instance UVMHS.Core.Classes.Arithmetic.Zero (UVMHS.Core.Init.𝑃 a)

module UVMHS.Core.Data.Sequence
qø :: 𝑄 a
cons𝑄 :: a -> 𝑄 a -> 𝑄 a
uncons𝑄 :: 𝑄 a -> 𝑂 (a ∧ 𝑄 a)
snoc𝑄 :: 𝑄 a -> a -> 𝑄 a
unsnoc𝑄 :: 𝑄 a -> 𝑂 (𝑄 a ∧ a)
single𝑄 :: a -> 𝑄 a
append𝑄 :: 𝑄 a -> 𝑄 a -> 𝑄 a
map𝑄 :: (a -> b) -> 𝑄 a -> 𝑄 b
bind𝑄 :: 𝑄 a -> (a -> 𝑄 b) -> 𝑄 b
iter𝑄 :: 𝑄 a -> 𝐼 a
seq𝐼 :: 𝐼 a -> 𝑄 a
seq :: ToIter a t => t -> 𝑄 a
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Init.𝑄 a)
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Init.𝑄
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Init.𝑄
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Init.𝑄
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Init.𝑄 a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Init.𝑄 a)
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Init.𝑄
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Init.𝑄 a)
instance UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Init.𝑄 a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Init.𝑄 a)

module UVMHS.Core.Data.Dict
class (Set k s, FunctorM d, OFunctorM d, KFunctorM k d, OKFunctorM k d, BiFunctorM d, OBiFunctorM d, KBiFunctorM k d, OKBiFunctorM k d, Functor d, OFunctor d, KFunctor k d, OKFunctor k d, BiFunctor d, OBiFunctor d, KBiFunctor k d, OKBiFunctor k d, forall x. () => CSized d x, forall x. Eq x => Eq d x, forall x. Ord x => Ord d x, forall x. () => ToIter k ∧ x d x, forall x. () => Single k ∧ x d x, forall x. () => Lookup k x d x, forall x. () => Null d x, forall x. Append x => Append d x, forall x. Monoid x => Monoid d x, forall x. POrd x => POrd d x, forall x. () => Bot d x, forall x. Join x => Join d x, forall x. JoinLattice x => JoinLattice d x, forall x. Meet x => Meet d x, forall x. Difference x => Difference d x) => Dict k s (d :: Type -> Type) | d -> k, d -> s
dø :: Dict k s d => d a
(↦) :: Dict k s d => k -> a -> d a
dadd :: Dict k s d => k -> a -> d a -> d a
drem :: Dict k s d => k -> d a -> d a
dupd :: Dict k s d => k -> (a -> 𝑂 a) -> d a -> d a
dlteBy :: Dict k s d => (a -> a -> 𝔹) -> d a -> d a -> 𝔹
dunionBy :: Dict k s d => (a -> a -> a) -> d a -> d a -> d a
dkunionBy :: Dict k s d => (k -> a -> a -> a) -> d a -> d a -> d a
dinterBy :: Dict k s d => (a -> b -> c) -> d a -> d b -> d c
dsdiffBy :: Dict k s d => (a -> b -> 𝑂 a) -> d a -> d b -> d a
(⋿) :: Dict k s d => k -> d a -> 𝔹
(⫑) :: (Dict k s d, Eq a) => d a -> d a -> 𝔹
(⩌) :: Dict k s d => d a -> d a -> d a
(⩍) :: Dict k s d => d a -> d a -> d a
(⧅) :: (Dict k s d, Eq a) => d a -> d a -> d a
dminView :: Dict k s d => d a -> 𝑂 ((k ∧ a) ∧ d a)
dmaxView :: Dict k s d => d a -> 𝑂 ((k ∧ a) ∧ d a)
dkeyView :: Dict k s d => k -> d a -> 𝑂 (a ∧ d a)
dminElem :: Dict k s d => d a -> 𝑂 (k ∧ a)
dmaxElem :: Dict k s d => d a -> 𝑂 (k ∧ a)
dkeep :: Dict k s d => s -> d a -> d a
dtoss :: Dict k s d => s -> d a -> d a
dict𝐼 :: Dict k s d => 𝐼 (k ∧ a) -> d a
dkeys :: Dict k s d => d a -> s
dvals :: Dict k s d => d a -> 𝐼 a
infixr 1 ↦
infix 4 ⋿
infix 4 ⫑
infixl 5 ⩌
infixl 6 ⩍
infixl 5 ⧅
dunionByOn :: Dict k s d => d a -> d a -> (a -> a -> a) -> d a
dkunionByOn :: Dict k s d => d a -> d a -> (k -> a -> a -> a) -> d a
dinterByOn :: Dict k s d => d a -> d b -> (a -> b -> c) -> d c
dinterByM :: (Monad m, Dict k s d) => (a -> b -> m c) -> d a -> d b -> m (d c)
dict :: forall d t a k s. (Dict k s d, ToIter (d a) t) => t -> d a
assoc :: forall d t a k s. (Dict k s d, ToIter (k ∧ a) t) => t -> d a
dø𝐷 :: k ⇰ a
(↦♭) :: k -> a -> k ⇰ a
dadd𝐷 :: Ord k => k -> a -> (k ⇰ a) -> k ⇰ a
drem𝐷 :: Ord k => k -> (k ⇰ a) -> k ⇰ a
dupd𝐷 :: Ord k => k -> (a -> 𝑂 a) -> (k ⇰ a) -> k ⇰ a
dlteBy𝐷 :: Ord k => (a -> a -> 𝔹) -> (k ⇰ a) -> (k ⇰ a) -> 𝔹
dunionBy𝐷 :: Ord k => (a -> a -> a) -> (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
dinterBy𝐷 :: Ord k => (a -> b -> c) -> (k ⇰ a) -> (k ⇰ b) -> k ⇰ c
dsdiffBy𝐷 :: forall k b a. Ord k => (a -> b -> 𝑂 a) -> (k ⇰ a) -> (k ⇰ b) -> k ⇰ a
(⋿♭) :: Ord k => k -> (k ⇰ a) -> 𝔹
(⫑♭) :: (Ord k, Eq a) => (k ⇰ a) -> (k ⇰ a) -> 𝔹
(⩌♭) :: Ord k => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
(⩍♭) :: Ord k => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
(⧅♭) :: (Ord k, Eq a) => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
dminView𝐷 :: (k ⇰ a) -> 𝑂 ((k ∧ a) ∧ (k ⇰ a))
dmaxView𝐷 :: (k ⇰ a) -> 𝑂 ((k ∧ a) ∧ (k ⇰ a))
dkeyView𝐷 :: Ord k => k -> (k ⇰ a) -> 𝑂 (a ∧ (k ⇰ a))
dminElem𝐷 :: (k ⇰ a) -> 𝑂 (k ∧ a)
dmaxElem𝐷 :: (k ⇰ a) -> 𝑂 (k ∧ a)
dkeep𝐷 :: Ord k => 𝑃 k -> (k ⇰ a) -> k ⇰ a
dtoss𝐷 :: Ord k => 𝑃 k -> (k ⇰ a) -> k ⇰ a
dict𝐼𝐷 :: Ord k => 𝐼 (k ∧ a) -> k ⇰ a
dkeys𝐷 :: Ord k => (k ⇰ a) -> 𝑃 k
dvals𝐷 :: (k ⇰ a) -> 𝐼 a
mapM𝐷 :: forall m k a b. Monad m => (a -> m b) -> (k ⇰ a) -> m (k ⇰ b)
omapM𝐷 :: forall m k a b. Monad m => (a -> m (𝑂 b)) -> (k ⇰ a) -> m (k ⇰ b)
kmapM𝐷 :: Monad m => (k -> a -> m b) -> (k ⇰ a) -> m (k ⇰ b)
kmapAtM𝐷 :: (Monad m, Ord k) => k -> (a -> m a) -> (k ⇰ a) -> m (k ⇰ a)
okmapM𝐷 :: Monad m => (k -> a -> m (𝑂 b)) -> (k ⇰ a) -> m (k ⇰ b)
okmapAtM𝐷 :: (Monad m, Ord k) => k -> (𝑂 a -> m (𝑂 a)) -> (k ⇰ a) -> m (k ⇰ a)
bimapM𝐷 :: forall m k a b c. (Monad m, Ord k) => (a -> m c) -> (b -> m c) -> (a -> b -> m c) -> (k ⇰ a) -> (k ⇰ b) -> m (k ⇰ c)
obimapM𝐷 :: forall m k a b c. (Monad m, Ord k) => (a -> m (𝑂 c)) -> (b -> m (𝑂 c)) -> (a -> b -> m (𝑂 c)) -> (k ⇰ a) -> (k ⇰ b) -> m (k ⇰ c)
kbimapM𝐷 :: forall m k a b c. (Monad m, Ord k) => (k -> a -> m c) -> (k -> b -> m c) -> (k -> a -> b -> m c) -> (k ⇰ a) -> (k ⇰ b) -> m (k ⇰ c)
okbimapM𝐷 :: forall m k a b c. (Monad m, Ord k) => (k -> a -> m (𝑂 c)) -> (k -> b -> m (𝑂 c)) -> (k -> a -> b -> m (𝑂 c)) -> (k ⇰ a) -> (k ⇰ b) -> m (k ⇰ c)
map𝐷 :: forall k a b. (a -> b) -> (k ⇰ a) -> k ⇰ b
omap𝐷 :: forall k a b. (a -> 𝑂 b) -> (k ⇰ a) -> k ⇰ b
kmap𝐷 :: (k -> a -> b) -> (k ⇰ a) -> k ⇰ b
kmapAt𝐷 :: Ord k => k -> (a -> a) -> (k ⇰ a) -> k ⇰ a
okmap𝐷 :: (k -> a -> 𝑂 b) -> (k ⇰ a) -> k ⇰ b
okmapAt𝐷 :: Ord k => k -> (𝑂 a -> 𝑂 a) -> (k ⇰ a) -> k ⇰ a
bimap𝐷 :: forall k a b c. Ord k => (a -> c) -> (b -> c) -> (a -> b -> c) -> (k ⇰ a) -> (k ⇰ b) -> k ⇰ c
obimap𝐷 :: forall k a b c. Ord k => (a -> 𝑂 c) -> (b -> 𝑂 c) -> (a -> b -> 𝑂 c) -> (k ⇰ a) -> (k ⇰ b) -> k ⇰ c
kbimap𝐷 :: forall k a b c. Ord k => (k -> a -> c) -> (k -> b -> c) -> (k -> a -> b -> c) -> (k ⇰ a) -> (k ⇰ b) -> k ⇰ c
okbimap𝐷 :: forall k a b c. Ord k => (k -> a -> 𝑂 c) -> (k -> b -> 𝑂 c) -> (k -> a -> b -> 𝑂 c) -> (k ⇰ a) -> (k ⇰ b) -> k ⇰ c
csize𝐷 :: (k ⇰ a) -> ℕ64
show𝐷 :: (Show k, Show a) => (k ⇰ a) -> 𝕊
iter𝐷 :: (k ⇰ a) -> 𝐼 (k ∧ a)
single𝐷 :: (k ∧ a) -> k ⇰ a
lookup𝐷 :: Ord k => (k ⇰ a) -> k -> 𝑂 a
null𝐷 :: k ⇰ a
append𝐷 :: (Ord k, Append a) => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
unit𝐷 :: (Ord k, Null k, Null a) => k ⇰ a
cross𝐷 :: (Ord k, Append k, Append a, Cross a) => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
zero𝐷 :: k ⇰ a
plus𝐷 :: (Ord k, Plus a) => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
one𝐷 :: (Ord k, Zero k, Zero a) => k ⇰ a
times𝐷 :: (Ord k, Plus k, Plus a, Times a) => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
plte𝐷 :: (Ord k, POrd a) => (k ⇰ a) -> (k ⇰ a) -> 𝔹
bot𝐷 :: k ⇰ a
join𝐷 :: (Ord k, Join a) => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
meet𝐷 :: (Ord k, Meet a) => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
diff𝐷 :: (Ord k, Difference a) => (k ⇰ a) -> (k ⇰ a) -> k ⇰ a
all𝐷 :: (Ord k, All k, All a) => 𝐼 (k ⇰ a)
dict𝐷 :: (Ord k, ToIter (k ⇰ a) t) => t -> k ⇰ a
assoc𝐷 :: (Ord k, ToIter (k ∧ a) t) => t -> k ⇰ a
dminKey𝐷 :: (k ⇰ a) -> 𝑂 k
dmaxKey𝐷 :: (k ⇰ a) -> 𝑂 k
data family Elem :: Type -> Type
data family ESet :: Type -> Type
data family EDct :: Type -> Type -> Type
class (Set Elem p ESet p, Dict Elem p ESet p EDct p) => ESD p
data StdESD x
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Arithmetic.Plus a) => UVMHS.Core.Classes.Arithmetic.Additive (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Collections.All k, UVMHS.Core.Classes.Collections.All a) => UVMHS.Core.Classes.Collections.All (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (k UVMHS.Core.Init.⇰ a)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.BiFunctorM ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.BiFunctor ((UVMHS.Core.Init.⇰) k)
instance UVMHS.Core.Classes.Lattice.Bot (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance UVMHS.Core.Classes.Lattice.Bot (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance UVMHS.Core.Classes.Lattice.Bot (k UVMHS.Core.Init.⇰ a)
instance UVMHS.Core.Classes.Collections.CSized (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance UVMHS.Core.Classes.Collections.CSized (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Monoid.Append k, UVMHS.Core.Classes.Monoid.Append a, UVMHS.Core.Classes.Monoid.Cross a) => UVMHS.Core.Classes.Monoid.Cross (k UVMHS.Core.Init.⇰ a)
instance GHC.Classes.Ord k => UVMHS.Core.Data.Dict.Dict k (UVMHS.Core.Init.𝑃 k) ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Lattice.Difference (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Lattice.Difference a) => UVMHS.Core.Classes.Lattice.Difference (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance GHC.Classes.Eq e => GHC.Classes.Eq (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Data.Dict.Elem (UVMHS.Core.Data.Dict.StdESD a))
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.FunctorM (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k))
instance UVMHS.Core.Classes.Functors.FunctorM ((UVMHS.Core.Init.⇰) k)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k))
instance UVMHS.Core.Classes.Functors.Functor ((UVMHS.Core.Init.⇰) k)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Lattice.Join a) => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Lattice.Join a) => UVMHS.Core.Classes.Lattice.JoinLattice (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Lattice.Join a) => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Lattice.Join a) => UVMHS.Core.Classes.Lattice.Join (k UVMHS.Core.Init.⇰ a)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.KBiFunctorM k ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.KBiFunctor k ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.KFunctorM k ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.KFunctor k ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Collections.Lookup k a (k UVMHS.Core.Init.⇰ a)
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Lattice.Meet a) => UVMHS.Core.Classes.Lattice.Meet (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Monoid (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Arithmetic.Additive k, UVMHS.Core.Classes.Arithmetic.Multiplicative a) => UVMHS.Core.Classes.Arithmetic.Multiplicative (k UVMHS.Core.Init.⇰ a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance UVMHS.Core.Classes.Monoid.Null (k UVMHS.Core.Init.⇰ a)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.OBiFunctorM ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.OBiFunctor ((UVMHS.Core.Init.⇰) k)
instance UVMHS.Core.Classes.Functors.OFunctorM ((UVMHS.Core.Init.⇰) k)
instance UVMHS.Core.Classes.Functors.OFunctor ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.OKBiFunctorM k ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.OKBiFunctor k ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.OKFunctorM k ((UVMHS.Core.Init.⇰) k)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Functors.OKFunctor k ((UVMHS.Core.Init.⇰) k)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Arithmetic.Zero k, UVMHS.Core.Classes.Arithmetic.Zero a) => UVMHS.Core.Classes.Arithmetic.One (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => GHC.Classes.Ord (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance GHC.Classes.Ord e => GHC.Classes.Ord (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Data.Dict.Elem (UVMHS.Core.Data.Dict.StdESD a))
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Lattice.POrd (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Lattice.POrd a) => UVMHS.Core.Classes.Lattice.POrd (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Arithmetic.Plus a) => UVMHS.Core.Classes.Arithmetic.Plus (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Monoid.Monoid k, UVMHS.Core.Classes.Monoid.Prodoid a) => UVMHS.Core.Classes.Monoid.Prodoid (k UVMHS.Core.Init.⇰ a)
instance GHC.Classes.Ord e => UVMHS.Core.Data.Set.Set (UVMHS.Core.Data.Dict.Elem (UVMHS.Core.Data.Dict.StdESD e)) (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (k UVMHS.Core.Init.⇰ a)
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Collections.Single (UVMHS.Core.Data.Dict.Elem (UVMHS.Core.Data.Dict.StdESD e)) (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Collections.Single (UVMHS.Core.Data.Dict.Elem (UVMHS.Core.Data.Dict.StdESD k) UVMHS.Core.Init.∧ a) (UVMHS.Core.Data.Dict.EDct (UVMHS.Core.Data.Dict.StdESD k) a)
instance GHC.Classes.Ord k => UVMHS.Core.Classes.Collections.Single (k UVMHS.Core.Init.∧ a) (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Arithmetic.Plus k, UVMHS.Core.Classes.Arithmetic.Plus a, UVMHS.Core.Classes.Arithmetic.Times a) => UVMHS.Core.Classes.Arithmetic.Times (k UVMHS.Core.Init.⇰ a)
instance GHC.Classes.Ord e => UVMHS.Core.Classes.Collections.ToIter (UVMHS.Core.Data.Dict.Elem (UVMHS.Core.Data.Dict.StdESD e)) (UVMHS.Core.Data.Dict.ESet (UVMHS.Core.Data.Dict.StdESD e))
instance UVMHS.Core.Classes.Collections.ToIter (k UVMHS.Core.Init.∧ a) (k UVMHS.Core.Init.⇰ a)
instance (GHC.Classes.Ord k, UVMHS.Core.Classes.Monoid.Null k, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Unit (k UVMHS.Core.Init.⇰ a)
instance UVMHS.Core.Classes.Arithmetic.Zero (k UVMHS.Core.Init.⇰ a)

module UVMHS.Core.Data.Lens
newtype a ⟢ b
Lens :: (a -> b ∧ (b -> a)) -> (⟢) a b
[runLens] :: (⟢) a b -> a -> b ∧ (b -> a)
infixr 1 ⟢
data a ⌲ b
Prism :: (b -> a) -> (a -> 𝑂 b) -> (⌲) a b
[construct] :: (⌲) a b -> b -> a
[view] :: (⌲) a b -> a -> 𝑂 b
infixr 1 ⌲
class Alter (t :: Type -> Type -> Type)
alter :: Alter t => t a b -> (b -> b) -> a -> a
class AlterM (t :: Type -> Type -> Type)
alterM :: (AlterM t, Monad m) => t a b -> (b -> m b) -> a -> m a
update :: Alter t => t a b -> b -> a -> a
updateM :: (AlterM t, Monad m) => t a b -> m b -> a -> m a
lens :: (a -> b) -> (a -> b -> a) -> a ⟢ b
isoLens :: (a -> b) -> (b -> a) -> a ⟢ b
access :: (a ⟢ b) -> a -> b
prism :: (b -> a) -> (a -> 𝑂 b) -> a ⌲ b
isoPrism :: (b -> a) -> (a -> b) -> a ⌲ b
viewΩ :: (a ⌲ b) -> a -> b
shape :: (a ⌲ b) -> a -> 𝔹
inlL :: (a ∨ b) ⌲ a
inrL :: (a ∨ b) ⌲ b
fstL :: (a ∧ b) ⟢ a
sndL :: (a ∧ b) ⟢ b
noneL :: 𝑂 a ⌲ ()
someL :: 𝑂 a ⌲ a
nilL :: 𝐿 a ⌲ ()
consL :: 𝐿 a ⌲ (a ∧ 𝐿 a)
singleL :: 𝐿 a ⌲ a
snocL :: 𝐿 a ⌲ (𝐿 a ∧ a)
single𝑆L :: 𝑆 a ⌲ a
empty𝐼L :: 𝐼 a ⌲ ()
single𝐼L :: 𝐼 a ⌲ a
single𝑃L :: Ord a => 𝑃 a ⌲ a
single𝑄L :: Ord a => 𝑄 a ⌲ a
single𝐷L :: Ord k => (k ⇰ v) ⌲ (k ∧ v)
keyL :: Ord k => k -> (k ⇰ v) ⟢ 𝑂 v
keyL𝑂 :: (Ord k, Null v) => k -> (k ⇰ v) ⟢ v
class HasPrism a b
hasPrism :: HasPrism a b => a ⌲ b
class HasLens a b
hasLens :: HasLens a b => a ⟢ b
𝛊 :: HasPrism a b => b -> a
𝛎 :: forall b a. HasPrism a b => a -> 𝑂 b
𝛑 :: HasLens a b => a -> b
𝛏 :: HasLens a b => b -> a -> a
instance UVMHS.Core.Data.Lens.AlterM (UVMHS.Core.Data.Lens.⟢)
instance UVMHS.Core.Data.Lens.Alter (UVMHS.Core.Data.Lens.⌲)
instance UVMHS.Core.Data.Lens.Alter (UVMHS.Core.Data.Lens.⟢)
instance UVMHS.Core.Classes.Morphism.Category (UVMHS.Core.Data.Lens.⌲)
instance UVMHS.Core.Classes.Morphism.Category (UVMHS.Core.Data.Lens.⟢)
instance UVMHS.Core.Data.Lens.HasLens a a
instance UVMHS.Core.Data.Lens.HasPrism a a
instance UVMHS.Core.Classes.Morphism.Reflexive (UVMHS.Core.Data.Lens.⌲)
instance UVMHS.Core.Classes.Morphism.Reflexive (UVMHS.Core.Data.Lens.⟢)
instance UVMHS.Core.Classes.Morphism.Transitive (UVMHS.Core.Data.Lens.⌲)
instance UVMHS.Core.Classes.Morphism.Transitive (UVMHS.Core.Data.Lens.⟢)

module UVMHS.Core.Data.Bitty
shiftL_shim :: Bits a => a -> ℕ64 -> a
shiftR_shim :: Bits a => a -> ℕ64 -> a
bsize_shim :: FiniteBits a => P a -> ℕ64
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitAnd UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitComp UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitOne UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitOr UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitShiftL UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitShiftR UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitSize UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitXor UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.BitZero UVMHS.Core.Init.ℕ8
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.𝔹
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.ℤ16
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.ℤ32
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.ℤ8
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.ℕ16
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.ℕ32
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Classes.Bitty.Bitty UVMHS.Core.Init.ℕ8

module UVMHS.Core.Data

module UVMHS.Core.FilePath
newtype ℙ
ℙ :: 𝕊 -> ℙ
[unℙ] :: ℙ -> 𝕊
pnull :: ℙ
pappend :: ℙ -> ℙ -> ℙ
pfilename :: ℙ -> 𝕊
pbasename :: ℙ -> 𝕊
pdirectory :: ℙ -> ℙ
pextension :: ℙ -> 𝕊
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Core.FilePath.ℙ
instance GHC.Classes.Eq UVMHS.Core.FilePath.ℙ
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Core.FilePath.ℙ
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Core.FilePath.ℙ
instance GHC.Classes.Ord UVMHS.Core.FilePath.ℙ
instance GHC.Show.Show UVMHS.Core.FilePath.ℙ

module UVMHS.Core.Effects
class MonadIO (m :: Type -> Type)
io :: MonadIO m => IO a -> m a
class LiftIO (t :: Type -> Type -> Type -> Type)
liftIO :: (LiftIO t, Monad m) => (forall a. () => IO a -> m a) -> forall a. () => IO a -> t m a
class MonadReader r (m :: Type -> Type) | m -> r
askL :: MonadReader r m => (r ⟢ r') -> m r'
localL :: forall a r'. MonadReader r m => (r ⟢ r') -> r' -> m a -> m a
class LiftReader (t :: Type -> Type -> Type -> Type)
liftAskL :: (LiftReader t, Monad m) => (forall r'. () => (r ⟢ r') -> m r') -> forall r'. () => (r ⟢ r') -> t m r'
liftLocalL :: (LiftReader t, Monad m) => (forall r' a. () => (r ⟢ r') -> r' -> m a -> m a) -> forall r' a. () => (r ⟢ r') -> r' -> t m a -> t m a
class MonadWriter o (m :: Type -> Type) | m -> o
tell :: MonadWriter o m => o -> m ()
hijack :: MonadWriter o m => m a -> m (o ∧ a)
class LiftWriter (t :: Type -> Type -> Type -> Type)
liftTell :: (LiftWriter t, Monad m) => (o -> m ()) -> o -> t m ()
liftHijack :: (LiftWriter t, Monad m) => (forall a. () => m a -> m (o ∧ a)) -> forall a. () => t m a -> t m (o ∧ a)
class MonadState s (m :: Type -> Type) | m -> s
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()
class LiftState (t :: Type -> Type -> Type -> Type)
liftGet :: (LiftState t, Monad m) => m s -> t m s
liftPut :: (LiftState t, Monad m) => (s -> m ()) -> s -> t m ()
class MonadFail (m :: k -> Type)
abort :: forall (a :: k). MonadFail m => m a
(⎅) :: forall (a :: k). MonadFail m => m a -> m a -> m a
infixl 5 ⎅
class LiftFail (t :: Type -> Type -> k -> Type)
liftAbort :: (LiftFail t, Monad m) => (forall a. () => m a) -> forall (a :: k). () => t m a
liftTry :: (LiftFail t, Monad m) => (forall a. () => m a -> m a -> m a) -> forall (a :: k). () => t m a -> t m a -> t m a
class MonadError e (m :: k -> Type) | m -> e
throw :: forall (a :: k). MonadError e m => e -> m a
catch :: forall (a :: k). MonadError e m => m a -> (e -> m a) -> m a
class LiftError (t :: Type -> Type -> k -> Type)
liftThrow :: (LiftError t, Monad m) => (forall a. () => e -> m a) -> forall (a :: k). () => e -> t m a
liftCatch :: (LiftError t, Monad m) => (forall a. () => m a -> (e -> m a) -> m a) -> forall (a :: k). () => t m a -> (e -> t m a) -> t m a
class MonadDelay (m :: k -> Type)
delay :: forall (a :: k). MonadDelay m => (() -> m a) -> m a
class LiftDelay (t :: Type -> Type -> k -> Type)
liftDelay :: (LiftDelay t, Monad m) => (forall a. () => (() -> m a) -> m a) -> forall (a :: k). () => (() -> t m a) -> t m a
class MonadNondet (m :: k -> Type)
mzero :: forall (a :: k). MonadNondet m => m a
(⊞) :: forall (a :: k). MonadNondet m => m a -> m a -> m a
infixl 5 ⊞
class LiftNondet (t :: Type -> Type -> k -> Type)
liftMzero :: (LiftNondet t, Monad m) => (forall a. () => m a) -> forall (a :: k). () => t m a
liftMplus :: (LiftNondet t, Monad m) => (forall a. () => m a -> m a -> m a) -> forall (a :: k). () => t m a -> t m a -> t m a
class MonadTop (m :: k -> Type)
mtop :: forall (a :: k). MonadTop m => m a
class LiftTop (t :: Type -> Type -> k -> Type)
liftMtop :: (LiftTop t, Monad m) => (forall a. () => m a) -> forall (a :: k). () => t m a
class MonadCont r (m :: Type -> Type) | m -> r
callCC :: MonadCont r m => ((a -> m r) -> m r) -> m a
withC :: MonadCont r m => (a -> m r) -> m a -> m r
class LiftCont (t :: Type -> Type -> Type -> Type)
liftCallCC :: (LiftCont t, Monad m) => (forall a. () => ((a -> m r) -> m r) -> m a) -> forall a. () => ((a -> t m r) -> t m r) -> t m a
liftWithC :: (LiftCont t, Monad m) => (forall a. () => (a -> m r) -> m a -> m r) -> forall a. () => (a -> t m r) -> t m a -> t m r
class MonadUCont (m :: Type -> Type)
ucallCC :: MonadUCont m => (forall u. () => (a -> m u) -> m u) -> m a
uwithC :: MonadUCont m => (a -> m u) -> m a -> m u
class LiftUCont (t :: Type -> Type -> Type -> Type)
liftUCallCC :: (LiftUCont t, Monad m) => (forall a. () => (forall u. () => (a -> m u) -> m u) -> m a) -> forall a. () => (forall u. () => (a -> t m u) -> t m u) -> t m a
liftUWithC :: (LiftUCont t, Monad m) => (forall a u. () => (a -> m u) -> m a -> m u) -> forall a u. () => (a -> t m u) -> t m a -> t m u
class MonadBad (m :: k -> Type)
bad :: forall (a :: k). MonadBad m => m a
mapEnvL :: (Monad m, MonadReader r₁ m) => (r₁ ⟢ r₂) -> (r₂ -> r₂) -> m a -> m a
ask :: (Monad m, MonadReader r m) => m r
local :: (Monad m, MonadReader r m) => r -> m a -> m a
mapEnv :: (Monad m, MonadReader r m) => (r -> r) -> m a -> m a
tellL :: (Monoid o₁, Monad m, MonadWriter o₁ m) => (o₁ ⟢ o₂) -> o₂ -> m ()
hijackL :: (Monad m, MonadWriter o₁ m, Null o₂) => (o₁ ⟢ o₂) -> m a -> m (o₂ ∧ a)
mapOut :: (Monad m, MonadWriter o m) => (o -> o) -> m a -> m a
retOut :: forall o m a. (Monad m, MonadWriter o m) => m a -> m o
getL :: (Monad m, MonadState s m) => (s ⟢ a) -> m a
putL :: (Monad m, MonadState s m) => (s ⟢ a) -> a -> m ()
modify :: (Monad m, MonadState s m) => (s -> s) -> m ()
modifyM :: (Monad m, MonadState s m) => (s -> m s) -> m ()
modifyL :: (Monad m, MonadState s m) => (s ⟢ a) -> (a -> a) -> m ()
modifyML :: (Monad m, MonadState s m) => (s ⟢ a) -> (a -> m a) -> m ()
getput :: (Monad m, MonadState s m) => s -> m s
getputL :: (Monad m, MonadState s₁ m) => (s₁ ⟢ s₂) -> s₂ -> m s₂
next :: (Monad m, MonadState s m, Multiplicative s) => m s
nextL :: (Monad m, MonadState s m, Multiplicative a) => (s ⟢ a) -> m a
bump :: (Monad m, MonadState s m, Multiplicative s) => m ()
bumpL :: (Monad m, MonadState s m, Multiplicative a) => (s ⟢ a) -> m ()
localize :: (Monad m, MonadState s m) => s -> m a -> m (s ∧ a)
localizeL :: (Monad m, MonadState s₁ m) => (s₁ ⟢ s₂) -> s₂ -> m a -> m (s₂ ∧ a)
localState :: (Monad m, MonadState s m) => s -> m a -> m a
localStateL :: (Monad m, MonadState s₁ m) => (s₁ ⟢ s₂) -> s₂ -> m a -> m a
retState :: (Monad m, MonadState s m) => m a -> m s
retStateOut :: (Monad m, MonadState s m, MonadWriter o m) => m a -> m (s ∧ o)
tellStateL :: (Monad m, MonadState o₁ m, Append o₂) => (o₁ ⟢ o₂) -> o₂ -> m ()
hijackStateL :: (Monad m, MonadState o₁ m, Null o₂) => (o₁ ⟢ o₂) -> m a -> m (o₂ ∧ a)
localMapStateL :: (Monad m, MonadState s₁ m) => (s₁ ⟢ s₂) -> (s₂ -> s₂) -> m a -> m a
localStateEffectsL :: (Monad m, MonadState s₁ m) => (s₁ ⟢ s₂) -> m a -> m a
failEff :: (Monad m, MonadFail m) => 𝑂 a -> m a
failObs :: (Monad m, MonadFail m) => m a -> m (𝑂 a)
abort𝑂 :: (Monad m, MonadFail m) => 𝑂 a -> m a
tries :: (Monad m, MonadFail m, ToIter (m a) t) => t -> m a
guard :: (Monad m, MonadFail m) => 𝔹 -> m ()
oneOrMoreSplit :: (Monad m, MonadFail m) => m a -> m (a ∧ 𝐿 a)
oneOrMore :: (Monad m, MonadFail m) => m a -> m (𝐿 a)
many :: (Monad m, MonadFail m) => m a -> m (𝐿 a)
throwEff :: (Monad m, MonadError e m) => m (e ∨ a) -> m a
throwObs :: (Monad m, MonadError e m) => m a -> m (e ∨ a)
throw𝑂 :: (Monad m, MonadError e m) => e -> 𝑂 a -> m a
mzeroIfNot :: (Monad m, MonadNondet m) => 𝔹 -> m ()
mconcat :: forall {k} m (a :: k) t. (MonadNondet m, ToIter (m a) t) => t -> m a
from :: (Monad m, MonadNondet m, ToIter a t) => t -> m a
oneOrMoreSplitNT :: (Monad m, MonadNondet m) => m a -> m (a ∧ 𝐿 a)
oneOrMoreNT :: (Monad m, MonadNondet m) => m a -> m (𝐿 a)
manyNT :: (Monad m, MonadNondet m) => m a -> m (𝐿 a)
twoOrMoreSplitNT :: (Monad m, MonadNondet m) => m a -> m ((a ∧ a) ∧ 𝐿 a)
manySepBy :: (Monad m, MonadNondet m) => m () -> m a -> m (𝐿 a)
manyPrefBy :: (Monad m, MonadNondet m) => m () -> m a -> m (𝐿 a)
mzero𝑂 :: (Monad m, MonadNondet m) => 𝑂 a -> m a
return𝑃 :: (Monad m, MonadNondet m) => 𝑃 a -> m a
reset :: (Monad m, MonadCont u m) => m u -> m u
modifyC :: (Monad m, MonadCont u m) => (u -> m u) -> m ()
withCOn :: (Monad m, MonadCont u m) => m a -> (a -> m u) -> m u
putEnv :: (Monad m, MonadReader r m, MonadCont u m) => r -> m ()
putEnvL :: (Monad m, MonadReader r m, MonadCont u m) => (r ⟢ r') -> r' -> m ()
modifyEnv :: (Monad m, MonadReader r m, MonadCont u m) => (r -> r) -> m ()
modifyEnvL :: (Monad m, MonadReader r m, MonadCont u m) => (r ⟢ r') -> (r' -> r') -> m ()
ureset :: (Monad m, MonadUCont m) => m a -> m a
umodifyC :: (Monad m, MonadUCont m) => (forall u. () => u -> m u) -> m ()
uwithCOn :: (Monad m, MonadUCont m) => m a -> (a -> m u) -> m u
uputEnv :: (Monad m, MonadReader r m, MonadUCont m) => r -> m ()
uputEnvL :: (Monad m, MonadReader r m, MonadUCont m) => (r ⟢ r') -> r' -> m ()
umodifyEnv :: (Monad m, MonadReader r m, MonadUCont m) => (r -> r) -> m ()
umodifyEnvL :: (Monad m, MonadReader r m, MonadUCont m) => (r ⟢ r') -> (r' -> r') -> m ()
unextEnvL :: (Monad m, MonadReader r m, MonadUCont m, Zero a, One a, Plus a) => (r ⟢ a) -> m a
deriveAskL :: forall m₁ (m₂ :: Type -> Type) r r'. (m₁ ⇄⁻ m₂, MonadReader r m₂) => (r ⟢ r') -> m₁ r'
deriveLocal :: forall m₁ (m₂ :: Type -> Type) r r' a. (m₁ ⇄⁻ m₂, MonadReader r m₂) => (r ⟢ r') -> r' -> m₁ a -> m₁ a
deriveTell :: forall m₁ (m₂ :: Type -> Type) o. (m₁ ⇄⁻ m₂, MonadWriter o m₂) => o -> m₁ ()
deriveHijack :: forall m₁ (m₂ :: Type -> Type) o a. (m₁ ⇄⁻ m₂, MonadWriter o m₂) => m₁ a -> m₁ (o ∧ a)
deriveGet :: forall m₁ (m₂ :: Type -> Type) s. (m₁ ⇄⁻ m₂, MonadState s m₂) => m₁ s
derivePut :: forall m₁ (m₂ :: Type -> Type) s. (m₁ ⇄⁻ m₂, MonadState s m₂) => s -> m₁ ()
deriveAbort :: forall m₁ (m₂ :: Type -> Type) a. (m₁ ⇄⁻ m₂, MonadFail m₂) => m₁ a
deriveTry :: forall m₁ (m₂ :: Type -> Type) a. (m₁ ⇄⁻ m₂, MonadFail m₂) => m₁ a -> m₁ a -> m₁ a
deriveThrow :: forall m₁ (m₂ :: Type -> Type) e a. (m₁ ⇄⁻ m₂, MonadError e m₂) => e -> m₁ a
deriveCatch :: forall m₁ (m₂ :: Type -> Type) e a. (m₁ ⇄⁻ m₂, MonadError e m₂) => m₁ a -> (e -> m₁ a) -> m₁ a
deriveMzero :: forall m₁ (m₂ :: Type -> Type) a. (m₁ ⇄⁻ m₂, MonadNondet m₂) => m₁ a
deriveMplus :: forall m₁ (m₂ :: Type -> Type) a. (m₁ ⇄⁻ m₂, MonadNondet m₂) => m₁ a -> m₁ a -> m₁ a
deriveMtop :: forall m₁ (m₂ :: Type -> Type) a. (m₁ ⇄⁻ m₂, MonadTop m₂) => m₁ a
deriveCallCC :: forall m₁ (m₂ :: Type -> Type) r a. (m₁ ⇄⁻ m₂, MonadCont r m₂) => ((a -> m₁ r) -> m₁ r) -> m₁ a
deriveWithC :: forall m₁ (m₂ :: Type -> Type) r a. (m₁ ⇄⁻ m₂, MonadCont r m₂) => (a -> m₁ r) -> m₁ a -> m₁ r
instance UVMHS.Core.Effects.MonadError e ((UVMHS.Core.Init.∨) e)
instance UVMHS.Core.Effects.MonadFail UVMHS.Core.Init.𝑂
instance UVMHS.Core.Effects.MonadNondet UVMHS.Core.Init.𝐼
instance UVMHS.Core.Effects.MonadNondet UVMHS.Core.Init.𝐿
instance UVMHS.Core.Effects.MonadNondet UVMHS.Core.Init.𝑄
instance UVMHS.Core.Effects.MonadReader r ((->) r)
instance UVMHS.Core.Classes.Monoid.Null o => UVMHS.Core.Effects.MonadWriter o ((UVMHS.Core.Init.∧) o)

module UVMHS.Core.Chunky
trℕ8 :: ℕ64 -> ℕ8
toBitsℤ64 :: ℤ64 -> ℕ64
frBitsℤ64 :: ℕ64 -> ℤ64
toBits𝔻 :: 𝔻 -> ℕ64
frBits𝔻 :: ℕ64 -> 𝔻
skipChunk :: Monad m => m ℕ8 -> ℕ64 -> m ()
emptyChunk :: ℕ64 -> 𝐼 ℕ8
joinBytes :: (ℕ8, ℕ8, ℕ8, ℕ8, ℕ8, ℕ8, ℕ8, ℕ8) -> ℕ64
splitBytes :: ℕ64 -> (ℕ8, ℕ8, ℕ8, ℕ8, ℕ8, ℕ8, ℕ8, ℕ8)
class Chunky a
chunkSize :: Chunky a => P a -> ℕ64
fromChunk :: (Chunky a, Monad m) => m ℕ8 -> m a
toChunk :: Chunky a => a -> 𝐼 ℕ8
instance UVMHS.Core.Chunky.Chunky UVMHS.Core.Init.𝔹
instance UVMHS.Core.Chunky.Chunky UVMHS.Core.Init.ℂ
instance UVMHS.Core.Chunky.Chunky UVMHS.Core.Init.𝔻
instance UVMHS.Core.Chunky.Chunky UVMHS.Core.Init.ℤ64
instance UVMHS.Core.Chunky.Chunky ()
instance UVMHS.Core.Chunky.Chunky UVMHS.Core.Init.ℕ64
instance UVMHS.Core.Chunky.Chunky UVMHS.Core.Init.ℕ8
instance (UVMHS.Core.Chunky.Chunky a, UVMHS.Core.Chunky.Chunky b) => UVMHS.Core.Chunky.Chunky (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Chunky.Chunky a, UVMHS.Core.Chunky.Chunky b) => UVMHS.Core.Chunky.Chunky (a UVMHS.Core.Init.∨ b)
instance (UVMHS.Core.Chunky.Chunky b, a UVMHS.Core.Classes.Morphism.⇄ b) => UVMHS.Core.Chunky.Chunky a

module UVMHS.Core.LensDerivedInstances

module UVMHS.Core.Pointed
data AddNull a
Null :: AddNull a
AddNull :: a -> AddNull a
elimAddNull :: b -> (a -> b) -> AddNull a -> b
data ZOM a
NullZOM :: ZOM a
OneZOM :: a -> ZOM a
MoreZOM :: ZOM a
elimZOM :: b -> (a -> b) -> b -> ZOM a -> b
data AddBot a
Bot :: AddBot a
AddBot :: a -> AddBot a
elimAddBot :: b -> (a -> b) -> AddBot a -> b
data AddTop a
AddTop :: a -> AddTop a
Top :: AddTop a
elimAddTop :: b -> (a -> b) -> AddTop a -> b
data AddBT a
BotBT :: AddBT a
AddBT :: a -> AddBT a
TopBT :: AddBT a
addTopL :: AddTop a ⌲ a
nullZOML :: ZOM a ⌲ ()
oneZOML :: ZOM a ⌲ a
moreZOML :: ZOM a ⌲ ()
instance UVMHS.Core.Classes.Arithmetic.Additive a => UVMHS.Core.Classes.Arithmetic.Additive (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Pointed.AddNull a)
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Pointed.ZOM a)
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Pointed.AddBT
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Pointed.AddBot
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Pointed.AddNull
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Pointed.AddTop
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Pointed.ZOM
instance UVMHS.Core.Classes.Lattice.Bot (UVMHS.Core.Pointed.AddBT a)
instance UVMHS.Core.Classes.Lattice.Bot (UVMHS.Core.Pointed.AddBot a)
instance UVMHS.Core.Classes.Lattice.Bot a => UVMHS.Core.Classes.Lattice.Bot (UVMHS.Core.Pointed.AddTop a)
instance (UVMHS.Core.Classes.Lattice.Bot a, UVMHS.Core.Classes.Lattice.Difference a) => UVMHS.Core.Classes.Lattice.Difference (UVMHS.Core.Pointed.AddTop a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Pointed.AddBT a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Pointed.AddBot a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Pointed.AddNull a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Pointed.AddTop a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Pointed.ZOM a)
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Pointed.AddBT
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Pointed.AddBot
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Pointed.AddNull
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Pointed.AddTop
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Pointed.ZOM
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Pointed.AddBT
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Pointed.AddBot
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Pointed.AddNull
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Pointed.AddTop
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Pointed.ZOM
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.Pointed.AddBT a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.Pointed.AddBot a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Core.Pointed.AddBT a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Core.Pointed.AddBot a)
instance UVMHS.Core.Classes.Lattice.JoinLattice a => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Core.Pointed.AddTop a)
instance (UVMHS.Core.Classes.Lattice.Join a, UVMHS.Core.Classes.Lattice.Meet a) => UVMHS.Core.Classes.Lattice.Lattice (UVMHS.Core.Pointed.AddBT a)
instance (UVMHS.Core.Classes.Lattice.Join a, UVMHS.Core.Classes.Lattice.MeetLattice a) => UVMHS.Core.Classes.Lattice.Lattice (UVMHS.Core.Pointed.AddBot a)
instance (UVMHS.Core.Classes.Lattice.JoinLattice a, UVMHS.Core.Classes.Lattice.Meet a) => UVMHS.Core.Classes.Lattice.Lattice (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Core.Pointed.AddBT a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Core.Pointed.AddBot a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.MeetLattice (UVMHS.Core.Pointed.AddBT a)
instance UVMHS.Core.Classes.Lattice.MeetLattice a => UVMHS.Core.Classes.Lattice.MeetLattice (UVMHS.Core.Pointed.AddBot a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.MeetLattice (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Pointed.AddBT
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Pointed.AddBot
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Pointed.AddNull
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Pointed.AddTop
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Pointed.ZOM
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Pointed.AddNull a)
instance UVMHS.Core.Classes.Monoid.Monoid a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Pointed.ZOM a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Pointed.AddNull a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Pointed.ZOM a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Pointed.AddBT a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Pointed.AddBot a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Pointed.AddNull a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Pointed.AddTop a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Pointed.ZOM a)
instance UVMHS.Core.Classes.Lattice.POrd a => UVMHS.Core.Classes.Lattice.POrd (UVMHS.Core.Pointed.AddBot a)
instance UVMHS.Core.Classes.Lattice.POrd a => UVMHS.Core.Classes.Lattice.POrd (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Arithmetic.Plus a => UVMHS.Core.Classes.Arithmetic.Plus (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Pointed.AddBT
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Pointed.AddBot
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Pointed.AddNull
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Pointed.AddTop
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Pointed.ZOM
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Pointed.AddBT a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Pointed.AddBot a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Pointed.AddNull a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Pointed.AddTop a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Pointed.ZOM a)
instance UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Pointed.ZOM a)
instance UVMHS.Core.Classes.Arithmetic.Times a => UVMHS.Core.Classes.Arithmetic.Times (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Lattice.Top (UVMHS.Core.Pointed.AddBT a)
instance UVMHS.Core.Classes.Lattice.Top a => UVMHS.Core.Classes.Lattice.Top (UVMHS.Core.Pointed.AddBot a)
instance UVMHS.Core.Classes.Lattice.Top (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Core.Classes.Arithmetic.Zero a => UVMHS.Core.Classes.Arithmetic.Zero (UVMHS.Core.Pointed.AddTop a)

module UVMHS.Core.Static
type family (a :: k) ≡ (b :: k) :: Bool
type family (x :: 𝔹) ⩔ (y :: 𝔹) :: 𝔹
type family (x :: 𝔹) ⩓ (y :: 𝔹) :: 𝔹
type 𝐍 = Nat
type 𝐒 = Symbol
type (m :: 𝐍) + (n :: 𝐍) = m + n
type (m :: 𝐍) × (n :: 𝐍) = m * n
type (m :: 𝐍) ^ (n :: 𝐍) = m ^ n
type (m :: 𝐍) - (n :: 𝐍) = m - n
type (m :: 𝐍) / (n :: 𝐍) = Div m n
type (m :: 𝐍) % (n :: 𝐍) = Mod m n
type Log2 (n :: 𝐍) = Log2 n
type (m :: 𝐍) ⋚ (n :: 𝐍) = CmpNat m n
type (m :: 𝐍) ≺ (n :: 𝐍) = m ⋚ n ≡ 'LT ~ 'True
infix 4 ≺
type (m :: 𝐍) ≍ (n :: 𝐍) = m ⋚ n ≡ 'EQ ~ 'True
infix 4 ≍
type (m :: 𝐍) ≻ (n :: 𝐍) = m ⋚ n ≡ 'GT ~ 'True
infix 4 ≻
type (m :: 𝐍) ≼ (n :: 𝐍) = m ⋚ n ≡ 'LT ⩔ m ⋚ n ≡ 'EQ ~ 'True
infix 4 ≼
wnlt_UNSAFE :: forall (m :: 𝐍) (n :: 𝐍). P m -> P n -> W (m ≺ n)
wneq_UNSAFE :: forall (m :: 𝐍) (n :: 𝐍). P m -> P n -> W (m ≍ n)
wngt_UNSAFE :: forall (m :: 𝐍) (n :: 𝐍). P m -> P n -> W (m ≻ n)
wnlte_UNSAFE :: forall (m :: 𝐍) (n :: 𝐍). P m -> P n -> W (m ≼ n)
data (m :: 𝐍) < (n :: 𝐍)
[W_LT] :: forall (m :: 𝐍) (n :: 𝐍). m ≺ n => m < n
infix 4 <
withLT :: forall (m :: 𝐍) (n :: 𝐍) a. (m < n) -> (m ≺ n => a) -> a
nlt_UNSAFE :: forall (m :: 𝐍) (n :: 𝐍). P m -> P n -> m < n
data (m :: 𝐍) ≤ (n :: 𝐍)
[W_LTE] :: forall (m :: 𝐍) (n :: 𝐍). m ≼ n => m ≤ n
infix 4 ≤
withLTE :: forall (m :: 𝐍) (n :: 𝐍) a. (m ≤ n) -> (m ≼ n => a) -> a
nlte_UNSAFE :: forall (m :: 𝐍) (n :: 𝐍). P m -> P n -> m ≤ n
irreflLT :: forall (n :: 𝐍). (n < n) -> Void
weakenLT :: forall (n₁ :: 𝐍) (n₂ :: 𝐍). (n₁ < n₂) -> n₁ ≤ n₂
succLT :: forall (n₁ :: 𝐍) (n₂ :: 𝐍). (n₁ < n₂) -> (n₁ + 1) ≤ n₂
succLTE :: forall (n₁ :: 𝐍) (n₂ :: 𝐍). (n₁ ≤ n₂) -> n₁ < (n₂ + 1)
(⊚♯) :: forall (n₁ :: 𝐍) (n₂ :: 𝐍) (n₃ :: 𝐍). (n₁ ≤ n₂) -> (n₂ < n₃) -> n₁ < n₃
(♯⊚) :: forall (n₁ :: 𝐍) (n₂ :: 𝐍) (n₃ :: 𝐍). (n₁ < n₂) -> (n₂ ≤ n₃) -> n₁ < n₃
newtype ℕS (n :: 𝐍)
ℕS_UNSAFE :: ℕ -> ℕS (n :: 𝐍)
[unℕS] :: ℕS (n :: 𝐍) -> ℕ
newtype ℕ64S (n :: 𝐍)
ℕ64S_UNSAFE :: ℕ64 -> ℕ64S (n :: 𝐍)
[unℕ64S] :: ℕ64S (n :: 𝐍) -> ℕ64
newtype 𝕊S (s :: 𝐒)
𝕊S_UNSAFE :: 𝕊 -> 𝕊S (s :: 𝐒)
[un𝕊S] :: 𝕊S (s :: 𝐒) -> 𝕊
class KnownNat n => 𝒩 (n :: 𝐍)
reifyℕ :: 𝒩 n => P n -> ℕ
class KnownNat n => 𝒩64 (n :: 𝐍)
reifyℕ64 :: 𝒩64 n => P n -> ℕ64
class KnownSymbol s => 𝒮 (s :: 𝐒)
reify𝕊 :: 𝒮 s => P s -> 𝕊
compare𝐍 :: forall (a :: 𝐍) (b :: 𝐍). (𝒩 a, 𝒩 b) => 𝑂 (a ≟ b)
𝕟s :: forall (n :: 𝐍). 𝒩 n => ℕS n
𝕟d :: ℕ -> (forall (n :: 𝐍). 𝒩 n => ℕS n -> a) -> a
𝕟64s :: forall (n :: 𝐍). 𝒩64 n => ℕ64S n
𝕟64d :: ℕ64 -> (forall (n :: 𝐍). 𝒩64 n => ℕ64S n -> a) -> a
𝕤s :: forall (s :: Symbol). KnownSymbol s => 𝕊S s
𝕤sd :: 𝕊 -> (forall (s :: 𝐒). 𝒮 s => 𝕊S s -> a) -> a
type family (xs :: [a]) ⧺ (ys :: [a]) :: [a]
type family Sum (ns :: [𝐍]) :: Natural
type family Prod (ns :: [𝐍]) :: Natural
type family AllC (c :: a -> Constraint) (xs :: [a])
data Spine (b :: [a])
[NilSpine] :: forall {a}. Spine ('[] :: [a])
[ConsSpine] :: forall {a} (xs :: [a]) (x :: a). Spine xs -> Spine (x ': xs)
class HasSpine (xs :: [a])
spine :: HasSpine xs => Spine xs
newtype 𝕀64 (n :: 𝐍)
𝕀64_UNSAFE :: ℕ64 -> 𝕀64 (n :: 𝐍)
[un𝕀64] :: 𝕀64 (n :: 𝐍) -> ℕ64
𝕚64 :: forall (m :: 𝐍) (n :: 𝐍). m ≺ n => ℕ64S m -> 𝕀64 n
𝕚64d :: forall (n :: 𝐍). 𝒩64 n => ℕ64 -> 𝑂 (𝕀64 n)
𝕟64di :: forall (n :: 𝐍) a. 𝕀64 n -> (forall (m :: 𝐍). m ≺ n => ℕ64S m -> a) -> a
upto𝕀64 :: forall (n :: 𝐍). 𝒩64 n => ℕ64S n -> 𝐼S n (𝕀64 n)
wk𝕀64 :: forall (m :: 𝐍) (n :: 𝐍). m ≼ n => 𝕀64 m -> 𝕀64 n
newtype 𝐼S (n :: 𝐍) a
𝐼S_UNSAFE :: 𝐼 a -> 𝐼S (n :: 𝐍) a
[un𝐼S] :: 𝐼S (n :: 𝐍) a -> 𝐼 a
class NullS (t :: Natural -> k -> Type)
nullS :: forall (a :: k). NullS t => t 0 a
class SingleS (t :: Natural -> Type -> Type)
𝔢 :: SingleS t => a -> t 1 a
class AppendS (t :: 𝐍 -> k -> Type)
(⧺♮) :: forall (n₁ :: 𝐍) (a :: k) (n₂ :: 𝐍). AppendS t => t n₁ a -> t n₂ a -> t (n₁ + n₂) a
instance UVMHS.Core.Static.AppendS UVMHS.Core.Static.𝐼S
instance UVMHS.Core.Classes.Morphism.Category (UVMHS.Core.Static.≤)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Static.𝐼S n)
instance forall a (xs :: [a]) (x :: a). UVMHS.Core.Static.HasSpine xs => UVMHS.Core.Static.HasSpine (x : xs)
instance UVMHS.Core.Static.HasSpine '[]
instance UVMHS.Core.Static.NullS UVMHS.Core.Static.𝐼S
instance UVMHS.Core.Classes.Morphism.Reflexive (UVMHS.Core.Static.≤)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Static.𝐼S n a)
instance UVMHS.Core.Static.SingleS UVMHS.Core.Static.𝐼S
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Static.𝐼S n a)
instance UVMHS.Core.Classes.Morphism.Transitive (UVMHS.Core.Static.<)
instance UVMHS.Core.Classes.Morphism.Transitive (UVMHS.Core.Static.≤)
instance GHC.TypeNats.KnownNat n => UVMHS.Core.Static.𝒩64 n
instance GHC.TypeNats.KnownNat n => UVMHS.Core.Static.𝒩 n
instance GHC.TypeLits.KnownSymbol s => UVMHS.Core.Static.𝒮 s

module UVMHS.Core.Time
type Time = UTCTime
type TimeD = NominalDiffTime
secondsTimeD :: TimeD -> 𝔻
(⨺) :: Time -> Time -> TimeD
infixl 5 ⨺
(⨹) :: Time -> TimeD -> Time
infixl 5 ⨹
now :: IO Time
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Core.Time.TimeD
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Core.Time.TimeD
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Core.Time.TimeD
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Core.Time.TimeD
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Core.Time.TimeD
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Core.Time.TimeD

module UVMHS.Core.Transformers
newtype ( (t₁ :: Type -> Type -> Type -> Type) ⊡ (t₂ :: Type -> Type -> Type -> Type) ) (m :: Type -> Type) a
Compose2 :: t₁ (t₂ m) a -> (⊡) (t₁ :: (Type -> Type) -> Type -> Type) (t₂ :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) a
[unCompose2] :: (⊡) (t₁ :: (Type -> Type) -> Type -> Type) (t₂ :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) a -> t₁ (t₂ m) a
infixl 7 ⊡
deriveLiftIO :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m. (Monad m, t₁ ⇄⁼ t₂, LiftIO t₂) => (forall a. () => IO a -> m a) -> forall a. () => IO a -> t₁ m a
deriveLiftAskL :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m r. (Monad m, t₁ ⇄⁼ t₂, LiftReader t₂) => (forall r'. () => (r ⟢ r') -> m r') -> forall r'. () => (r ⟢ r') -> t₁ m r'
deriveLiftLocalL :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m r. (Monad m, t₁ ⇄⁼ t₂, LiftReader t₂) => (forall r' a. () => (r ⟢ r') -> r' -> m a -> m a) -> forall r' a. () => (r ⟢ r') -> r' -> t₁ m a -> t₁ m a
deriveLiftTell :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m o. (Monad m, t₁ ⇄⁼ t₂, LiftWriter t₂) => (o -> m ()) -> o -> t₁ m ()
deriveLiftHijack :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m o. (Monad m, t₁ ⇄⁼ t₂, LiftWriter t₂) => (forall a. () => m a -> m (o ∧ a)) -> forall a. () => t₁ m a -> t₁ m (o ∧ a)
deriveLiftGet :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m s. (Monad m, t₁ ⇄⁼ t₂, LiftState t₂) => m s -> t₁ m s
deriveLiftPut :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m s. (Monad m, t₁ ⇄⁼ t₂, LiftState t₂) => (s -> m ()) -> s -> t₁ m ()
deriveLiftAbort :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m. (Monad m, t₁ ⇄⁼ t₂, LiftFail t₂) => (forall a. () => m a) -> forall a. () => t₁ m a
deriveLiftTry :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m. (Monad m, t₁ ⇄⁼ t₂, LiftFail t₂) => (forall a. () => m a -> m a -> m a) -> forall a. () => t₁ m a -> t₁ m a -> t₁ m a
deriveLiftThrow :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m e. (Monad m, t₁ ⇄⁼ t₂, LiftError t₂) => (forall a. () => e -> m a) -> forall a. () => e -> t₁ m a
deriveLiftCatch :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m e. (Monad m, t₁ ⇄⁼ t₂, LiftError t₂) => (forall a. () => m a -> (e -> m a) -> m a) -> forall a. () => t₁ m a -> (e -> t₁ m a) -> t₁ m a
deriveLiftDelay :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m. (Monad m, t₁ ⇄⁼ t₂, LiftDelay t₂) => (forall a. () => (() -> m a) -> m a) -> forall a. () => (() -> t₁ m a) -> t₁ m a
deriveLiftMzero :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m. (Monad m, t₁ ⇄⁼ t₂, LiftNondet t₂) => (forall a. () => m a) -> forall a. () => t₁ m a
deriveLiftMplus :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m. (Monad m, t₁ ⇄⁼ t₂, LiftNondet t₂) => (forall a. () => m a -> m a -> m a) -> forall a. () => t₁ m a -> t₁ m a -> t₁ m a
deriveLiftMtop :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m. (Monad m, t₁ ⇄⁼ t₂, LiftTop t₂) => (forall a. () => m a) -> forall a. () => t₁ m a
deriveLiftCallCC :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m r. (Monad m, t₁ ⇄⁼ t₂, LiftCont t₂) => (forall a. () => ((a -> m r) -> m r) -> m a) -> forall a. () => ((a -> t₁ m r) -> t₁ m r) -> t₁ m a
deriveLiftWithC :: forall t₁ (t₂ :: (Type -> Type) -> Type -> Type) m r. (Monad m, t₁ ⇄⁼ t₂, LiftCont t₂) => (forall a. () => (a -> m r) -> m a -> m r) -> forall a. () => (a -> t₁ m r) -> t₁ m a -> t₁ m r
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₁ m'), forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Classes.Functors.Monad m) => UVMHS.Core.Classes.Functors.Bind ((UVMHS.Core.Transformers.⊡) t₁ t₂ m)
instance (UVMHS.Core.Classes.Functors.Functor2 t₁, UVMHS.Core.Classes.Functors.Functor2 t₂) => UVMHS.Core.Classes.Functors.Functor2 (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₁ m'), forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Classes.Functors.Monad m) => UVMHS.Core.Classes.Functors.Functor ((UVMHS.Core.Transformers.⊡) t₁ t₂ m)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftCont t₁, UVMHS.Core.Effects.LiftCont t₂) => UVMHS.Core.Effects.LiftCont (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftDelay t₁, UVMHS.Core.Effects.LiftDelay t₂) => UVMHS.Core.Effects.LiftDelay (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftError t₁, UVMHS.Core.Effects.LiftError t₂) => UVMHS.Core.Effects.LiftError (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftFail t₁, UVMHS.Core.Effects.LiftFail t₂) => UVMHS.Core.Effects.LiftFail (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftIO t₁, UVMHS.Core.Effects.LiftIO t₂) => UVMHS.Core.Effects.LiftIO (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftNondet t₁, UVMHS.Core.Effects.LiftNondet t₂) => UVMHS.Core.Effects.LiftNondet (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftReader t₁, UVMHS.Core.Effects.LiftReader t₂) => UVMHS.Core.Effects.LiftReader (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftState t₁, UVMHS.Core.Effects.LiftState t₂) => UVMHS.Core.Effects.LiftState (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftTop t₁, UVMHS.Core.Effects.LiftTop t₂) => UVMHS.Core.Effects.LiftTop (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Effects.LiftWriter t₁, UVMHS.Core.Effects.LiftWriter t₂) => UVMHS.Core.Effects.LiftWriter (t₁ UVMHS.Core.Transformers.⊡ t₂)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₁ m'), forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Classes.Functors.Monad m) => UVMHS.Core.Classes.Functors.Monad ((UVMHS.Core.Transformers.⊡) t₁ t₂ m)
instance (forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₁ m'), forall (m' :: * -> *). UVMHS.Core.Classes.Functors.Monad m' => UVMHS.Core.Classes.Functors.Monad (t₂ m'), UVMHS.Core.Classes.Functors.Monad m) => UVMHS.Core.Classes.Functors.Return ((UVMHS.Core.Transformers.⊡) t₁ t₂ m)

module UVMHS.Core.Monads
newtype MU (m :: Type -> Type)
MU :: m () -> MU (m :: Type -> Type)
[unMU] :: MU (m :: Type -> Type) -> m ()
onMU :: (m () -> m ()) -> MU m -> MU m
newtype ID a
ID :: a -> ID a
[unID] :: ID a -> a
newtype ReaderT r (m :: k -> Type) (a :: k)
ReaderT :: (r -> m a) -> ReaderT r (m :: k -> Type) (a :: k)
[unReaderT] :: ReaderT r (m :: k -> Type) (a :: k) -> r -> m a
runReaderT :: forall {k} r m (a :: k). r -> ReaderT r m a -> m a
newtype WriterT o (m :: Type -> Type) a
WriterT :: m (o ∧ a) -> WriterT o (m :: Type -> Type) a
[unWriterT] :: WriterT o (m :: Type -> Type) a -> m (o ∧ a)
evalWriterT :: forall o m a. Functor m => WriterT o m a -> m a
newtype StateT s (m :: Type -> Type) a
StateT :: (s -> m (s ∧ a)) -> StateT s (m :: Type -> Type) a
[unStateT] :: StateT s (m :: Type -> Type) a -> s -> m (s ∧ a)
runStateT :: s -> StateT s m a -> m (s ∧ a)
evalStateT :: forall s m a. Functor m => s -> StateT s m a -> m a
type State s = StateT s ID
mkState :: (s -> s ∧ a) -> State s a
runState :: s -> State s a -> s ∧ a
evalState :: s -> State s a -> a
newtype FailT (m :: Type -> Type) a
FailT :: m (𝑂 a) -> FailT (m :: Type -> Type) a
[unFailT] :: FailT (m :: Type -> Type) a -> m (𝑂 a)
newtype ErrorT e (m :: Type -> Type) a
ErrorT :: m (e ∨ a) -> ErrorT e (m :: Type -> Type) a
[unErrorT] :: ErrorT e (m :: Type -> Type) a -> m (e ∨ a)
newtype DelayT (m :: k -> Type) (a :: k)
DelayT :: (() -> m a) -> DelayT (m :: k -> Type) (a :: k)
[unDelayT] :: DelayT (m :: k -> Type) (a :: k) -> () -> m a
runDelayT :: forall {k} m (a :: k). DelayT m a -> m a
newtype NondetT (m :: Type -> Type) a
NondetT :: m (𝑄 a) -> NondetT (m :: Type -> Type) a
[unNondetT] :: NondetT (m :: Type -> Type) a -> m (𝑄 a)
newtype ContT (u :: k) (m :: k -> Type) a
ContT :: ((a -> m u) -> m u) -> ContT (u :: k) (m :: k -> Type) a
[unContT] :: ContT (u :: k) (m :: k -> Type) a -> (a -> m u) -> m u
runContT :: forall {k} a m (u :: k). (a -> m u) -> ContT u m a -> m u
evalContT :: Return m => ContT u m u -> m u
newtype UContT (m :: k -> Type) a
UContT :: (forall (u :: k). () => (a -> m u) -> m u) -> UContT (m :: k -> Type) a
[unUContT] :: UContT (m :: k -> Type) a -> forall (u :: k). () => (a -> m u) -> m u
runUContT :: forall {k} (u :: k) m a. (a -> m u) -> UContT m a -> m u
evalUContT :: Return m => UContT m a -> m a
newtype RWST r o s (m :: Type -> Type) a
RWST :: ReaderT r (WriterT o (StateT s m)) a -> RWST r o s (m :: Type -> Type) a
[unRWST] :: RWST r o s (m :: Type -> Type) a -> ReaderT r (WriterT o (StateT s m)) a
mkRWST :: forall r o s m a. Monad m => (r -> s -> m ((s ∧ o) ∧ a)) -> RWST r o s m a
runRWST :: forall r o s m a. Monad m => r -> s -> RWST r o s m a -> m ((s ∧ o) ∧ a)
evalRWST :: forall r o s m a. Monad m => r -> s -> RWST r o s m a -> m a
type RWS r o s = RWST r o s ID
mkRWS :: forall r o s a. (r -> s -> (s ∧ o) ∧ a) -> RWS r o s a
runRWS :: forall r o s a. r -> s -> RWS r o s a -> (s ∧ o) ∧ a
evalRWS :: forall r o s a. r -> s -> RWS r o s a -> a
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Append u) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.ContT u m a)
instance UVMHS.Core.Classes.Constraints.Const UVMHS.Core.Classes.Monoid.Append m => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.DelayT m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Append e, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.ErrorT e m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.FailT m a)
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.ID a)
instance UVMHS.Core.Classes.Functors.Bind m => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.MU m)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Append o, UVMHS.Core.Classes.Monoid.Append s, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.RWST r o s m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.ReaderT r m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Append s, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.StateT s m a)
instance UVMHS.Core.Classes.Constraints.Const UVMHS.Core.Classes.Monoid.Append m => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.UContT m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Append o, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Monads.WriterT o m a)
instance forall k (u :: k) (m :: k -> *). UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.ContT u m)
instance UVMHS.Core.Classes.Functors.Bind m => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.DelayT m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.ErrorT e m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.FailT m)
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Core.Monads.ID
instance UVMHS.Core.Classes.Functors.Bind GHC.Types.IO
instance (UVMHS.Core.Classes.Functors.Bind m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Monoid m) => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Append o) => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.RWST r o s m)
instance UVMHS.Core.Classes.Functors.Bind m => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.ReaderT r m)
instance UVMHS.Core.Classes.Functors.Bind m => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.StateT s m)
instance forall k (m :: k -> *). UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Append o) => UVMHS.Core.Classes.Functors.Bind (UVMHS.Core.Monads.WriterT o m)
instance UVMHS.Core.Classes.Lattice.Bot a => UVMHS.Core.Classes.Lattice.Bot (UVMHS.Core.Monads.ID a)
instance UVMHS.Core.Classes.Comonad.Cobind UVMHS.Core.Monads.ID
instance UVMHS.Core.Classes.Comonad.Comonad UVMHS.Core.Monads.ID
instance UVMHS.Core.Classes.Lattice.Difference a => UVMHS.Core.Classes.Lattice.Difference (UVMHS.Core.Monads.ID a)
instance UVMHS.Core.Classes.Lattice.Dual a => UVMHS.Core.Classes.Lattice.Dual (UVMHS.Core.Monads.ID a)
instance UVMHS.Core.Classes.Comonad.Extract UVMHS.Core.Monads.ID
instance UVMHS.Core.Classes.Functors.Functor2Iso (UVMHS.Core.Monads.ContT u)
instance UVMHS.Core.Classes.Functors.Functor2Iso UVMHS.Core.Monads.UContT
instance UVMHS.Core.Classes.Functors.Functor2 UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Classes.Functors.Functor2 (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Classes.Functors.Functor2 UVMHS.Core.Monads.FailT
instance UVMHS.Core.Classes.Monoid.Monoid o => UVMHS.Core.Classes.Functors.Functor2 (UVMHS.Core.Monads.RWST r o s)
instance UVMHS.Core.Classes.Functors.Functor2 (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Classes.Functors.Functor2 (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Classes.Monoid.Monoid o => UVMHS.Core.Classes.Functors.Functor2 (UVMHS.Core.Monads.WriterT o)
instance forall k (u :: k) (m :: k -> *). UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.ContT u m)
instance UVMHS.Core.Classes.Functors.Functor m => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.DelayT m)
instance UVMHS.Core.Classes.Functors.Functor m => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.ErrorT e m)
instance UVMHS.Core.Classes.Functors.Functor m => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.FailT m)
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Monads.ID
instance UVMHS.Core.Classes.Functors.Functor GHC.Types.IO
instance UVMHS.Core.Classes.Functors.Functor m => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.NondetT m)
instance UVMHS.Core.Classes.Functors.Functor m => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.RWST r o s m)
instance UVMHS.Core.Classes.Functors.Functor m => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.ReaderT r m)
instance UVMHS.Core.Classes.Functors.Functor m => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.StateT s m)
instance forall k (m :: k -> *). UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.UContT m)
instance UVMHS.Core.Classes.Functors.Functor m => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.Monads.WriterT o m)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.Monads.ID a)
instance (UVMHS.Core.Classes.Lattice.Bot a, UVMHS.Core.Classes.Lattice.Join a) => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Core.Monads.ID a)
instance (UVMHS.Core.Classes.Lattice.Bot a, UVMHS.Core.Classes.Lattice.Join a, UVMHS.Core.Classes.Lattice.Top a, UVMHS.Core.Classes.Lattice.Meet a) => UVMHS.Core.Classes.Lattice.Lattice (UVMHS.Core.Monads.ID a)
instance UVMHS.Core.Effects.LiftCont (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftDelay (UVMHS.Core.Monads.ContT u)
instance UVMHS.Core.Effects.LiftDelay UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftDelay (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftDelay UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftDelay UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftDelay (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftDelay (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Effects.LiftDelay UVMHS.Core.Monads.UContT
instance UVMHS.Core.Effects.LiftDelay (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Effects.LiftError UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftError (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftError UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftError UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftError (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftError (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Effects.LiftError (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Effects.LiftFail UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftFail (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftFail UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftFail UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftFail (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftFail (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Effects.LiftFail (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Effects.LiftIO (UVMHS.Core.Monads.ContT u)
instance UVMHS.Core.Effects.LiftIO UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftIO (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftIO UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftIO UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftIO (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftIO (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Effects.LiftIO UVMHS.Core.Monads.UContT
instance UVMHS.Core.Classes.Monoid.Null o => UVMHS.Core.Effects.LiftIO (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Effects.LiftNondet UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftNondet (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftNondet UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftNondet UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftNondet (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftNondet (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Effects.LiftNondet (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Effects.LiftReader UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftReader (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftReader UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftReader UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftReader (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftReader (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Classes.Monoid.Null o => UVMHS.Core.Effects.LiftReader (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Effects.LiftState UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftState (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftState UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftState UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftState (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftState (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Classes.Monoid.Null o => UVMHS.Core.Effects.LiftState (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Effects.LiftTop UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftTop (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftTop UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftTop UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftTop (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftTop (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Effects.LiftTop (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Effects.LiftWriter UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Effects.LiftWriter (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Effects.LiftWriter UVMHS.Core.Monads.FailT
instance UVMHS.Core.Effects.LiftWriter UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Effects.LiftWriter (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Effects.LiftWriter (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Classes.Monoid.Null o => UVMHS.Core.Effects.LiftWriter (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Core.Monads.ID a)
instance (UVMHS.Core.Classes.Lattice.Top a, UVMHS.Core.Classes.Lattice.Meet a) => UVMHS.Core.Classes.Lattice.MeetLattice (UVMHS.Core.Monads.ID a)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadCont r' m) => UVMHS.Core.Effects.MonadCont r' (UVMHS.Core.Monads.ReaderT r m)
instance UVMHS.Core.Effects.MonadCont r m => UVMHS.Core.Effects.MonadCont r (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadCont (e UVMHS.Core.Init.∨ r) m) => UVMHS.Core.Effects.MonadCont r (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadCont (UVMHS.Core.Init.𝑂 r) m) => UVMHS.Core.Effects.MonadCont r (UVMHS.Core.Monads.FailT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Monoid m, UVMHS.Core.Effects.MonadCont (UVMHS.Core.Init.𝑄 r) m) => UVMHS.Core.Effects.MonadCont r (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadCont (o UVMHS.Core.Init.∧ r) m) => UVMHS.Core.Effects.MonadCont r (UVMHS.Core.Monads.WriterT o m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Effects.MonadCont u (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadCont (s UVMHS.Core.Init.∧ u) m) => UVMHS.Core.Effects.MonadCont u (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.FailT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.RWST r o s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.ReaderT r m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadDelay m) => UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.WriterT o m)
instance forall k (m :: k -> *). UVMHS.Core.Effects.MonadDelay (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.DelayT m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.FailT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.RWST r o s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.ReaderT r m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadError e m) => UVMHS.Core.Effects.MonadError e (UVMHS.Core.Monads.WriterT o m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.ErrorT e m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.FailT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.RWST r o s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.ReaderT r m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadFail m) => UVMHS.Core.Effects.MonadFail (UVMHS.Core.Monads.WriterT o m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.FailT m)
instance UVMHS.Core.Effects.MonadIO GHC.Types.IO
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.RWST r o s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.ReaderT r m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Monoid.Null o, UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadIO m) => UVMHS.Core.Effects.MonadIO (UVMHS.Core.Monads.WriterT o m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.FailT m)
instance UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Monoid m => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.RWST r o s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.ReaderT r m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadNondet m) => UVMHS.Core.Effects.MonadNondet (UVMHS.Core.Monads.WriterT o m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadReader r m) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadReader r m) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadReader r m) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadReader r m) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.FailT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadReader r m) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.RWST r o s m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.ReaderT r m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadReader r m) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadReader r m) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Monoid.Null o, UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadReader r m) => UVMHS.Core.Effects.MonadReader r (UVMHS.Core.Monads.WriterT o m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadState s m) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadState s m) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadState s m) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadState s m) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.FailT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadState s m) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.RWST r o s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadState s m) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.ReaderT r m)
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadState s m) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Monoid.Null o, UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadState s m) => UVMHS.Core.Effects.MonadState s (UVMHS.Core.Monads.WriterT o m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.ContT u m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.FailT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.RWST r o s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.ReaderT r m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadTop m) => UVMHS.Core.Effects.MonadTop (UVMHS.Core.Monads.WriterT o m)
instance UVMHS.Core.Effects.MonadUCont m => UVMHS.Core.Effects.MonadUCont (UVMHS.Core.Monads.DelayT m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Effects.MonadUCont (UVMHS.Core.Monads.UContT m)
instance forall k (u :: k) (m :: k -> *). UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.ContT u m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.DelayT m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.ErrorT e m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.FailT m)
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Core.Monads.ID
instance UVMHS.Core.Classes.Functors.Monad GHC.Types.IO
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Monoid m) => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Monoid.Null o, UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Append o) => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.RWST r o s m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.ReaderT r m)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.StateT s m)
instance forall k (m :: k -> *). UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o) => UVMHS.Core.Classes.Functors.Monad (UVMHS.Core.Monads.WriterT o m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Effects.MonadWriter o m) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.ContT (o UVMHS.Core.Init.∧ r) m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadWriter o m) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.DelayT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadWriter o m) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.ErrorT e m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadWriter o m) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.FailT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadWriter o m) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.RWST r o s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadWriter o m) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.ReaderT r m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Effects.MonadWriter o m) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.StateT s m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Effects.MonadWriter o m) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Monad m, UVMHS.Core.Classes.Monoid.Null o) => UVMHS.Core.Effects.MonadWriter o (UVMHS.Core.Monads.WriterT o m)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Monoid u) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.ContT u m a)
instance (UVMHS.Core.Classes.Constraints.Const UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Constraints.Const UVMHS.Core.Classes.Monoid.Append m) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.DelayT m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Append e, UVMHS.Core.Classes.Monoid.Monoid a) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.ErrorT e m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Monoid a) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.FailT m a)
instance (UVMHS.Core.Classes.Monoid.Null a, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.ID a)
instance UVMHS.Core.Classes.Functors.Monad m => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.MU m)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Classes.Monoid.Monoid s, UVMHS.Core.Classes.Monoid.Monoid a) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.RWST r o s m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Monoid a) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.ReaderT r m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Monoid s, UVMHS.Core.Classes.Monoid.Monoid a) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.StateT s m a)
instance UVMHS.Core.Classes.Constraints.Const UVMHS.Core.Classes.Monoid.Monoid m => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.UContT m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Append m, UVMHS.Core.Classes.Monoid.Monoid o, UVMHS.Core.Classes.Monoid.Monoid a) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Monads.WriterT o m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Monoid.Null u) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.ContT u m a)
instance UVMHS.Core.Classes.Constraints.Const UVMHS.Core.Classes.Monoid.Null m => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.DelayT m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.ErrorT e m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.FailT m a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.ID a)
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.MU m)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Monoid.Null o, UVMHS.Core.Classes.Monoid.Null s, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.RWST r o s m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.ReaderT r m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Monoid.Null s, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.StateT s m a)
instance UVMHS.Core.Classes.Constraints.Const UVMHS.Core.Classes.Monoid.Null m => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.UContT m a)
instance (UVMHS.Core.Classes.Constraints.Func UVMHS.Core.Classes.Monoid.Null m, UVMHS.Core.Classes.Monoid.Null o, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Monads.WriterT o m a)
instance forall k (u :: k) (m :: k -> *). UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.ContT u m)
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.DelayT m)
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.ErrorT e m)
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.FailT m)
instance UVMHS.Core.Classes.Functors.Return UVMHS.Core.Monads.ID
instance UVMHS.Core.Classes.Functors.Return GHC.Types.IO
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.NondetT m)
instance (UVMHS.Core.Classes.Functors.Return m, UVMHS.Core.Classes.Monoid.Null o) => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.RWST r o s m)
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.ReaderT r m)
instance UVMHS.Core.Classes.Functors.Return m => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.StateT s m)
instance forall k (m :: k -> *). UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.UContT m)
instance (UVMHS.Core.Classes.Functors.Return m, UVMHS.Core.Classes.Monoid.Null o) => UVMHS.Core.Classes.Functors.Return (UVMHS.Core.Monads.WriterT o m)
instance UVMHS.Core.Classes.Lattice.Top a => UVMHS.Core.Classes.Lattice.Top (UVMHS.Core.Monads.ID a)
instance UVMHS.Core.Classes.Functors.Transformer (UVMHS.Core.Monads.ContT u)
instance UVMHS.Core.Classes.Functors.Transformer UVMHS.Core.Monads.DelayT
instance UVMHS.Core.Classes.Functors.Transformer (UVMHS.Core.Monads.ErrorT e)
instance UVMHS.Core.Classes.Functors.Transformer UVMHS.Core.Monads.FailT
instance UVMHS.Core.Classes.Functors.Transformer UVMHS.Core.Monads.NondetT
instance UVMHS.Core.Classes.Monoid.Monoid o => UVMHS.Core.Classes.Functors.Transformer (UVMHS.Core.Monads.RWST r o s)
instance UVMHS.Core.Classes.Functors.Transformer (UVMHS.Core.Monads.ReaderT r)
instance UVMHS.Core.Classes.Functors.Transformer (UVMHS.Core.Monads.StateT s)
instance UVMHS.Core.Classes.Functors.Transformer UVMHS.Core.Monads.UContT
instance UVMHS.Core.Classes.Monoid.Null o => UVMHS.Core.Classes.Functors.Transformer (UVMHS.Core.Monads.WriterT o)
instance UVMHS.Core.Monads.RWST r o s UVMHS.Core.Classes.Morphism.⇄⁼ ((UVMHS.Core.Monads.ReaderT r UVMHS.Core.Transformers.⊡ UVMHS.Core.Monads.WriterT o) UVMHS.Core.Transformers.⊡ UVMHS.Core.Monads.StateT s)

module UVMHS.Core.TH
type THLift = Lift :: Type -> Constraint
class MonadQ (m :: Type -> Type)
qio :: MonadQ m => Q a -> m a
thString :: 𝕊 -> Exp
thConNames :: Con -> 𝐿 Name
thTyVarBndrName :: TyVarBndr a -> Name
thSingleClause :: 𝐿 Pat -> Exp -> Clause
thSingleMatch :: Pat -> Exp -> Match
thViewSimpleCon :: Con -> 𝑂 (Name ∧ 𝐿 Type)
thTyConIL :: Info ⌲ Dec
thDataDL :: Dec ⌲ (((((Cxt ∧ Name) ∧ 𝐿 (TyVarBndr BndrVis)) ∧ 𝑂 Kind) ∧ 𝐿 Con) ∧ 𝐿 DerivClause)
thNewtypeDL :: Dec ⌲ (((((Cxt ∧ Name) ∧ 𝐿 (TyVarBndr BndrVis)) ∧ 𝑂 Kind) ∧ Con) ∧ 𝐿 DerivClause)
thViewADT :: Dec -> 𝑂 (((((Cxt ∧ Name) ∧ 𝐿 (TyVarBndr BndrVis)) ∧ 𝑂 Kind) ∧ 𝐿 Con) ∧ 𝐿 DerivClause)
thViewSingleConADT :: Dec -> 𝑂 (((((Cxt ∧ Name) ∧ 𝐿 (TyVarBndr BndrVis)) ∧ 𝑂 Kind) ∧ Con) ∧ 𝐿 DerivClause)
thRecCL :: Con ⌲ (Name ∧ 𝐿 VarStrictType)
thLoc𝕊 :: Q 𝕊
thLoc :: Q (TExp ((𝕊 -> c) -> c))
thExp :: Q (TExp a) -> Q (TExp ((𝕊 -> a -> c) -> c))
thmut :: (Monad (WriterT (𝐼 Dec) Q) => WriterT (𝐼 Dec) Q ()) -> Q [Dec]
thdec :: Q [Dec] -> WriterT (𝐼 Dec) Q ()
instance UVMHS.Core.Classes.DSL.Apply Language.Haskell.TH.Syntax.Exp
instance UVMHS.Core.Classes.DSL.Apply Language.Haskell.TH.Syntax.Type
instance UVMHS.Core.Classes.DSL.Arrow Language.Haskell.TH.Syntax.Type
instance UVMHS.Core.Classes.Functors.Bind Language.Haskell.TH.Syntax.Q
instance UVMHS.Core.Classes.Functors.Functor Language.Haskell.TH.Syntax.Q
instance UVMHS.Core.Effects.MonadIO Language.Haskell.TH.Syntax.Q
instance UVMHS.Core.Classes.Functors.Monad Language.Haskell.TH.Syntax.Q
instance UVMHS.Core.TH.MonadQ Language.Haskell.TH.Syntax.Q
instance UVMHS.Core.Classes.Functors.Return Language.Haskell.TH.Syntax.Q
instance UVMHS.Core.Classes.DSL.Tup Language.Haskell.TH.Syntax.Exp
instance UVMHS.Core.Classes.DSL.Tup Language.Haskell.TH.Syntax.Pat
instance UVMHS.Core.Classes.DSL.Tup Language.Haskell.TH.Syntax.Type

module UVMHS.Core.IO
time :: (() -> a) -> IO (a ∧ TimeD)
throwIO :: IOError -> IO a
trace :: 𝕊 -> ()
failIO :: 𝕊 -> IO a
gc :: IO ()
traceM :: Monad m => 𝕊 -> m ()
shell :: 𝕊 -> IO ((𝔹 ∧ 𝕊) ∧ 𝕊)
catchIO :: IO a -> (IOError -> IO a) -> IO a
err :: 𝕊 -> IO ()
out :: 𝕊 -> IO ()
(↢) :: 𝑅 a -> a -> IO ()
infix 1 ↢
type 𝑅 = IORef
ref :: a -> IO (𝑅 a)
deref :: 𝑅 a -> IO a
io_UNSAFE :: IO a -> a
initUVMHS :: IO ()
owrite :: 𝕊 -> IO ()
outs :: ToIter 𝕊 t => t -> IO ()
oflush :: IO ()
shout :: Show a => a -> IO ()
ewrite :: 𝕊 -> IO ()
eflush :: IO ()
redirectErrToOut :: IO ()
iread :: IO 𝕊
iargs :: IO (𝐿 𝕊)
ilocalArgs :: 𝐿 𝕊 -> IO a -> IO a
abortIOCode :: ℤ64 -> IO a
abortIO :: IO a
exitIO :: IO a
cleanExit :: IO a -> IO a
fread :: ℙ -> IO 𝕊
fwrite :: ℙ -> 𝕊 -> IO ()
fappend :: ℙ -> 𝕊 -> IO ()
fcopy :: ℙ -> ℙ -> IO ()
dfilesAll :: IO (𝐿 ℙ)
dfiles :: IO (𝐿 ℙ)
din :: ℙ -> IO a -> IO a
dtouch :: ℙ -> IO ()
drremove :: ℙ -> IO ()
dcurrent :: IO ℙ
pexists :: ℙ -> IO 𝔹
shellOK :: 𝕊 -> IO 𝕊
shelll :: 𝕊 -> IO ((𝔹 ∧ 𝕊) ∧ 𝕊)
shelllOK :: 𝕊 -> IO 𝕊
rtime :: 𝕊 -> (() -> a) -> IO a
timeIO :: IO a -> IO (a ∧ TimeD)
rtimeIO :: 𝕊 -> IO a -> IO a
profile :: IO a -> IO ((a ∧ 𝔻) ∧ 𝔻)

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Defines the exit codes that a program can return.
data ExitCode

module UVMHS.Core.LensDeriving
makeLensLogic :: Cxt -> Name -> 𝐿 (TyVarBndr BndrVis) -> Name -> Type -> Q (𝐿 Dec)
makeLenses :: Name -> Q [Dec]
makePrismLogic :: Cxt -> Name -> 𝐿 (TyVarBndr BndrVis) -> Name -> 𝐿 Type -> ℕ -> Q (𝐿 Dec)
makePrisms :: Name -> Q [Dec]

module UVMHS.Core.Sized
data 𝐼A a
𝐼A :: ℕ64 -> 𝐼 a -> 𝐼A a
[𝑖aSize] :: 𝐼A a -> ℕ64
[𝑖aIter] :: 𝐼A a -> 𝐼 a
𝑖aSizeL :: 𝐼A a ⟢ ℕ64
𝑖aIterL :: 𝐼A a ⟢ 𝐼 a
class ToIterA a t | t -> a
iterA :: ToIterA a t => t -> 𝐼A a
iterAI :: (ToIter a t, ASized a) => t -> 𝐼A a
data 𝐼C a
𝐼C :: ℕ64 -> 𝐼 a -> 𝐼C a
[𝑖cSize] :: 𝐼C a -> ℕ64
[𝑖cIter] :: 𝐼C a -> 𝐼 a
𝑖cSizeL :: 𝐼C a ⟢ ℕ64
𝑖cIterL :: 𝐼C a ⟢ 𝐼 a
class ToIterC a t | t -> a
iterC :: ToIterC a t => t -> 𝐼C a
iterCI :: ToIter a t => t -> 𝐼C a
data 𝐼AC a
𝐼AC :: ℕ64 -> ℕ64 -> 𝐼 a -> 𝐼AC a
[𝑖acSize] :: 𝐼AC a -> ℕ64
[𝑖acCSize] :: 𝐼AC a -> ℕ64
[𝑖acIter] :: 𝐼AC a -> 𝐼 a
𝑖acSizeL :: 𝐼AC a ⟢ ℕ64
𝑖acCSizeL :: 𝐼AC a ⟢ ℕ64
𝑖acIterL :: 𝐼AC a ⟢ 𝐼 a
class ToIterAC a t | t -> a
iterAC :: ToIterAC a t => t -> 𝐼AC a
iterACI :: (ToIter a t, ASized a) => t -> 𝐼AC a
buildC :: ℕ64 -> a -> (a -> a) -> 𝐼C a
uptoC :: ℕ64 -> 𝐼C ℕ64
stringCS :: (ToIter ℂ t, CSized t) => t -> 𝕊
stringSS :: (ToIter 𝕊 t, ASized t) => t -> 𝕊
mapState𝐼C :: ToIterC a t => s -> (a -> s -> s ∧ b) -> t -> 𝐼C b
withIndexC :: forall t a. ToIterC a t => t -> 𝐼C (ℕ64 ∧ a)
zipWithC :: (ToIterC a t₁, ToIterC b t₂) => (a -> b -> c) -> t₁ -> t₂ -> 𝐼C c
zipC :: (ToIterC a t₁, ToIterC b t₂) => t₁ -> t₂ -> 𝐼C (a ∧ b)
prodWith𝐼C :: (a -> b -> c) -> 𝐼C a -> 𝐼C b -> 𝐼C c
instance UVMHS.Core.Classes.Collections.ASized UVMHS.Core.Init.𝕊
instance (UVMHS.Core.Classes.Collections.ASized a, UVMHS.Core.Classes.Collections.ASized b) => UVMHS.Core.Classes.Collections.ASized (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Core.Classes.Collections.ASized a, UVMHS.Core.Classes.Collections.ASized b) => UVMHS.Core.Classes.Collections.ASized (a UVMHS.Core.Init.∨ b)
instance UVMHS.Core.Classes.Collections.ASized (UVMHS.Core.Sized.𝐼A a)
instance UVMHS.Core.Classes.Collections.ASized (UVMHS.Core.Sized.𝐼AC a)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Sized.𝐼A a)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Sized.𝐼AC a)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Sized.𝐼C a)
instance UVMHS.Core.Classes.Collections.CSized UVMHS.Core.Init.𝕊
instance UVMHS.Core.Classes.Collections.CSized (UVMHS.Core.Sized.𝐼AC a)
instance UVMHS.Core.Classes.Collections.CSized (UVMHS.Core.Sized.𝐼C a)
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Sized.𝐼C
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Sized.𝐼C
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Sized.𝐼A a)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Sized.𝐼AC a)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Sized.𝐼C a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Sized.𝐼A a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Sized.𝐼AC a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Sized.𝐼C a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Sized.𝐼A a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Sized.𝐼AC a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Sized.𝐼C a)
instance UVMHS.Core.Classes.Collections.ASized a => UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Sized.𝐼A a)
instance UVMHS.Core.Classes.Collections.ASized a => UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Sized.𝐼AC a)
instance UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Sized.𝐼C a)
instance UVMHS.Core.Sized.ToIterAC a (UVMHS.Core.Sized.𝐼AC a)
instance UVMHS.Core.Sized.ToIterA a (UVMHS.Core.Sized.𝐼A a)
instance UVMHS.Core.Sized.ToIterC a (UVMHS.Core.Sized.𝐼C a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Sized.𝐼A a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Sized.𝐼AC a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Sized.𝐼C a)

module UVMHS.Core.Vector
newtype 𝕍 a
𝕍 :: Vector a -> 𝕍 a
[un𝕍] :: 𝕍 a -> Vector a
iter𝕍 :: 𝕍 a -> 𝐼 a
show𝕍 :: Show a => 𝕍 a -> 𝕊
idx𝕍 :: ℕ64 -> 𝕍 a -> 𝑂 a
map𝕍 :: (a -> b) -> 𝕍 a -> 𝕍 b
mapM𝕍 :: Monad m => (a -> m b) -> 𝕍 a -> m (𝕍 b)
csize𝕍 :: 𝕍 a -> ℕ64
single𝕍 :: a -> 𝕍 a
null𝕍 :: 𝕍 a
append𝕍 :: 𝕍 a -> 𝕍 a -> 𝕍 a
vec :: ToIter a t => t -> 𝕍 a
vecC :: ToIterC a t => t -> 𝕍 a
vecF :: ℕ64 -> (ℕ64 -> a) -> 𝕍 a
vecDΩ :: (ℕ64 ⇰ a) -> 𝕍 a
idx𝕍Ω :: ℕ64 -> 𝕍 a -> a
idx𝕍Ω_UNSAFE :: ℕ64 -> 𝕍 a -> a
nulls𝕍 :: Null a => ℕ64 -> 𝕍 a
newtype 𝕍Mut a
𝕍Mut :: IOVector a -> 𝕍Mut a
[un𝕍Mut] :: 𝕍Mut a -> IOVector a
vecIMut :: ToIter a t => t -> IO (𝕍Mut a)
vecVMut :: 𝕍 a -> IO (𝕍Mut a)
idx𝕍Mut :: ℕ64 -> 𝕍Mut a -> IO a
set𝕍Mut :: ℕ64 -> a -> 𝕍Mut a -> IO ()
eachI𝕍Mut :: (ℕ64 -> a -> IO ()) -> 𝕍Mut a -> IO ()
each𝕍Mut :: (a -> IO ()) -> 𝕍Mut a -> IO ()
values𝕍Mut :: 𝕍Mut a -> IO (𝕍 a)
grow𝕍Mut :: ℕ64 -> 𝕍Mut a -> IO (𝕍Mut a)
newtype 𝕌 a
𝕌 :: Vector a -> 𝕌 a
[un𝕌] :: 𝕌 a -> Vector a
iter𝕌 :: Storable a => 𝕌 a -> 𝐼 a
show𝕌 :: (Storable a, Show a) => 𝕌 a -> 𝕊
idx𝕌 :: Storable a => ℕ64 -> 𝕌 a -> 𝑂 a
csize𝕌 :: Storable a => 𝕌 a -> ℕ64
zipWith𝕌 :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> 𝕌 a -> 𝕌 b -> 𝕌 c
map𝕌 :: (Storable a, Storable b) => (a -> b) -> 𝕌 a -> 𝕌 b
uvec :: (Storable a, ToIter a t) => t -> 𝕌 a
uvecC :: (Storable a, ToIterC a t) => t -> 𝕌 a
uvecF :: Storable a => ℕ64 -> (ℕ64 -> a) -> 𝕌 a
uvecDΩ :: Storable a => (ℕ64 ⇰ a) -> 𝕌 a
idx𝕌Ω :: Storable a => ℕ64 -> 𝕌 a -> a
idx𝕌Ω_UNSAFE :: Storable a => ℕ64 -> 𝕌 a -> a
mapM𝕌 :: (Monad m, Storable a, Storable b) => (a -> m b) -> 𝕌 a -> m (𝕌 b)
null𝕌 :: (Storable a, Null a) => ℕ64 -> 𝕌 a
zipWithOn𝕌 :: (Storable a, Storable b, Storable c) => 𝕌 a -> 𝕌 b -> (a -> b -> c) -> 𝕌 c
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.Vector.𝕍 a)
instance Foreign.Storable.Storable a => UVMHS.Core.Classes.Collections.CSized (UVMHS.Core.Vector.𝕌 a)
instance UVMHS.Core.Classes.Collections.CSized (UVMHS.Core.Vector.𝕍 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Arithmetic.DivMod a) => UVMHS.Core.Classes.Arithmetic.DivMod (UVMHS.Core.Vector.𝕌 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Arithmetic.Divide a) => UVMHS.Core.Classes.Arithmetic.Divide (UVMHS.Core.Vector.𝕌 a)
instance (Foreign.Storable.Storable a, GHC.Classes.Eq a) => GHC.Classes.Eq (UVMHS.Core.Vector.𝕌 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.Vector.𝕍 a)
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Core.Vector.𝕍
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.Vector.𝕍
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Lattice.Join a) => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.Vector.𝕌 a)
instance Foreign.Storable.Storable a => UVMHS.Core.Classes.Collections.Lookup UVMHS.Core.Init.ℕ64 a (UVMHS.Core.Vector.𝕌 a)
instance UVMHS.Core.Classes.Collections.Lookup UVMHS.Core.Init.ℕ64 a (UVMHS.Core.Vector.𝕍 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Lattice.Meet a) => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Core.Vector.𝕌 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Arithmetic.Minus a) => UVMHS.Core.Classes.Arithmetic.Minus (UVMHS.Core.Vector.𝕌 a)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.Vector.𝕍 a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.Vector.𝕍 a)
instance (Foreign.Storable.Storable a, GHC.Classes.Ord a) => GHC.Classes.Ord (UVMHS.Core.Vector.𝕌 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.Vector.𝕍 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Arithmetic.Plus a) => UVMHS.Core.Classes.Arithmetic.Plus (UVMHS.Core.Vector.𝕌 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Arithmetic.Pon a) => UVMHS.Core.Classes.Arithmetic.Pon (UVMHS.Core.Vector.𝕌 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Arithmetic.Pow a) => UVMHS.Core.Classes.Arithmetic.Pow (UVMHS.Core.Vector.𝕌 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Arithmetic.Root a) => UVMHS.Core.Classes.Arithmetic.Root (UVMHS.Core.Vector.𝕌 a)
instance (Foreign.Storable.Storable a, GHC.Show.Show a) => GHC.Show.Show (UVMHS.Core.Vector.𝕌 a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.Vector.𝕍 a)
instance UVMHS.Core.Classes.Collections.Single a (UVMHS.Core.Vector.𝕍 a)
instance (Foreign.Storable.Storable a, UVMHS.Core.Classes.Arithmetic.Times a) => UVMHS.Core.Classes.Arithmetic.Times (UVMHS.Core.Vector.𝕌 a)
instance Foreign.Storable.Storable a => UVMHS.Core.Sized.ToIterC a (UVMHS.Core.Vector.𝕌 a)
instance UVMHS.Core.Sized.ToIterC a (UVMHS.Core.Vector.𝕍 a)
instance Foreign.Storable.Storable a => UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Vector.𝕌 a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.Vector.𝕍 a)

module UVMHS.Core.VectorSparse
data 𝑉 a
𝑉 :: IntMap a -> 𝑉 a
[un𝑉] :: 𝑉 a -> IntMap a
lookup𝑉 :: 𝑉 a -> ℤ64 -> 𝑂 a
single𝑉 :: (ℤ64 ∧ a) -> 𝑉 a
subDictBy𝑉 :: (a -> a -> 𝔹) -> 𝑉 a -> 𝑉 a -> 𝔹
wø :: 𝑉 a
unionWith𝑉 :: (a -> a -> a) -> 𝑉 a -> 𝑉 a -> 𝑉 a
(↦♮) :: ℤ64 -> a -> 𝑉 a
(⋵♮) :: ℤ64 -> 𝑉 a -> 𝔹
(⩌♮) :: 𝑉 a -> 𝑉 a -> 𝑉 a
(⩍♮) :: 𝑉 a -> 𝑉 a -> 𝑉 a
delete𝑉 :: ℤ64 -> 𝑉 a -> 𝑉 a
size𝑉 :: 𝑉 a -> ℕ
(⊎♮) :: Additive a => 𝑉 a -> 𝑉 a -> 𝑉 a
unionsWith𝑉 :: ToIter (𝑉 a) t => (a -> a -> a) -> t -> 𝑉 a
interWith𝑉 :: (a -> b -> c) -> 𝑉 a -> 𝑉 b -> 𝑉 c
minView𝑉 :: 𝑉 a -> 𝑂 ((ℤ64 ∧ a) ∧ 𝑉 a)
maxView𝑉 :: 𝑉 a -> 𝑂 ((ℤ64 ∧ a) ∧ 𝑉 a)
minKey𝑉 :: 𝑉 a -> 𝑂 ℤ64
maxKey𝑉 :: 𝑉 a -> 𝑂 ℤ64
view𝑉 :: ℤ64 -> 𝑉 a -> 𝑂 (a ∧ 𝑉 a)
without𝑉 :: 𝑃 ℤ64 -> 𝑉 a -> 𝑉 a
restrict𝑉 :: 𝑃 ℤ64 -> 𝑉 a -> 𝑉 a
keys𝑉 :: 𝑉 a -> 𝐼 ℤ64
values𝑉 :: 𝑉 a -> 𝐼 a
map𝑉 :: (a -> b) -> 𝑉 a -> 𝑉 b
mapK𝑉 :: (ℤ64 -> a -> b) -> 𝑉 a -> 𝑉 b
iter𝑉 :: 𝑉 a -> 𝐼 (ℤ64 ∧ a)
spvec𝐼 :: 𝐼 (ℤ64 ∧ a) -> 𝑉 a
spvec :: ToIter (𝑉 a) t => t -> 𝑉 a
assoc𝑉 :: ToIter (ℤ64 ∧ a) t => t -> 𝑉 a
join𝑉 :: (Ord a, Ord b) => 𝑉 (𝑃 a) -> 𝑉 (𝑃 b) -> 𝑉 (𝑃 (a ∧ b))
instance UVMHS.Core.Classes.Arithmetic.Plus a => UVMHS.Core.Classes.Arithmetic.Additive (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Lattice.Bot (UVMHS.Core.VectorSparse.𝑉 a)
instance (UVMHS.Core.Classes.Monoid.Append a, UVMHS.Core.Classes.Monoid.Cross a) => UVMHS.Core.Classes.Monoid.Cross (UVMHS.Core.VectorSparse.𝑉 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Core.VectorSparse.𝑉
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Collections.Lookup UVMHS.Core.Init.ℤ64 a (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.MeetLattice (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Arithmetic.Multiplicative a => UVMHS.Core.Classes.Arithmetic.Multiplicative (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Arithmetic.Zero a => UVMHS.Core.Classes.Arithmetic.One (UVMHS.Core.VectorSparse.𝑉 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Lattice.POrd a => UVMHS.Core.Classes.Lattice.POrd (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Arithmetic.Plus a => UVMHS.Core.Classes.Arithmetic.Plus (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Monoid.Prodoid a => UVMHS.Core.Classes.Monoid.Prodoid (UVMHS.Core.VectorSparse.𝑉 a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Collections.Single (UVMHS.Core.Init.ℤ64 UVMHS.Core.Init.∧ a) (UVMHS.Core.VectorSparse.𝑉 a)
instance (UVMHS.Core.Classes.Arithmetic.Plus a, UVMHS.Core.Classes.Arithmetic.Times a) => UVMHS.Core.Classes.Arithmetic.Times (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Collections.ToIter (UVMHS.Core.Init.ℤ64 UVMHS.Core.Init.∧ a) (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Lattice.Top (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Unit (UVMHS.Core.VectorSparse.𝑉 a)
instance UVMHS.Core.Classes.Arithmetic.Zero (UVMHS.Core.VectorSparse.𝑉 a)

module UVMHS.Core.VectorStatic
(⋅) :: forall (n :: 𝐍) a. (𝒩 n, Additive a, Times a) => 𝕍S n a -> 𝕍S n a -> a
infixl 6 ⋅
(✖) :: forall (m :: 𝐍) (n :: 𝐍) (o :: 𝐍) a. (𝒩 m, 𝒩 n, 𝒩 o, Additive a, Times a) => 𝕍S m (𝕍S o a) -> 𝕍S n (𝕍S o a) -> 𝕍S m (𝕍S n a)
infixl 6 ✖
newtype 𝕍SV (n :: 𝐍) a
𝕍SV :: (𝕀64 n -> a) -> 𝕍SV (n :: 𝐍) a
[un𝕍SV] :: 𝕍SV (n :: 𝐍) a -> 𝕀64 n -> a
newtype 𝕍S (n :: k) a
𝕍S_UNSAFE :: Vector a -> 𝕍S (n :: k) a
[un𝕍S] :: 𝕍S (n :: k) a -> Vector a
iter𝕍S :: forall {k} (n :: k) a. 𝕍S n a -> 𝐼 a
show𝕍S :: forall {k} a (n :: k). Show a => 𝕍S n a -> 𝕊
idx𝕍S :: forall (n :: 𝐍) a. 𝕀64 n -> 𝕍S n a -> a
idxChecked𝕍S :: forall {k} (n :: k) a. ℕ64 -> 𝕍S n a -> 𝑂 a
null𝕍S :: forall (n :: 𝐍) a. (𝒩 n, Null a) => ℕ64S n -> 𝕍S n a
map𝕍S :: forall (n :: 𝐍) a b. 𝒩 n => (a -> b) -> 𝕍S n a -> 𝕍S n b
const𝕍S :: forall (n :: 𝐍) a. 𝒩 n => ℕ64S n -> a -> 𝕍S n a
svecF :: forall (n :: 𝐍) a. 𝒩 n => ℕ64S n -> (𝕀64 n -> a) -> 𝕍S n a
svec :: forall (n :: 𝐍) a. 𝒩 n => 𝐼S n a -> 𝕍S n a
iter𝕍SS :: forall (n :: 𝐍) a. 𝕍S n a -> 𝐼S n a
svirt :: forall (n :: 𝐍) a. 𝒩 n => 𝕍S n a -> 𝕍SV n a
svirt2 :: forall (m :: 𝐍) (n :: 𝐍) a. (𝒩 m, 𝒩 n) => 𝕍S m (𝕍S n a) -> 𝕍SV m (𝕍SV n a)
sconc :: forall (n :: 𝐍) a. 𝒩 n => ℕ64S n -> 𝕍SV n a -> 𝕍S n a
sconc2 :: forall (m :: 𝐍) (n :: 𝐍) a. (𝒩 m, 𝒩 n) => ℕ64S m -> ℕ64S n -> 𝕍SV m (𝕍SV n a) -> 𝕍S m (𝕍S n a)
𝐭 :: forall (m :: 𝐍) (n :: 𝐍) a. (𝒩 m, 𝒩 n) => 𝕍S m (𝕍S n a) -> 𝕍S n (𝕍S m a)
d𝕍 :: 𝕍 a -> (forall (n :: 𝐍). 𝒩64 n => 𝕍S n a -> b) -> b
newtype 𝕌S (n :: k) a
𝕌S_UNSAFE :: Vector a -> 𝕌S (n :: k) a
[un𝕌S] :: 𝕌S (n :: k) a -> Vector a
iter𝕌S :: forall {k} a (n :: k). Storable a => 𝕌S n a -> 𝐼 a
show𝕌S :: forall {k} a (n :: k). (Storable a, Show a) => 𝕌S n a -> 𝕊
idx𝕌S :: forall a (n :: 𝐍). Storable a => 𝕀64 n -> 𝕌S n a -> a
idxChecked𝕌S :: forall {k} a (n :: k). Storable a => ℕ64 -> 𝕌S n a -> 𝑂 a
null𝕌S :: forall (n :: 𝐍) a. (𝒩 n, Storable a, Null a) => ℕ64S n -> 𝕌S n a
suvec :: forall (n :: 𝐍) a. (𝒩 n, Storable a) => 𝐼S n a -> 𝕌S n a
suvecF :: forall (n :: 𝐍) a. (𝒩 n, Storable a) => ℕ64S n -> (𝕀64 n -> a) -> 𝕌S n a
iter𝕌SS :: forall a (n :: 𝐍). Storable a => 𝕌S n a -> 𝐼S n a
map𝕌S :: forall (n :: 𝐍) a b. (𝒩 n, Storable a, Storable b) => (a -> b) -> 𝕌S n a -> 𝕌S n b
d𝕌 :: Storable a => 𝕌 a -> (forall (n :: 𝐍). 𝒩64 n => 𝕌S n a -> b) -> b
data 𝕄S (ns :: [𝐍]) a
[Nil𝕄S] :: forall a. a -> 𝕄S ('[] :: [𝐍]) a
[Cons𝕄S] :: forall (n :: 𝐍) (ns1 :: [𝐍]) a. 𝕍S n (𝕄S ns1 a) -> 𝕄S (n ': ns1) a
zero𝕄S :: forall (ns :: [𝐍]) a. (AllC 𝒩 ns, Zero a) => Spine ns -> 𝕄S ns a
mapUnder𝕄S :: forall (ns :: [𝐍]) (ms₁ :: [𝐍]) a (ms₂ :: [𝐍]) b. AllC 𝒩 ns => Spine ns -> (𝕄S ms₁ a -> 𝕄S ms₂ b) -> 𝕄S (ns ⧺ ms₁) a -> 𝕄S (ns ⧺ ms₂) b
instance Foreign.Storable.Storable a => UVMHS.Core.Classes.Collections.Access (UVMHS.Core.Static.𝕀64 n) a (UVMHS.Core.VectorStatic.𝕌S n a)
instance UVMHS.Core.Classes.Collections.Access (UVMHS.Core.Static.𝕀64 n) a (UVMHS.Core.VectorStatic.𝕍S n a)
instance UVMHS.Core.Classes.Collections.Access (UVMHS.Core.Static.𝕀64 n) a (UVMHS.Core.VectorStatic.𝕍SV n a)
instance forall k (n :: k) a. (Foreign.Storable.Storable a, GHC.Classes.Eq a) => GHC.Classes.Eq (UVMHS.Core.VectorStatic.𝕌S n a)
instance forall k (n :: k) a. GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Core.VectorStatic.𝕍S n a)
instance UVMHS.Core.Static.𝒩 n => UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.VectorStatic.𝕍S n)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Core.VectorStatic.𝕍SV n)
instance forall k a (n :: k). Foreign.Storable.Storable a => UVMHS.Core.Classes.Collections.Lookup UVMHS.Core.Init.ℕ64 a (UVMHS.Core.VectorStatic.𝕌S n a)
instance forall k a (n :: k). UVMHS.Core.Classes.Collections.Lookup UVMHS.Core.Init.ℕ64 a (UVMHS.Core.VectorStatic.𝕍S n a)
instance (UVMHS.Core.Static.𝒩 n, Foreign.Storable.Storable a, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.VectorStatic.𝕌S n a)
instance (UVMHS.Core.Static.𝒩 n, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Core.VectorStatic.𝕍S n a)
instance (UVMHS.Core.Static.𝒩 n, UVMHS.Core.Classes.Arithmetic.One a) => UVMHS.Core.Classes.Arithmetic.One (UVMHS.Core.VectorStatic.𝕍S n a)
instance forall k (n :: k) a. (Foreign.Storable.Storable a, GHC.Classes.Ord a) => GHC.Classes.Ord (UVMHS.Core.VectorStatic.𝕌S n a)
instance forall k (n :: k) a. GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Core.VectorStatic.𝕍S n a)
instance (UVMHS.Core.Static.AllC UVMHS.Core.Static.𝒩 ns, UVMHS.Core.Classes.Arithmetic.Plus a) => UVMHS.Core.Classes.Arithmetic.Plus (UVMHS.Core.VectorStatic.𝕄S ns a)
instance (UVMHS.Core.Static.𝒩 n, UVMHS.Core.Classes.Arithmetic.Plus a) => UVMHS.Core.Classes.Arithmetic.Plus (UVMHS.Core.VectorStatic.𝕍S n a)
instance forall k a (n :: k). (Foreign.Storable.Storable a, GHC.Show.Show a) => GHC.Show.Show (UVMHS.Core.VectorStatic.𝕌S n a)
instance forall k a (n :: k). GHC.Show.Show a => GHC.Show.Show (UVMHS.Core.VectorStatic.𝕍S n a)
instance (UVMHS.Core.Static.AllC UVMHS.Core.Static.𝒩 ns, UVMHS.Core.Classes.Arithmetic.Times a) => UVMHS.Core.Classes.Arithmetic.Times (UVMHS.Core.VectorStatic.𝕄S ns a)
instance (UVMHS.Core.Static.𝒩 n, UVMHS.Core.Classes.Arithmetic.Times a) => UVMHS.Core.Classes.Arithmetic.Times (UVMHS.Core.VectorStatic.𝕍S n a)
instance forall k a (n :: k). Foreign.Storable.Storable a => UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.VectorStatic.𝕌S n a)
instance forall k a (n :: k). UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Core.VectorStatic.𝕍S n a)
instance (UVMHS.Core.Static.HasSpine ns, UVMHS.Core.Static.AllC UVMHS.Core.Static.𝒩 ns, UVMHS.Core.Classes.Arithmetic.Zero a) => UVMHS.Core.Classes.Arithmetic.Zero (UVMHS.Core.VectorStatic.𝕄S ns a)
instance (UVMHS.Core.Static.𝒩 n, UVMHS.Core.Classes.Arithmetic.Zero a) => UVMHS.Core.Classes.Arithmetic.Zero (UVMHS.Core.VectorStatic.𝕍S n a)

module UVMHS.Core

module UVMHS.Lib.GTree

module UVMHS.Lib.Graph

-- | A <a>Graph</a> has node elements <tt>a</tt>, and is just a relation
--   between nodes.
--   
--   Notation:
--   
--   kvss : Graph a
--   
--   (same as general dictionaries)
type Graph a = a ⇰ 𝑃 a

-- | Property:
--   
--   (v ↦ ks) ∈ graph-transpose(kvss) ⟺ ∀ (k ↦ vs) ∈ kvss. k ∈ ks ⟺ v ∈ vs
graphTranspose :: Ord a => Graph a -> Graph a

-- | Run the Kosaraju algorithm, which computes strongly connected
--   components. The algorithm computes a canonical node for each strongly
--   connected component, and maps each node to the canonical node for
--   strongly connected component in which it lives.
--   
--   Definition:
--   
--   strongly-connected ∈ ℘(Graph) strongly-connected(kvss) ≜ ∀ k₁,k₂ ∈
--   nodes(kvss). ∃ path(k₁,k₂) strongly-connected-components ∈ ℘(℘(Graph))
--   strongly-connected-components(kvsss) ≜ (∀ kvss ∈ kvsss.
--   strongly-connected(kvss)) ∧ (∀ kvss₁,kvss₂ ∈ kvsss.
--   ¬strongly-connected(kvss₁ ∪kvss₂))
--   
--   Property:
--   
--   ∀ kvss. strongly-connected-components( values( graph-transpose( { k ↦
--   {v} | (k ↦ v) ∈ kosaraju(kvss) }
kosaraju :: Ord a => Graph a -> a ⇰ a

-- | In the context of this function, we treat the element <tt>a</tt> like
--   variables that have a definition/use structure. The first argument
--   <tt>deps</tt> encodes dependencies from definitions of things to uses
--   of things.
--   
--   From a dependency relation, compute two elements: 1. The strongly
--   connected components for the dependency relation, represented as a map
--   from variables to a canonical SCC elements for its dependency group 2.
--   A map from canonical SCC elements to: (a). All variables in its
--   dependency group (i.e., the inverse of (1)) (b). All dependencies of
--   all variables in the dependnecy group
--   
--   <ol>
--   <li>is computed using <a>kosaraju</a>, but with an additional bit of
--   information in the node representation that encodes def/use
--   information, following these two semantic ideas: - *Use* of any
--   variable <tt>x</tt> depends on the *definition* of that variable
--   <tt>x</tt> - If `{x ↦ y}` appears in <tt>deps</tt>, this means that
--   *definition* of variable <tt>x</tt> depends on *use* of variable
--   <tt>y</tt>.</li>
--   </ol>
sccGroups :: Ord a => (a ⇰ 𝑃 a) -> (a ⇰ a) ∧ (a ⇰ (𝑃 a ∧ 𝑃 a))

-- | Compute strongly connected components following a dependency map, and
--   process each component with a monadic action.
--   
--   sccEachGroupM xs deps f
--   
--   <ul>
--   <li><tt>xs</tt> represents a desired ordering in which to process
--   variables (e.g., if definitions <tt>x</tt> and <tt>y</tt> do not
--   depend on each other, and <tt>x</tt> comes before <tt>y</tt> in
--   <tt>xs</tt>, then call <tt>f</tt> on the SCC group for <tt>x</tt>
--   before doing the same for <tt>y</tt>.)</li>
--   <li><tt>deps</tt> represents dependency information. See
--   <a>sccGroups</a> for how these are processed.</li>
--   <li>`f b xs′` represents an action to perform on each SCC group. If
--   the group is non-recursive, then <tt>b</tt> will be <a>False</a> and
--   `|xs′| = 1`. If the group is recursive, then <tt>b</tt> will be
--   <a>True</a> and `|xs′| ≥ 1`.</li>
--   </ul>
sccEachGroupM :: forall a b m. (Ord a, Monad m) => 𝐼 a -> (a ⇰ 𝑃 a) -> (𝔹 -> 𝐼 a -> m (𝐼 b)) -> m (𝐼 b)

-- | Similar to <a>sccEachGroupM</a>, but specialized to the identity
--   monad.
sccEachGroup :: Ord a => 𝐼 a -> (a ⇰ 𝑃 a) -> (𝔹 -> 𝐼 a -> 𝐼 b) -> 𝐼 b

module UVMHS.Lib.Neural

module UVMHS.Lib.Options
option :: 𝐿 ℂ -> 𝐿 𝕊 -> ArgDescr a -> 𝕊 -> OptDescr a
noArg :: a -> ArgDescr a
reqArg :: (𝕊 -> a) -> 𝕊 -> ArgDescr a
optArg :: (𝑂 𝕊 -> a) -> 𝕊 -> ArgDescr a
optUsageInfo :: 𝕊 -> 𝐿 (OptDescr a) -> 𝕊
parseOptions :: 𝐿 (OptDescr a) -> 𝐿 𝕊 -> (𝐿 a ∧ 𝐿 𝕊) ∧ 𝐿 𝕊

-- | Describes whether an option takes an argument or not, and if so how
--   the argument is injected into a value of type <tt>a</tt>.
data ArgDescr a

-- | Each <a>OptDescr</a> describes a single option.
--   
--   The arguments to <a>Option</a> are:
--   
--   <ul>
--   <li>list of short option characters</li>
--   <li>list of long option strings (without "--")</li>
--   <li>argument descriptor</li>
--   <li>explanation of option for user</li>
--   </ul>
data OptDescr a

module UVMHS.Lib.Pipeline

-- | A <a>Pipeline</a> is essentially just a list of annotated monadic
--   functions. Its definitions uses a GADT to capture chaining `a → m b`
--   with `b → m c` as a <a>Pipeline</a> from <tt>a</tt> to <tt>c</tt>, and
--   where <tt>b</tt> ends up existentially quantified in the chain.
--   
--   A <a>Pipeline</a> 𝒸 m i a b` imposes constraint <tt>𝒸</tt> on all
--   intermediate result types of monadic computations in the list,
--   annotates each function in the list with a value of type <tt>i</tt>,
--   and ultimately consumes a value of type <tt>a</tt> and produces a
--   value of type `m b`.
data Pipeline (𝒸 :: Type -> Constraint) (m :: Type -> Type) i a b
[UnitPipeline] :: forall (𝒸 :: Type -> Constraint) (m :: Type -> Type) i a. Pipeline 𝒸 m i a a
[StepPipeline] :: forall (𝒸 :: Type -> Constraint) b1 (m :: Type -> Type) i a b. 𝒸 b1 => Pipeline 𝒸 m i a b1 -> i -> (b1 -> m b) -> Pipeline 𝒸 m i a b
runPipeline :: forall m (𝒸 :: Type -> Constraint) i a b. Monad m => Pipeline 𝒸 m i a b -> a -> m b

module UVMHS.Lib.Pretty.Color
data Color3Bit
DefaultColor :: Color3Bit
Black :: Color3Bit
Red :: Color3Bit
Green :: Color3Bit
Yellow :: Color3Bit
Blue :: Color3Bit
Magenta :: Color3Bit
Cyan :: Color3Bit
GrayLight :: Color3Bit
GrayDark :: Color3Bit
RedLight :: Color3Bit
GreenLight :: Color3Bit
YellowLight :: Color3Bit
BlueLight :: Color3Bit
PinkLight :: Color3Bit
TealLight :: Color3Bit
White :: Color3Bit
data Color
Color :: Color3Bit -> Color
Color8 :: ℕ8 -> Color
Color24 :: ℕ8 -> ℕ8 -> ℕ8 -> Color
defaultColor :: Color
black :: Color
red :: Color
green :: Color
yellow :: Color
blue :: Color
pink :: Color
teal :: Color
grayLight :: Color
grayDark :: Color
redLight :: Color
greenLight :: Color
yellowLight :: Color
blueLight :: Color
pinkLight :: Color
tealLight :: Color
white :: Color
highlight :: Color
altBlack :: Color
altWhite :: Color
altNight :: Color
altNightLight :: Color
altRed :: Color
altRedLight :: Color
altGreen :: Color
altGreenLight :: Color
altOrange :: Color
altOrangeLight :: Color
altBlue :: Color
altBlueLight :: Color
altPurple :: Color
altPurpleLight :: Color
altTeal :: Color
altTealLight :: Color
altGray :: Color
altGrayLight :: Color
allColors :: 𝐿 (𝕊 ∧ Color)
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Color.Color
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Color.Color3Bit
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Color.Color
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Color.Color3Bit
instance GHC.Show.Show UVMHS.Lib.Pretty.Color.Color
instance GHC.Show.Show UVMHS.Lib.Pretty.Color.Color3Bit

module UVMHS.Lib.Pretty.Annotation
data Format
FG :: Color -> Format
NOFG :: Format
BG :: Color -> Format
NOBG :: Format
UL :: Format
NOUL :: Format
BD :: Format
NOBD :: Format
IT :: Format
NOIT :: Format
data Formats
Formats :: 𝑂 Color -> 𝑂 Color -> 𝑂 𝔹 -> 𝑂 𝔹 -> 𝑂 𝔹 -> Formats
[fgFormats] :: Formats -> 𝑂 Color
[bgFormats] :: Formats -> 𝑂 Color
[ulFormats] :: Formats -> 𝑂 𝔹
[bdFormats] :: Formats -> 𝑂 𝔹
[itFormats] :: Formats -> 𝑂 𝔹
format :: Format -> Formats
formats :: ToIter Format t => t -> Formats
override :: 𝐿 Format
data Annotation
Annotation :: Formats -> 𝑂 (ℂ ∧ Formats) -> Annotation
[annotationFormats] :: Annotation -> Formats
[annotationUndertag] :: Annotation -> 𝑂 (ℂ ∧ Formats)
formatAnnotation :: Formats -> Annotation
undertagAnnotation :: ℂ -> Formats -> Annotation
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.Annotation.Annotation
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.Annotation.Formats
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Annotation.Annotation
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Annotation.Format
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Annotation.Formats
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.Annotation.Annotation
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.Annotation.Formats
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.Annotation.Annotation
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.Annotation.Formats
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Annotation.Annotation
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Annotation.Format
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Annotation.Formats
instance GHC.Show.Show UVMHS.Lib.Pretty.Annotation.Annotation
instance GHC.Show.Show UVMHS.Lib.Pretty.Annotation.Format
instance GHC.Show.Show UVMHS.Lib.Pretty.Annotation.Formats

module UVMHS.Lib.Pretty.Levels
pDEF :: ℕ64
pLET :: ℕ64
pSEP :: ℕ64
pASC :: ℕ64
pARR :: ℕ64
pOR :: ℕ64
pAND :: ℕ64
pCMP :: ℕ64
pCONS :: ℕ64
pBWOR :: ℕ64
pBWAND :: ℕ64
pBSHFT :: ℕ64
pPLUS :: ℕ64
pTIMES :: ℕ64
pNEG :: ℕ64
pPOW :: ℕ64
pFAC :: ℕ64
pAPP :: ℕ64
pREF :: ℕ64
pIDX :: ℕ64
pTOP :: ℕ64

module UVMHS.Lib.Pretty.Shape
data ShapeM
ShapeM :: {-# UNPACK #-}ℕ64 -> {-# UNPACK #-}ℕ64 -> {-# UNPACK #-}ℕ64 -> {-# UNPACK #-}ℕ64 -> ShapeM
[shapeMFirstLength] :: ShapeM -> {-# UNPACK #-}ℕ64
[shapeMMidMaxLength] :: ShapeM -> {-# UNPACK #-}ℕ64
[shapeMLastLength] :: ShapeM -> {-# UNPACK #-}ℕ64
[shapeMNewlines] :: ShapeM -> {-# UNPACK #-}ℕ64
shapeMFirstLengthL :: ShapeM ⟢ ℕ64
shapeMMidMaxLengthL :: ShapeM ⟢ ℕ64
shapeMLastLengthL :: ShapeM ⟢ ℕ64
shapeMNewlinesL :: ShapeM ⟢ ℕ64
data Shape
SingleLine :: {-# UNPACK #-}ℕ64 -> Shape
MultiLine :: {-# UNPACK #-}ShapeM -> Shape
singleLineL :: Shape ⌲ ℕ64
multiLineL :: Shape ⌲ ShapeM
shapeFirstLength :: Shape -> ℕ64
shapeLastLength :: Shape -> ℕ64
newlineShapeM :: ShapeM
newlineShape :: Shape
boxShape :: ℕ64 -> ℕ64 -> Shape
shapeWidth :: Shape -> ℕ64
shapeNewlines :: Shape -> ℕ64
data ShapeA
ShapeA :: 𝔹 -> Shape -> ShapeA
[shapeIAligned] :: ShapeA -> 𝔹
[shapeIShape] :: ShapeA -> Shape
shapeIAlignedL :: ShapeA ⟢ 𝔹
shapeIShapeL :: ShapeA ⟢ Shape
alignShapeA :: ShapeA -> ShapeA
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.Shape.Shape
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.Shape.ShapeA
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Lib.Pretty.Shape.Shape
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Shape.Shape
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Shape.ShapeA
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Shape.ShapeM
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Lib.Pretty.Shape.Shape
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.Shape.Shape
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.Shape.ShapeA
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.Shape.Shape
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.Shape.ShapeA
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Shape.Shape
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Shape.ShapeA
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Shape.ShapeM
instance GHC.Show.Show UVMHS.Lib.Pretty.Shape.Shape
instance GHC.Show.Show UVMHS.Lib.Pretty.Shape.ShapeA
instance GHC.Show.Show UVMHS.Lib.Pretty.Shape.ShapeM

module UVMHS.Lib.Rand
class MonadRand (m :: Type -> Type)
rng :: MonadRand m => State RG a -> m a
newtype RG
RG :: StdGen -> RG
[unRG] :: RG -> StdGen
rngSeed :: ℕ64 -> IO ()
wrapPrimRandu :: (StdGen -> (a, StdGen)) -> State RG a
wrapPrimRandr :: ((a, a) -> StdGen -> (a, StdGen)) -> a -> a -> State RG a
class RandUniform a
prandu :: RandUniform a => State RG a
class RandRange a
prandr :: RandRange a => a -> a -> State RG a
prandrRadius :: (RandRange a, Zero a, Minus a) => a -> State RG a
randu :: forall a m. (MonadRand m, RandUniform a) => m a
randr :: forall a m. (MonadRand m, RandRange a) => a -> a -> m a
randrRadius :: forall a m. (MonadRand m, RandRange a, Zero a, Minus a) => a -> m a
wrchoose :: forall t m a. (Monad m, MonadRand m, ToIter (ℕ64 ∧ (() -> m a)) t) => t -> m a
rchoose :: (Monad m, MonadRand m, ToIter (() -> m a) t) => t -> m a
untilPass :: Monad m => (a -> 𝔹) -> m a -> m a
instance UVMHS.Lib.Rand.MonadRand GHC.Types.IO
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.𝔻
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.ℤ16
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.ℤ32
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.ℤ64
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.ℤ8
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.ℕ16
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.ℕ32
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.ℕ64
instance UVMHS.Lib.Rand.RandRange UVMHS.Core.Init.ℕ8
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.𝔹
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.ℤ16
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.ℤ32
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.ℤ64
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.ℤ8
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.ℕ16
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.ℕ32
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.ℕ64
instance UVMHS.Lib.Rand.RandUniform UVMHS.Core.Init.ℕ8

module UVMHS.Lib.Fuzzy
class Fuzzy a
fuzzy :: Fuzzy a => FuzzyM a
data FuzzyEnv
FuzzyEnv :: ℕ64 -> ℕ64 -> FuzzyEnv
[fuzzyEnvRadius] :: FuzzyEnv -> ℕ64
[fuzzyEnvDepth] :: FuzzyEnv -> ℕ64
newtype FuzzyM a
FuzzyM :: RWS FuzzyEnv () RG a -> FuzzyM a
[unRandM] :: FuzzyM a -> RWS FuzzyEnv () RG a
fuzzyEnvRadiusL :: FuzzyEnv ⟢ ℕ64
fuzzyEnvDepthL :: FuzzyEnv ⟢ ℕ64
mkFuzzyM :: (FuzzyEnv -> RG -> RG ∧ a) -> FuzzyM a
runFuzzyM :: FuzzyEnv -> RG -> FuzzyM a -> RG ∧ a
runFuzzyMRG :: FuzzyEnv -> FuzzyM a -> State RG a

-- | Use this to ensure termination when building recursive datatypes. Note
--   that this will underflow to the maximum natural when <tt>d</tt> is
--   zero, so you should only every use this when you're sure <tt>d</tt> is
--   not zero, e.g. guarded behind a <a>wrchoose</a> with coefficient
--   <tt>d</tt>.
fuzzyRec :: FuzzyM a -> FuzzyM a
rand :: forall a m. (MonadRand m, Fuzzy a) => ℕ64 -> ℕ64 -> m a
randTny :: forall a m. (MonadRand m, Fuzzy a) => m a
randSml :: forall a m. (MonadRand m, Fuzzy a) => m a
randMed :: forall a m. (MonadRand m, Fuzzy a) => m a
randLrg :: forall a m. (MonadRand m, Fuzzy a) => m a
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Lib.Fuzzy.FuzzyM
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Lib.Fuzzy.FuzzyM
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.𝔹
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.𝔻
instance UVMHS.Lib.Fuzzy.Fuzzy a => UVMHS.Lib.Fuzzy.Fuzzy (() -> a)
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.ℤ16
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.ℤ32
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.ℤ64
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.ℤ8
instance UVMHS.Lib.Fuzzy.Fuzzy ()
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.ℕ16
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.ℕ32
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.ℕ64
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Core.Init.ℕ8
instance (GHC.Classes.Ord k, UVMHS.Lib.Fuzzy.Fuzzy k, UVMHS.Lib.Fuzzy.Fuzzy v) => UVMHS.Lib.Fuzzy.Fuzzy (k UVMHS.Core.Init.⇰ v)
instance (UVMHS.Lib.Fuzzy.Fuzzy a, UVMHS.Lib.Fuzzy.Fuzzy b) => UVMHS.Lib.Fuzzy.Fuzzy (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Lib.Fuzzy.Fuzzy a, UVMHS.Lib.Fuzzy.Fuzzy b) => UVMHS.Lib.Fuzzy.Fuzzy (a UVMHS.Core.Init.∨ b)
instance UVMHS.Lib.Fuzzy.Fuzzy a => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Core.Init.𝐿 a)
instance UVMHS.Lib.Fuzzy.Fuzzy a => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Core.Init.𝑂 a)
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Lib.Fuzzy.FuzzyM
instance UVMHS.Lib.Rand.MonadRand UVMHS.Lib.Fuzzy.FuzzyM
instance UVMHS.Core.Effects.MonadReader UVMHS.Lib.Fuzzy.FuzzyEnv UVMHS.Lib.Fuzzy.FuzzyM
instance UVMHS.Core.Effects.MonadState UVMHS.Lib.Rand.RG UVMHS.Lib.Fuzzy.FuzzyM
instance UVMHS.Core.Classes.Functors.Return UVMHS.Lib.Fuzzy.FuzzyM

module UVMHS.Lib.Sep
data Sep i a
SepE :: a -> Sep i a
SepN :: a -> i -> 𝐼C (a ∧ i) -> a -> Sep i a
sepI :: Null a => i -> Sep i a
mapSep :: (i -> j) -> (a -> b) -> Sep i a -> Sep j b
mapSepI :: (i -> j) -> Sep i a -> Sep j a
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Sep.Sep i a)
instance UVMHS.Core.Classes.Collections.CSized (UVMHS.Lib.Sep.Sep i a)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Sep.Sep i)
instance UVMHS.Core.Classes.Monoid.Monoid a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Sep.Sep i a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Sep.Sep i a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Lib.Sep.Sep a a)

module UVMHS.Lib.Shrinky
class Shrinky a
shrink :: Shrinky a => a -> 𝐼 a
shrinkAssoc :: Shrinky v => 𝐿 (k ∧ v) -> 𝐼 (𝐿 (k ∧ v))
shrunkR :: Shrinky a => (a -> 𝔹) -> ℕ64 -> a -> 𝑆 a -> ℕ64 ∧ a
shrunk :: Shrinky a => (a -> 𝔹) -> a -> ℕ64 ∧ a
instance UVMHS.Lib.Shrinky.Shrinky UVMHS.Core.Init.ℤ64
instance (UVMHS.Lib.Shrinky.Shrinky a, UVMHS.Lib.Shrinky.Shrinky b) => UVMHS.Lib.Shrinky.Shrinky (a, b)
instance (UVMHS.Lib.Shrinky.Shrinky a, UVMHS.Lib.Shrinky.Shrinky b, UVMHS.Lib.Shrinky.Shrinky c) => UVMHS.Lib.Shrinky.Shrinky (a, b, c)
instance UVMHS.Lib.Shrinky.Shrinky ()
instance UVMHS.Lib.Shrinky.Shrinky UVMHS.Core.Init.ℕ64
instance (GHC.Classes.Ord k, UVMHS.Lib.Shrinky.Shrinky v) => UVMHS.Lib.Shrinky.Shrinky (k UVMHS.Core.Init.⇰ v)
instance (UVMHS.Lib.Shrinky.Shrinky a, UVMHS.Lib.Shrinky.Shrinky b) => UVMHS.Lib.Shrinky.Shrinky (a UVMHS.Core.Init.∧ b)
instance (UVMHS.Lib.Shrinky.Shrinky a, UVMHS.Lib.Shrinky.Shrinky b) => UVMHS.Lib.Shrinky.Shrinky (a UVMHS.Core.Init.∨ b)
instance UVMHS.Lib.Shrinky.Shrinky a => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Lib.Shrinky.Shrinky a => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Core.Init.𝐿 a)
instance UVMHS.Lib.Shrinky.Shrinky a => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Core.Init.𝑂 a)
instance UVMHS.Lib.Shrinky.Shrinky a => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Core.Vector.𝕍 a)

module UVMHS.Lib.TreeAnnote
class Annote i a | a -> i
annote :: Annote i a => i -> a -> a
data 𝑇 i a
N𝑇 :: 𝑇 i a
B𝑇 :: 𝑇 i a -> 𝑇 i a -> 𝑇 i a
L𝑇 :: a -> 𝑇 i a
A𝑇 :: i -> 𝑇 i a -> 𝑇 i a
fold𝑇With :: Monoid b => (a -> b) -> (i -> b -> b) -> 𝑇 i a -> b
fold𝑇On :: Monoid b => 𝑇 i a -> (a -> b) -> (i -> b -> b) -> b
data 𝑇V i a
𝑇V :: (forall b. Monoid b => (a -> b) -> (i -> b -> b) -> b) -> 𝑇V i a
[un𝑇V] :: 𝑇V i a -> forall b. Monoid b => (a -> b) -> (i -> b -> b) -> b
fold𝑇VOn :: Monoid b => 𝑇V i a -> (a -> b) -> (i -> b -> b) -> b
fold𝑇VWith :: Monoid b => (a -> b) -> (i -> b -> b) -> 𝑇V i a -> b
null𝑇V :: 𝑇V i a
append𝑇V :: 𝑇V i a -> 𝑇V i a -> 𝑇V i a
single𝑇V :: a -> 𝑇V i a
annote𝑇V :: i -> 𝑇V i a -> 𝑇V i a
map𝑇V :: (i -> j) -> (a -> b) -> 𝑇V i a -> 𝑇V j b
instance UVMHS.Lib.TreeAnnote.Annote i (UVMHS.Lib.TreeAnnote.𝑇 i a)
instance UVMHS.Lib.TreeAnnote.Annote i (UVMHS.Lib.TreeAnnote.𝑇V i a)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.TreeAnnote.𝑇 i a)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.TreeAnnote.𝑇V i a)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.TreeAnnote.𝑇 i)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.TreeAnnote.𝑇V i)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.TreeAnnote.𝑇 i a)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.TreeAnnote.𝑇V i a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.TreeAnnote.𝑇 i a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.TreeAnnote.𝑇V i a)
instance UVMHS.Core.Classes.Collections.Single a (UVMHS.Lib.TreeAnnote.𝑇 i a)
instance UVMHS.Core.Classes.Collections.Single a (UVMHS.Lib.TreeAnnote.𝑇V i a)

module UVMHS.Lib.Pretty.Common
data ChunkI
RawChunkI :: ℕ64 -> 𝕊 -> ChunkI
NewlineChunkI :: ℕ64 -> ChunkI
rawChunksI :: 𝕊 -> ChunkI
splitChunksI :: 𝕊 -> 𝐼 ChunkI
shapeIChunk :: ChunkI -> Shape
extendNewlinesIChunk :: ℕ64 -> ChunkI -> ChunkI
data ChunkO
RawChunkO :: ℕ64 -> 𝕊 -> ChunkO
PaddingChunkO :: ℕ64 -> ChunkO
shapeOChunk :: ChunkO -> Shape
type TreeI = 𝑇V Annotation 𝐼 ChunkI
type TreeO = 𝑇V Formats Sep () 𝐼A ChunkO
chunkIO :: ChunkO -> ChunkI
treeIO :: TreeO -> TreeI
data SummaryI
SummaryI :: 𝔹 -> ShapeA -> TreeI -> SummaryI
[summaryIForceBreak] :: SummaryI -> 𝔹
[summaryIShape] :: SummaryI -> ShapeA
[summaryIContents] :: SummaryI -> TreeI
summaryIForceBreakL :: SummaryI ⟢ 𝔹
summaryIShapeL :: SummaryI ⟢ ShapeA
summaryIContentsL :: SummaryI ⟢ TreeI
alignSummary :: SummaryI -> SummaryI
summaryChunksI :: 𝐼 ChunkI -> SummaryI
annotateSummaryI :: Annotation -> SummaryI -> SummaryI
data SummaryO
SummaryO :: Shape -> TreeO -> SummaryO
[summaryOShape] :: SummaryO -> Shape
[summaryOContents] :: SummaryO -> TreeO
summaryOShapeL :: SummaryO ⟢ Shape
summaryOContentsL :: SummaryO ⟢ TreeO
summaryChunksO :: Sep () (𝐼A ChunkO) -> SummaryO
annotateSummaryO :: Formats -> SummaryO -> SummaryO
data HAlign
LH :: HAlign
CH :: HAlign
RH :: HAlign
data VAlign
TV :: VAlign
CV :: VAlign
BV :: VAlign
hvalign :: HAlign -> VAlign -> ℕ64 -> ℕ64 -> SummaryO -> SummaryO
instance UVMHS.Core.Classes.Collections.ASized UVMHS.Lib.Pretty.Common.ChunkO
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.Common.SummaryI
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.Common.SummaryO
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Common.ChunkI
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Common.ChunkO
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.Common.SummaryI
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.Common.SummaryO
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.Common.SummaryI
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.Common.SummaryO
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Common.ChunkI
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Common.ChunkO
instance GHC.Show.Show UVMHS.Lib.Pretty.Common.ChunkI
instance GHC.Show.Show UVMHS.Lib.Pretty.Common.ChunkO

module UVMHS.Lib.Pretty.RenderUndertags
data RenderUTEnv
RenderUTEnv :: 𝑂 (ℂ ∧ Formats) -> RenderUTEnv
[renderUTEnvUnderFormat] :: RenderUTEnv -> 𝑂 (ℂ ∧ Formats)
renderUTEnvUnderFormatL :: RenderUTEnv ⟢ 𝑂 (ℂ ∧ Formats)
renderUTEnv₀ :: RenderUTEnv
data RenderUTState
RenderUTState :: ℕ64 -> 𝐼 (((ℕ64 ∧ ℕ64) ∧ ℂ) ∧ Formats) -> RenderUTState
[t2StateCol] :: RenderUTState -> ℕ64
[t2StateUnders] :: RenderUTState -> 𝐼 (((ℕ64 ∧ ℕ64) ∧ ℂ) ∧ Formats)
t2StateColL :: RenderUTState ⟢ ℕ64
t2StateUndersL :: RenderUTState ⟢ 𝐼 (((ℕ64 ∧ ℕ64) ∧ ℂ) ∧ Formats)
t2State₀ :: RenderUTState
type RenderUTM = RWS RenderUTEnv SummaryO RenderUTState
newtype RenderUT
RenderUT :: RenderUTM () -> RenderUT
[unRenderUT] :: RenderUT -> RenderUTM ()
onRenderUT :: (RenderUTM () -> RenderUTM ()) -> RenderUT -> RenderUT
onRenderUT2 :: (RenderUTM () -> RenderUTM () -> RenderUTM ()) -> RenderUT -> RenderUT -> RenderUT
buildUndertags :: ℕ64 -> RenderUTM ()
renderNewline :: ℕ64 -> RenderUTM ()
renderRaw :: ℕ64 -> 𝕊 -> RenderUTM ()
renderPadding :: ℕ64 -> RenderUTM ()
renderUndertags :: RenderUTM ()
renderChunkUndertags :: ChunkI -> RenderUTM ()
annotateRenderUT :: Annotation -> RenderUTM () -> RenderUTM ()
compileRenderUT :: TreeI -> RenderUT
execRenderUT :: TreeI -> SummaryO
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.RenderUndertags.RenderUT
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.RenderUndertags.RenderUT
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.RenderUndertags.RenderUT

module UVMHS.Lib.Pretty.DocA
data DocAEnv
DocAEnv :: 𝑂 ℕ64 -> 𝑂 ℕ64 -> ℕ64 -> DocAEnv
[docAEnvMaxLineWidth] :: DocAEnv -> 𝑂 ℕ64
[docAEnvMaxRibbonWidth] :: DocAEnv -> 𝑂 ℕ64
[docAEnvNest] :: DocAEnv -> ℕ64
docAEnvMaxLineWidthL :: DocAEnv ⟢ 𝑂 ℕ64
docAEnvMaxRibbonWidthL :: DocAEnv ⟢ 𝑂 ℕ64
docAEnvNestL :: DocAEnv ⟢ ℕ64
docAEnv₀ :: DocAEnv
data DocAState
DocAState :: ℕ64 -> ℕ64 -> ℕ64 -> DocAState
[docAStateRib] :: DocAState -> ℕ64
[docAStateRow] :: DocAState -> ℕ64
[docAStateCol] :: DocAState -> ℕ64
docAStateRibL :: DocAState ⟢ ℕ64
docAStateRowL :: DocAState ⟢ ℕ64
docAStateColL :: DocAState ⟢ ℕ64
docAState₀ :: DocAState
type DocAM = RWS DocAEnv TreeI DocAState
data DocA
StaticDocA :: SummaryI -> DocA
DynamicDocA :: SummaryI -> DocAM () -> DocA
staticDocAL :: DocA ⌲ SummaryI
dynamicDocAL :: DocA ⌲ (SummaryI ∧ DocAM ())
staticDocA :: DocA -> SummaryI
dynamicDocA :: DocA -> DocAM ()
renderSummaryI :: SummaryI -> DocAM ()
stringDocA :: 𝕊 -> DocA
docAModal :: DocA -> DocA -> DocA
annotateDocA :: Annotation -> DocA -> DocA
groupDocAM :: SummaryI -> DocAM () -> DocAM ()
groupDocA :: DocA -> DocA
alignDocAM :: DocAM a -> DocAM a
alignDocA :: DocA -> DocA
execDocAWith :: (DocAM () -> DocAM ()) -> DocA -> TreeI
execDocA :: DocA -> TreeI
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.DocA.DocA
instance GHC.Classes.Eq UVMHS.Lib.Pretty.DocA.DocAEnv
instance GHC.Classes.Eq UVMHS.Lib.Pretty.DocA.DocAState
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.DocA.DocA
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.DocA.DocA
instance GHC.Classes.Ord UVMHS.Lib.Pretty.DocA.DocAEnv
instance GHC.Classes.Ord UVMHS.Lib.Pretty.DocA.DocAState
instance GHC.Show.Show UVMHS.Lib.Pretty.DocA.DocAEnv
instance GHC.Show.Show UVMHS.Lib.Pretty.DocA.DocAState

module UVMHS.Lib.Pretty.Doc
data PrettyParams
PrettyParams :: Formats -> Formats -> Formats -> Formats -> Formats -> Formats -> Formats -> Formats -> Formats -> Formats -> Formats -> Formats -> Formats -> ℕ64 -> PrettyParams
[punctuationFormat] :: PrettyParams -> Formats
[keywordFormat] :: PrettyParams -> Formats
[constructorFormat] :: PrettyParams -> Formats
[operatorFormat] :: PrettyParams -> Formats
[primitiveFormat] :: PrettyParams -> Formats
[binderFormat] :: PrettyParams -> Formats
[literalFormat] :: PrettyParams -> Formats
[highlightFormat] :: PrettyParams -> Formats
[headerFormat] :: PrettyParams -> Formats
[commentFormat] :: PrettyParams -> Formats
[errorFormat] :: PrettyParams -> Formats
[lineNumberFormat] :: PrettyParams -> Formats
[annotationFormat] :: PrettyParams -> Formats
[appLevel] :: PrettyParams -> ℕ64
punctuationFormatL :: PrettyParams ⟢ Formats
keywordFormatL :: PrettyParams ⟢ Formats
constructorFormatL :: PrettyParams ⟢ Formats
operatorFormatL :: PrettyParams ⟢ Formats
primitiveFormatL :: PrettyParams ⟢ Formats
binderFormatL :: PrettyParams ⟢ Formats
literalFormatL :: PrettyParams ⟢ Formats
highlightFormatL :: PrettyParams ⟢ Formats
headerFormatL :: PrettyParams ⟢ Formats
commentFormatL :: PrettyParams ⟢ Formats
errorFormatL :: PrettyParams ⟢ Formats
lineNumberFormatL :: PrettyParams ⟢ Formats
annotationFormatL :: PrettyParams ⟢ Formats
appLevelL :: PrettyParams ⟢ ℕ64
prettyParams₀ :: PrettyParams
data DocEnv
DocEnv :: PrettyParams -> ℕ64 -> 𝔹 -> DocEnv
[docEnvPrettyParams] :: DocEnv -> PrettyParams
[docEnvPrecLevel] :: DocEnv -> ℕ64
[docEnvPrecBumped] :: DocEnv -> 𝔹
docEnvPrettyParamsL :: DocEnv ⟢ PrettyParams
docEnvPrecLevelL :: DocEnv ⟢ ℕ64
docEnvPrecBumpedL :: DocEnv ⟢ 𝔹
docEnv₀ :: DocEnv
type DocM = RWS DocEnv DocA ()
newtype Doc
Doc :: DocM () -> Doc
[unDoc] :: Doc -> DocM ()
execDocWith :: (DocM () -> DocM ()) -> Doc -> DocA
execDoc :: Doc -> DocA
onDoc :: (DocM () -> DocM ()) -> Doc -> Doc
onDoc2 :: (DocM () -> DocM () -> DocM ()) -> Doc -> Doc -> Doc
docShape :: Doc -> ShapeA
ppForceBreak :: Doc
ppWithForcedBreak :: Doc -> Doc
ppAnnotate :: Annotation -> Doc -> Doc
ppFormat :: Formats -> Doc -> Doc
ppFormatParam :: (PrettyParams ⟢ Formats) -> Doc -> Doc
ppUndertag :: ℂ -> Formats -> Doc -> Doc
ppGroup :: Doc -> Doc
ppAlign :: Doc -> Doc
ppGA :: Doc -> Doc
ppString :: 𝕊 -> Doc
ppStringModal :: 𝕊 -> 𝕊 -> Doc
ppModal :: Doc -> Doc -> Doc
ppFG :: Color -> Doc -> Doc
ppBG :: Color -> Doc -> Doc
ppUL :: Doc -> Doc
ppBD :: Doc -> Doc
ppIT :: Doc -> Doc
ppUT :: ℂ -> Color -> Doc -> Doc
ppPunFmt :: Doc -> Doc
ppPun :: 𝕊 -> Doc
ppKeyFmt :: Doc -> Doc
ppKey :: 𝕊 -> Doc
ppConFmt :: Doc -> Doc
ppCon :: 𝕊 -> Doc
ppOpFmt :: Doc -> Doc
ppOp :: 𝕊 -> Doc
ppPrimFmt :: Doc -> Doc
ppPrim :: 𝕊 -> Doc
ppBdrFmt :: Doc -> Doc
ppBdr :: 𝕊 -> Doc
ppLitFmt :: Doc -> Doc
ppLit :: 𝕊 -> Doc
ppHlFmt :: Doc -> Doc
ppHl :: 𝕊 -> Doc
ppHeaderFmt :: Doc -> Doc
ppHeader :: 𝕊 -> Doc
ppCommentFmt :: Doc -> Doc
ppComment :: 𝕊 -> Doc
ppErrFmt :: Doc -> Doc
ppErr :: 𝕊 -> Doc
ppLineNumFmt :: Doc -> Doc
ppLineNum :: 𝕊 -> Doc
ppAnnotation :: Doc -> Doc
ppCxt :: 𝕊 -> Doc -> Doc
ppSpace :: ℕ64 -> Doc
ppNewline :: Doc
ppIndented :: Doc -> Doc
ppSpaceIfBreak :: Doc
ppSpaceIfNoBreak :: Doc
ppNewlineIfBreak :: Doc
ppSpaceNewlineIfBreak :: Doc
ppHangIfBreak :: Doc -> Doc
ppHorizontal :: ToIter Doc t => t -> Doc
ppVertical :: ToIter Doc t => t -> Doc
ppSeparated :: ToIter Doc t => t -> Doc
ppSetLevel :: ℕ64 -> Doc -> Doc
ppSetBotLevel :: Doc -> Doc
ppBump :: Doc -> Doc
ppClosed :: Doc -> Doc -> Doc -> Doc
ppParens :: Doc -> Doc
ppLevel :: ℕ64 -> Doc -> Doc
ppInfLevel :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInflLevel :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInfrLevel :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppPreLevel :: ℕ64 -> Doc -> Doc -> Doc
ppPostLevel :: ℕ64 -> Doc -> Doc -> Doc
ppInf :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInfl :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInfr :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppPre :: ℕ64 -> Doc -> Doc -> Doc
ppPost :: ℕ64 -> Doc -> Doc -> Doc
ppInfSep :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInflSep :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInfrSep :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppPreSep :: ℕ64 -> Doc -> Doc -> Doc
ppPostSep :: ℕ64 -> Doc -> Doc -> Doc
ppInf' :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInfl' :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInfr' :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInfSep' :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInflSep' :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppInfrSep' :: ℕ64 -> Doc -> Doc -> Doc -> Doc
ppApp :: ToIter Doc t => Doc -> t -> Doc
ppCollection :: ToIter Doc t => Doc -> Doc -> Doc -> t -> Doc
ppRecord :: ToIter (Doc ∧ Doc) t => Doc -> t -> Doc
ppBake :: Doc -> TreeI
ppEmbed :: TreeI -> Doc
matrixHelper :: forall (m :: 𝐍) (n :: 𝐍). (𝒩 m, 𝒩 n) => 𝕍S n HAlign -> 𝕍S m VAlign -> 𝕍S m (𝕍S n SummaryO) -> 𝕍S n ℕ64 ∧ 𝕍S m (𝕍S n SummaryO)
ppMatrix :: forall (m :: 𝐍) (n :: 𝐍). (𝒩 m, 𝒩 n) => 𝕍S n HAlign -> 𝕍S m VAlign -> 𝕍S m (𝕍S n Doc) -> Doc
ppMatrixCells :: forall (m :: 𝐍) (n :: 𝐍). (𝒩 m, 𝒩 n) => 𝕍S n HAlign -> 𝕍S m VAlign -> 𝕍S m (𝕍S n Doc) -> Doc
class Pretty a
pretty :: Pretty a => a -> Doc
class PrettyM (m :: Type -> Type) a | a -> m
mpretty :: PrettyM m a => a -> m Doc
escape :: ℂ -> 𝐼 ℂ
ppTupHS2 :: Doc -> Doc -> Doc
ppTup :: Doc -> Doc -> Doc
ppList :: ToIter Doc t => t -> Doc
ppLazyList :: ToIter Doc t => t -> Doc
ppIter :: ToIter Doc t => t -> Doc
ppIterC :: ToIter Doc t => t -> Doc
ppSeq :: ToIter Doc t => t -> Doc
ppSet :: ToIter Doc t => t -> Doc
ppDict :: ToIter (Doc ∧ Doc) t => t -> Doc
ppVec :: ToIter Doc t => t -> Doc
ppVecS :: ToIter Doc t => t -> Doc
ppUVec :: ToIter Doc t => t -> Doc
ppUVecS :: ToIter Doc t => t -> Doc
ppAddNull :: AddNull Doc -> Doc
ppAddBot :: AddBot Doc -> Doc
ppAddTop :: AddTop Doc -> Doc
ppAddBT :: AddBT Doc -> Doc
ppZOM :: ZOM Doc -> Doc
colorsDemo :: Doc
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Pretty.Doc.Doc
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Doc.DocEnv
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Doc.PrettyParams
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Pretty.Doc.Doc
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Pretty.Doc.Doc
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Doc.DocEnv
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Doc.PrettyParams
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Pointed.AddBT a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Pointed.AddBot a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Pointed.AddNull a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Pointed.AddTop a)
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔹
instance UVMHS.Lib.Pretty.Doc.Pretty GHC.Stack.Types.CallStack
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℂ
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Pretty.Doc.Doc
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔻
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (() -> a)
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ16
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ32
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ64
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ8
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty [a]
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Time.TimeD
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℚ
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℚᴾ
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊
instance (UVMHS.Lib.Pretty.Doc.Pretty a, UVMHS.Lib.Pretty.Doc.Pretty b) => UVMHS.Lib.Pretty.Doc.Pretty (a, b)
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Time.Time
instance UVMHS.Lib.Pretty.Doc.Pretty ()
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.Void
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ16
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ32
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ64
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ8
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Pointed.ZOM a)
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℝ
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℝᴾ
instance (UVMHS.Lib.Pretty.Doc.Pretty k, UVMHS.Lib.Pretty.Doc.Pretty v) => UVMHS.Lib.Pretty.Doc.Pretty (k UVMHS.Core.Init.⇰ v)
instance (UVMHS.Lib.Pretty.Doc.Pretty a, UVMHS.Lib.Pretty.Doc.Pretty b) => UVMHS.Lib.Pretty.Doc.Pretty (a UVMHS.Core.Init.∧ b)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝐼 a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Sized.𝐼C a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝐿 a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑃 a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑄 a)
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔻ᴾ
instance (Foreign.Storable.Storable a, UVMHS.Lib.Pretty.Doc.Pretty a) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Vector.𝕌 a)
instance forall k a (n :: k). (Foreign.Storable.Storable a, UVMHS.Lib.Pretty.Doc.Pretty a) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.VectorStatic.𝕌S n a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Vector.𝕍 a)
instance forall k a (n :: k). UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.VectorStatic.𝕍S n a)
instance GHC.Show.Show UVMHS.Lib.Pretty.Doc.DocEnv
instance GHC.Show.Show UVMHS.Lib.Pretty.Doc.PrettyParams

module UVMHS.Lib.Pretty.RenderANSI
data ANSIEnv
ANSIEnv :: 𝔹 -> Formats -> ANSIEnv
[ansiEnvDoFormat] :: ANSIEnv -> 𝔹
[ansiEnvFormats] :: ANSIEnv -> Formats
ansiEnvDoFormatL :: ANSIEnv ⟢ 𝔹
ansiEnvFormatsL :: ANSIEnv ⟢ Formats
ansiEnv₀ :: ANSIEnv
type RenderANSIM = RWS ANSIEnv 𝐼A 𝕊 ()
sgrLeader :: 𝕊
sgrCloser :: 𝕊
sgrReset :: 𝕊
sgrFg :: Color -> 𝕊
sgrBg :: Color -> 𝕊
sgrUl :: 𝔹 -> 𝕊
sgrBd :: 𝔹 -> 𝕊
sgrIt :: 𝔹 -> 𝕊
sgrFormat :: Formats -> 𝐼A 𝕊
tellSgrFormat :: RenderANSIM ()
localFormat :: Formats -> RenderANSIM () -> RenderANSIM ()
renderChunkANSI :: ChunkO -> 𝐼A 𝕊
formatRenderANSI :: Formats -> RenderANSIM () -> RenderANSIM ()
compileOTree :: TreeO -> RenderANSIM ()
execRenderANSIWith :: (RenderANSIM () -> RenderANSIM ()) -> TreeO -> 𝐼A 𝕊
execRenderANSI :: TreeO -> 𝐼A 𝕊
gv_PPRINT_COLOR :: IORef 𝔹
ppRenderWith :: (RenderANSIM () -> RenderANSIM ()) -> (DocAM () -> DocAM ()) -> (DocM () -> DocM ()) -> Doc -> 𝕊
ppRender :: Doc -> 𝕊
ppRenderNoFmt :: Doc -> 𝕊
ppRenderYesFmt :: Doc -> 𝕊
ppRenderWide :: Doc -> 𝕊
ppRenderNarrow :: Doc -> 𝕊
ppRenderNoFmtWide :: Doc -> 𝕊
ppRenderNoFmtNarrow :: Doc -> 𝕊
ppshow :: Pretty a => a -> 𝕊
pprint :: Pretty a => a -> IO ()
ppColorOn :: IO ()
ppColorOff :: IO ()
pptrace :: Pretty a => a -> ()
pptraceM :: (Monad m, Pretty a) => a -> m ()
ppabort :: Pretty a => a -> IO b
debugShape :: Doc -> IO ()
instance GHC.Classes.Eq UVMHS.Lib.Pretty.RenderANSI.ANSIEnv
instance GHC.Classes.Eq UVMHS.Lib.Pretty.Doc.Doc
instance GHC.Classes.Ord UVMHS.Lib.Pretty.RenderANSI.ANSIEnv
instance GHC.Classes.Ord UVMHS.Lib.Pretty.Doc.Doc
instance GHC.Show.Show UVMHS.Lib.Pretty.RenderANSI.ANSIEnv

module UVMHS.Lib.Pretty.Deriving
makePrettySumLogic :: Cxt -> Name -> 𝐿 (TyVarBndr BndrVis) -> 𝐿 (Name ∧ 𝐿 Type) -> Q (𝐿 Dec)
makePrettySum :: Name -> Q [Dec]
makePrettyUnionLogic :: Cxt -> Name -> 𝐿 (TyVarBndr BndrVis) -> 𝐿 (Name ∧ 𝐿 Type) -> Q (𝐿 Dec)
makePrettyUnion :: Name -> Q [Dec]
makePrettyRecordLogic :: Cxt -> Name -> 𝐿 (TyVarBndr BndrVis) -> Name -> 𝐿 (Name ∧ Type) -> Q (𝐿 Dec)
makePrettyRecord :: Name -> Q [Dec]

module UVMHS.Lib.Pretty.DerivedInstances
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Pretty.Color.Color3Bit, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ8) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Pretty.Color.Color
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Pretty.Color.Color3Bit
instance (UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑂 UVMHS.Lib.Pretty.Color.Color), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑂 UVMHS.Core.Init.𝔹)) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Pretty.Annotation.Formats
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Monads.ID a)
instance (UVMHS.Lib.Pretty.Doc.Pretty a, UVMHS.Lib.Pretty.Doc.Pretty b) => UVMHS.Lib.Pretty.Doc.Pretty (a UVMHS.Core.Init.∨ b)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑂 a)

module UVMHS.Lib.Pretty

module UVMHS.Lib.Parser.Loc
data Loc
Loc :: (ℕ64 ∧ ℕ64) -> ℕ64 -> ℕ64 -> Loc
[locPos] :: Loc -> ℕ64 ∧ ℕ64
[locRow] :: Loc -> ℕ64
[locCol] :: Loc -> ℕ64
locPosL :: Loc ⟢ (ℕ64 ∧ ℕ64)
locRowL :: Loc ⟢ ℕ64
locColL :: Loc ⟢ ℕ64
bumpRow₁ :: Loc -> Loc
bumpCol₁ :: Loc -> Loc
bumpCol₂ :: Loc -> Loc
data LocRange
LocRange :: AddBT Loc -> AddBT Loc -> LocRange
[locRangeBegin] :: LocRange -> AddBT Loc
[locRangeEnd] :: LocRange -> AddBT Loc
locRangeBeginL :: LocRange ⟢ AddBT Loc
locRangeEndL :: LocRange ⟢ AddBT Loc
bumpColEnd₂ :: LocRange -> LocRange
locRange₀ :: LocRange
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Lib.Parser.Loc.Loc
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Lib.Parser.Loc.LocRange
instance GHC.Classes.Eq UVMHS.Lib.Parser.Loc.Loc
instance GHC.Classes.Eq UVMHS.Lib.Parser.Loc.LocRange
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Lib.Parser.Loc.Loc
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Lib.Parser.Loc.Loc
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Lib.Parser.Loc.LocRange
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Lib.Parser.Loc.Loc
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Lib.Parser.Loc.LocRange
instance GHC.Classes.Ord UVMHS.Lib.Parser.Loc.Loc
instance GHC.Classes.Ord UVMHS.Lib.Parser.Loc.LocRange
instance (UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.ℕ64 UVMHS.Core.Init.∧ UVMHS.Core.Init.ℕ64), UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ64) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Loc.Loc
instance UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Pointed.AddBT UVMHS.Lib.Parser.Loc.Loc) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Loc.LocRange
instance GHC.Show.Show UVMHS.Lib.Parser.Loc.Loc
instance GHC.Show.Show UVMHS.Lib.Parser.Loc.LocRange
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Lib.Parser.Loc.LocRange

module UVMHS.Lib.Logging
newtype LogLevel
LogLevel :: ℕ64 -> LogLevel
[unLogLevel] :: LogLevel -> ℕ64
newtype LogDepth
LogDepth :: ℕ64 -> LogDepth
[unLogDepth] :: LogDepth -> ℕ64
data LogOptions
LogOptions :: ℕ64 -> ℕ64 -> 𝔹 -> LogOptions
[logOptionsLevel] :: LogOptions -> ℕ64
[logOptionsDepth] :: LogOptions -> ℕ64
[logOptionsShowLevel] :: LogOptions -> 𝔹
logOptionsLevelL :: LogOptions ⟢ ℕ64
logOptionsDepthL :: LogOptions ⟢ ℕ64
logOptionsShowLevelL :: LogOptions ⟢ 𝔹
logOptions₀ :: LogOptions
pplog :: (Monad m, MonadIO m, MonadReader r m, HasLens r LogOptions) => ℕ64 -> (() -> Doc) -> m ()
pplogd :: (Monad m, MonadIO m, MonadReader r m, HasLens r LogOptions) => ℕ64 -> (() -> Doc) -> m ()
pplogdIndent :: (Monad m, MonadIO m, MonadReader r m, HasLens r LogOptions) => m a -> m a
pplogdIndentReset :: (Monad m, MonadIO m, MonadReader r m, HasLens r LogOptions) => m a -> m a
whenLogLevel :: (Monad m, MonadReader r m, HasLens r LogOptions) => ℕ64 -> (() -> m ()) -> m ()
instance GHC.Classes.Eq UVMHS.Lib.Logging.LogDepth
instance GHC.Classes.Eq UVMHS.Lib.Logging.LogLevel
instance GHC.Classes.Eq UVMHS.Lib.Logging.LogOptions
instance GHC.Classes.Ord UVMHS.Lib.Logging.LogDepth
instance GHC.Classes.Ord UVMHS.Lib.Logging.LogLevel
instance GHC.Classes.Ord UVMHS.Lib.Logging.LogOptions
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Logging.LogDepth
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Logging.LogLevel
instance GHC.Show.Show UVMHS.Lib.Logging.LogDepth
instance GHC.Show.Show UVMHS.Lib.Logging.LogLevel
instance GHC.Show.Show UVMHS.Lib.Logging.LogOptions

module UVMHS.Lib.Dataframe
data FrameType
B_FT :: FrameType
N_FT :: FrameType
Z_FT :: FrameType
D_FT :: FrameType
S_FT :: FrameType
b_FTL :: FrameType ⌲ ()
n_FTL :: FrameType ⌲ ()
z_FTL :: FrameType ⌲ ()
d_FTL :: FrameType ⌲ ()
s_FTL :: FrameType ⌲ ()
frameTypeCode :: FrameType -> 𝕊
data FrameVal
B_FV :: 𝔹 -> FrameVal
N_FV :: ℕ64 -> FrameVal
Z_FV :: ℤ64 -> FrameVal
D_FV :: 𝔻 -> FrameVal
S_FV :: 𝕊 -> FrameVal
b_FVL :: FrameVal ⌲ 𝔹
n_FVL :: FrameVal ⌲ ℕ64
z_FVL :: FrameVal ⌲ ℤ64
d_FVL :: FrameVal ⌲ 𝔻
s_FVL :: FrameVal ⌲ 𝕊
data FrameCol
B_FC :: 𝕌 𝔹 -> FrameCol
N_FC :: 𝕌 ℕ64 -> FrameCol
Z_FC :: 𝕌 ℤ64 -> FrameCol
D_FC :: 𝕌 𝔻 -> FrameCol
S_FC :: 𝕍 𝕊 -> FrameCol
b_FCL :: FrameCol ⌲ 𝕌 𝔹
n_FCL :: FrameCol ⌲ 𝕌 ℕ64
z_FCL :: FrameCol ⌲ 𝕌 ℤ64
d_FCL :: FrameCol ⌲ 𝕌 𝔻
s_FCL :: FrameCol ⌲ 𝕍 𝕊
frameColType :: FrameCol -> FrameType
frameColPack :: FrameType -> 𝐼C FrameVal -> 𝑂 FrameCol
frameColUnpack :: FrameCol -> 𝐼C FrameVal
frameColIndex :: ℕ64 -> FrameCol -> 𝑂 FrameVal
data FrameGrouping v
B_FG :: (𝔹 ⇰ v) -> FrameGrouping v
N_FG :: (ℕ64 ⇰ v) -> FrameGrouping v
Z_FG :: (ℤ64 ⇰ v) -> FrameGrouping v
D_FG :: (𝔻 ⇰ v) -> FrameGrouping v
S_FG :: (𝕊 ⇰ v) -> FrameGrouping v
frameGroupingInterWithM :: (Monad m, MonadFail m) => (v₁ -> v₂ -> m v₃) -> FrameGrouping v₁ -> FrameGrouping v₂ -> m (FrameGrouping v₃)
data FrameData
Vec_FD :: ℕ64 -> (𝕊 ⇰ FrameCol) -> FrameData
Grp_FD :: 𝕊 -> FrameGrouping FrameData -> FrameData
data Frame
Frame :: 𝑃 𝕊 -> 𝕍 𝕊 -> (𝕊 ⇰ FrameType) -> (𝕊 ⇰ FrameType) -> ((𝕊 ⇰ FrameVal) ⇰ (ℕ64 ∧ (𝕊 ⇰ FrameCol))) -> Frame
[frameColP] :: Frame -> 𝑃 𝕊
[frameColV] :: Frame -> 𝕍 𝕊
[frameColT] :: Frame -> 𝕊 ⇰ FrameType
[frameGrpT] :: Frame -> 𝕊 ⇰ FrameType
[frameData] :: Frame -> (𝕊 ⇰ FrameVal) ⇰ (ℕ64 ∧ (𝕊 ⇰ FrameCol))
frameProduct :: Frame -> Frame -> 𝑂 Frame
frameGroup :: 𝕊 -> 𝕊 -> Frame -> 𝑂 Frame
frameUngroup :: 𝕊 -> 𝕊 -> Frame -> 𝑂 Frame
frameValParse :: 𝕊 -> FrameType -> IO FrameVal
frameParse :: 𝕊 -> IO Frame
instance GHC.Classes.Eq UVMHS.Lib.Dataframe.Frame
instance GHC.Classes.Eq UVMHS.Lib.Dataframe.FrameCol
instance GHC.Classes.Eq UVMHS.Lib.Dataframe.FrameData
instance GHC.Classes.Eq v => GHC.Classes.Eq (UVMHS.Lib.Dataframe.FrameGrouping v)
instance GHC.Classes.Eq UVMHS.Lib.Dataframe.FrameType
instance GHC.Classes.Eq UVMHS.Lib.Dataframe.FrameVal
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Lib.Dataframe.FrameGrouping
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Lib.Dataframe.FrameGrouping
instance GHC.Classes.Ord UVMHS.Lib.Dataframe.Frame
instance GHC.Classes.Ord UVMHS.Lib.Dataframe.FrameCol
instance GHC.Classes.Ord UVMHS.Lib.Dataframe.FrameData
instance GHC.Classes.Ord v => GHC.Classes.Ord (UVMHS.Lib.Dataframe.FrameGrouping v)
instance GHC.Classes.Ord UVMHS.Lib.Dataframe.FrameType
instance GHC.Classes.Ord UVMHS.Lib.Dataframe.FrameVal
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Dataframe.Frame
instance (UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝔹 UVMHS.Core.Init.⇰ v), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.ℕ64 UVMHS.Core.Init.⇰ v), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.ℤ64 UVMHS.Core.Init.⇰ v), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝔻 UVMHS.Core.Init.⇰ v), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝕊 UVMHS.Core.Init.⇰ v)) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Dataframe.FrameGrouping v)
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔹, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ64, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ64, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔻, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Dataframe.FrameVal
instance GHC.Show.Show UVMHS.Lib.Dataframe.Frame
instance GHC.Show.Show UVMHS.Lib.Dataframe.FrameCol
instance GHC.Show.Show UVMHS.Lib.Dataframe.FrameData
instance GHC.Show.Show v => GHC.Show.Show (UVMHS.Lib.Dataframe.FrameGrouping v)
instance GHC.Show.Show UVMHS.Lib.Dataframe.FrameType
instance GHC.Show.Show UVMHS.Lib.Dataframe.FrameVal

module UVMHS.Lib.Annotated
data 𝐴 e a
𝐴 :: e -> a -> 𝐴 e a
[atag] :: 𝐴 e a -> e
[aval] :: 𝐴 e a -> a
atagL :: 𝐴 e a ⟢ e
avalL :: 𝐴 e a ⟢ a
map𝐴 :: (e -> e') -> (a -> b) -> 𝐴 e a -> 𝐴 e' b
mapATag :: (e -> e') -> 𝐴 e a -> 𝐴 e' a
mapAVal :: (a -> b) -> 𝐴 e a -> 𝐴 e b
mapM𝐴 :: Monad m => (e -> m e') -> (a -> m b) -> 𝐴 e a -> m (𝐴 e' b)
mapMATag :: Monad m => (e -> m e') -> 𝐴 e a -> m (𝐴 e' a)
mapMAVal :: Monad m => (a -> m b) -> 𝐴 e a -> m (𝐴 e b)
untag :: ((() -> e) -> b -> b) -> 𝐴 e a -> (a -> b) -> b
untagWith :: ((() -> e) -> b -> b) -> (a -> b) -> 𝐴 e a -> b
retag :: Monad m => m e -> a -> m (𝐴 e a)
instance (UVMHS.Core.Classes.Monoid.Append e, UVMHS.Core.Classes.Monoid.Append a) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Annotated.𝐴 e a)
instance UVMHS.Core.Classes.Comonad.Cobind (UVMHS.Lib.Annotated.𝐴 t)
instance UVMHS.Core.Classes.Comonad.Comonad (UVMHS.Lib.Annotated.𝐴 t)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Lib.Annotated.𝐴 t a)
instance UVMHS.Core.Classes.Comonad.Extract (UVMHS.Lib.Annotated.𝐴 t)
instance UVMHS.Core.Classes.Functors.FunctorM (UVMHS.Lib.Annotated.𝐴 t)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Annotated.𝐴 t)
instance GHC.Generics.Generic (UVMHS.Lib.Annotated.𝐴 e a)
instance (UVMHS.Core.Classes.Monoid.Null e, UVMHS.Core.Classes.Monoid.Null a) => UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Annotated.𝐴 e a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Lib.Annotated.𝐴 t a)
instance (UVMHS.Lib.Pretty.Doc.Pretty e, UVMHS.Lib.Pretty.Doc.Pretty a) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Annotated.𝐴 e a)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (UVMHS.Lib.Annotated.𝐴 e a)

module UVMHS.Lib.AD
data ADF a
ADF :: a -> a -> ADF a
[adfVal] :: ADF a -> a
[adfDer] :: ADF a -> a
adfValL :: ADF a ⟢ a
adfDerL :: ADF a ⟢ a
constADF :: Zero a => a -> ADF a
sensADF :: a -> a -> ADF a
plusADF :: Plus a => ADF a -> ADF a -> ADF a
timesADF :: (Plus a, Times a) => ADF a -> ADF a -> ADF a
data ADB a
ADB :: a -> (a -> a -> a) -> ADB a
[adbVal] :: ADB a -> a
[adbDer] :: ADB a -> a -> a -> a
adbValL :: ADB a ⟢ a
adbDerL :: ADB a ⟢ (a -> a -> a)
constADB :: Zero a => a -> ADB a
sensADB :: a -> (a -> a -> a) -> ADB a
plusADB :: Plus a => ADB a -> ADB a -> ADB a
timesADB :: Times a => ADB a -> ADB a -> ADB a
data ADFF (ns :: [𝐍]) (f :: [𝐍] -> Type -> Type) (ms :: [𝐍]) a
ADFF :: f (ns ⧺ ms) a -> f (ns ⧺ ms) a -> ADFF (ns :: [𝐍]) (f :: [𝐍] -> Type -> Type) (ms :: [𝐍]) a
[adffVal] :: ADFF (ns :: [𝐍]) (f :: [𝐍] -> Type -> Type) (ms :: [𝐍]) a -> f (ns ⧺ ms) a
[adffDer] :: ADFF (ns :: [𝐍]) (f :: [𝐍] -> Type -> Type) (ms :: [𝐍]) a -> f (ns ⧺ ms) a
adffValL :: forall (ns :: [𝐍]) f (ms :: [𝐍]) a. ADFF ns f ms a ⟢ f (ns ⧺ ms) a
adffDerL :: forall (ns :: [𝐍]) f (ms :: [𝐍]) a. ADFF ns f ms a ⟢ f (ns ⧺ ms) a
constADFF :: forall f (ns :: [𝐍]) (ms :: [𝐍]) a. Zero (f (ns ⧺ ms) a) => f (ns ⧺ ms) a -> ADFF ns f ms a
sensADFF :: forall f (ns :: [𝐍]) (ms :: [𝐍]) a. f (ns ⧺ ms) a -> f (ns ⧺ ms) a -> ADFF ns f ms a
plusADFF :: forall (f :: [𝐍] -> Type -> Type) (ns :: [𝐍]) (ms :: [𝐍]) a. Plus (f (ns ⧺ ms) a) => ADFF ns f ms a -> ADFF ns f ms a -> ADFF ns f ms a
timesADFF :: forall (f :: [𝐍] -> Type -> Type) (ns :: [𝐍]) (ms :: [𝐍]) a. (Plus (f (ns ⧺ ms) a), Times (f (ns ⧺ ms) a)) => ADFF ns f ms a -> ADFF ns f ms a -> ADFF ns f ms a
data ADFB (ns :: [𝐍]) (f :: [𝐍] -> Type -> Type) (ms :: [𝐍]) a
ADFB :: f (ns ⧺ ms) a -> (f (ns ⧺ ms) a -> f (ns ⧺ ms) a -> f (ns ⧺ ms) a) -> ADFB (ns :: [𝐍]) (f :: [𝐍] -> Type -> Type) (ms :: [𝐍]) a
[adfbVal] :: ADFB (ns :: [𝐍]) (f :: [𝐍] -> Type -> Type) (ms :: [𝐍]) a -> f (ns ⧺ ms) a
[adfbDer] :: ADFB (ns :: [𝐍]) (f :: [𝐍] -> Type -> Type) (ms :: [𝐍]) a -> f (ns ⧺ ms) a -> f (ns ⧺ ms) a -> f (ns ⧺ ms) a
adfbValL :: forall (ns :: [𝐍]) f (ms :: [𝐍]) a. ADFB ns f ms a ⟢ f (ns ⧺ ms) a
adfbDerL :: forall (ns :: [𝐍]) f (ms :: [𝐍]) a. ADFB ns f ms a ⟢ (f (ns ⧺ ms) a -> f (ns ⧺ ms) a -> f (ns ⧺ ms) a)
constADFB :: forall f (ns :: [𝐍]) (ms :: [𝐍]) a. f (ns ⧺ ms) a -> ADFB ns f ms a
sensADFB :: forall f (ns :: [𝐍]) (ms :: [𝐍]) a. f (ns ⧺ ms) a -> (f (ns ⧺ ms) a -> f (ns ⧺ ms) a -> f (ns ⧺ ms) a) -> ADFB ns f ms a
plusADFB :: forall (f :: [𝐍] -> Type -> Type) (ns :: [𝐍]) (ms :: [𝐍]) a. Plus (f (ns ⧺ ms) a) => ADFB ns f ms a -> ADFB ns f ms a -> ADFB ns f ms a
timesADFB :: forall (f :: [𝐍] -> Type -> Type) (ns :: [𝐍]) (ms :: [𝐍]) a. (Plus (f (ns ⧺ ms) a), Times (f (ns ⧺ ms) a)) => ADFB ns f ms a -> ADFB ns f ms a -> ADFB ns f ms a
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Lib.AD.ADF a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Lib.AD.ADF a)
instance (UVMHS.Lib.Pretty.Doc.Pretty a, UVMHS.Lib.Pretty.Doc.Pretty (a -> a -> a)) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.AD.ADB a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.AD.ADF a)
instance (UVMHS.Lib.Pretty.Doc.Pretty (f (ns UVMHS.Core.Static.⧺ ms) a), UVMHS.Lib.Pretty.Doc.Pretty (f (ns UVMHS.Core.Static.⧺ ms) a -> f (ns UVMHS.Core.Static.⧺ ms) a -> f (ns UVMHS.Core.Static.⧺ ms) a)) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.AD.ADFB ns f ms a)
instance UVMHS.Lib.Pretty.Doc.Pretty (f (ns UVMHS.Core.Static.⧺ ms) a) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.AD.ADFF ns f ms a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Lib.AD.ADF a)

module UVMHS.Lib.TreeNested
data 𝑇A a
𝑇A :: 𝐼 a -> 𝐼 (𝕊 ∧ 𝑇A a) -> 𝑇A a
[vals𝑇A] :: 𝑇A a -> 𝐼 a
[nest𝑇A] :: 𝑇A a -> 𝐼 (𝕊 ∧ 𝑇A a)
fold𝑇AWith :: Monoid b => (𝐼 a -> b) -> (𝕊 -> b -> b) -> 𝑇A a -> b
fold𝑇AOn :: Monoid b => 𝑇A a -> (𝐼 a -> b) -> (𝕊 -> b -> b) -> b
key𝑇A :: 𝕊 -> 𝑇A a -> 𝑇A a
val𝑇A :: a -> 𝑇A a
𝐤 :: 𝕊 -> 𝑇A a -> 𝑇A a
𝐯 :: a -> 𝑇A a
keys𝑇A :: 𝐿 𝕊 -> 𝑇A a -> 𝑇A a
data 𝑇D a
𝑇D :: 𝐼 a -> (𝕊 ⇰ 𝑇D a) -> 𝑇D a
[vals𝑇D] :: 𝑇D a -> 𝐼 a
[nest𝑇D] :: 𝑇D a -> 𝕊 ⇰ 𝑇D a
fold𝑇DWith :: Monoid b => (𝐼 a -> b) -> (𝕊 -> b -> b) -> 𝑇D a -> b
fold𝑇DOn :: Monoid b => 𝑇D a -> (𝐼 a -> b) -> (𝕊 -> b -> b) -> b
key𝑇D :: 𝕊 -> 𝑇D a -> 𝑇D a
val𝑇D :: a -> 𝑇D a
keys𝑇D :: 𝐿 𝕊 -> 𝑇D a -> 𝑇D a
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.TreeNested.𝑇A a)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.TreeNested.𝑇D a)
instance UVMHS.Core.Classes.Monoid.Eps (UVMHS.Lib.TreeNested.𝑇A a)
instance UVMHS.Core.Classes.Monoid.Eps (UVMHS.Lib.TreeNested.𝑇D a)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.TreeNested.𝑇A a)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.TreeNested.𝑇D a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.TreeNested.𝑇A a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.TreeNested.𝑇D a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.TreeNested.𝑇A a)
instance UVMHS.Lib.Pretty.Doc.Pretty a => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.TreeNested.𝑇D a)
instance UVMHS.Core.Classes.Monoid.Seqoid (UVMHS.Lib.TreeNested.𝑇A a)
instance UVMHS.Core.Classes.Monoid.Seqoid (UVMHS.Lib.TreeNested.𝑇D a)
instance UVMHS.Core.Classes.Monoid.Seq (UVMHS.Lib.TreeNested.𝑇A a)
instance UVMHS.Core.Classes.Monoid.Seq (UVMHS.Lib.TreeNested.𝑇D a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Lib.TreeNested.𝑇A a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Lib.TreeNested.𝑇D a)

module UVMHS.Lib.Window
data WindowL i a
ZerWindowL :: a -> WindowL i a
OneWindowL :: 𝔹 -> a -> i -> a -> WindowL i a
eWindowL :: a -> WindowL i a
iWindowL :: Null a => i -> WindowL i a
overflowL :: WindowL i a -> 𝔹
mapWindowL :: (i -> j) -> (a -> b) -> WindowL i a -> WindowL j b
data WindowR i a
ZerWindowR :: a -> WindowR i a
OneWindowR :: 𝔹 -> a -> i -> a -> WindowR i a
eWindowR :: a -> WindowR i a
iWindowR :: Null a => i -> WindowR i a
overflowR :: WindowR i a -> 𝔹
mapWindowR :: (i -> j) -> (a -> b) -> WindowR i a -> WindowR j b
renderWindowL :: WindowL Doc Doc -> Doc
renderWindowR :: WindowR Doc Doc -> Doc
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Window.WindowL i a)
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Window.WindowR i a)
instance (GHC.Classes.Eq i, GHC.Classes.Eq a) => GHC.Classes.Eq (UVMHS.Lib.Window.WindowL i a)
instance (GHC.Classes.Eq i, GHC.Classes.Eq a) => GHC.Classes.Eq (UVMHS.Lib.Window.WindowR i a)
instance UVMHS.Core.Classes.Monoid.Monoid a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Window.WindowL i a)
instance UVMHS.Core.Classes.Monoid.Monoid a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Window.WindowR i a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Window.WindowL i a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Window.WindowR i a)
instance (GHC.Classes.Ord i, GHC.Classes.Ord a) => GHC.Classes.Ord (UVMHS.Lib.Window.WindowL i a)
instance (GHC.Classes.Ord i, GHC.Classes.Ord a) => GHC.Classes.Ord (UVMHS.Lib.Window.WindowR i a)
instance (UVMHS.Lib.Pretty.Doc.Pretty a, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔹, UVMHS.Lib.Pretty.Doc.Pretty i) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Window.WindowL i a)
instance (UVMHS.Lib.Pretty.Doc.Pretty a, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔹, UVMHS.Lib.Pretty.Doc.Pretty i) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Window.WindowR i a)
instance (GHC.Show.Show i, GHC.Show.Show a) => GHC.Show.Show (UVMHS.Lib.Window.WindowL i a)
instance (GHC.Show.Show i, GHC.Show.Show a) => GHC.Show.Show (UVMHS.Lib.Window.WindowR i a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Lib.Window.WindowL a a)
instance UVMHS.Core.Classes.Collections.ToIter a (UVMHS.Lib.Window.WindowR a a)

module UVMHS.Lib.Parser.ParserError
data ParserErrorInfo
ParserErrorInfo :: WindowR Doc Doc -> WindowR Doc Doc -> 𝕊 -> 𝐼 𝕊 -> ParserErrorInfo
[parserErrorInfoPrefix] :: ParserErrorInfo -> WindowR Doc Doc
[parserErrorInfoContext] :: ParserErrorInfo -> WindowR Doc Doc
[parserErrorInfoStackHead] :: ParserErrorInfo -> 𝕊
[parserErrorInfoStackTail] :: ParserErrorInfo -> 𝐼 𝕊
data ParserError (t :: k)
ParserError :: AddBT Loc -> WindowR Doc Doc -> WindowL Doc Doc -> 𝐼 ParserErrorInfo -> ParserError (t :: k)
[parserErrorTokenLoc] :: ParserError (t :: k) -> AddBT Loc
[parserErrorTokenContext] :: ParserError (t :: k) -> WindowR Doc Doc
[parserErrorTokenSuffix] :: ParserError (t :: k) -> WindowL Doc Doc
[parserErrorFailures] :: ParserError (t :: k) -> 𝐼 ParserErrorInfo
data ParserErrorStackTraces
ParserErrorStackTraces :: 𝑃 𝕊 -> (𝕊 ⇰ ParserErrorStackTraces) -> ParserErrorStackTraces
[parserErrorStackTracesMessages] :: ParserErrorStackTraces -> 𝑃 𝕊
[parserErrorStackTracesChain] :: ParserErrorStackTraces -> 𝕊 ⇰ ParserErrorStackTraces
parserErrorStackTracesMessagesL :: ParserErrorStackTraces ⟢ 𝑃 𝕊
parserErrorStackTracesChainL :: ParserErrorStackTraces ⟢ (𝕊 ⇰ ParserErrorStackTraces)
stackTraces :: 𝕊 -> 𝐼 𝕊 -> ParserErrorStackTraces
parserErrorFailuresMap :: 𝐼 ParserErrorInfo -> (𝕊 ∧ 𝔹) ⇰ ((WindowR Doc Doc ∧ WindowR Doc Doc) ∧ ParserErrorStackTraces)
displaySourceError :: forall {k} (t :: k). 𝕊 -> AddNull (ParserError t) -> Doc
displayErrorTraces :: ParserErrorStackTraces -> Doc
instance forall k (t :: k). UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.ParserError.ParserError t)
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Lib.Parser.ParserError.ParserErrorStackTraces
instance GHC.Classes.Eq UVMHS.Lib.Parser.ParserError.ParserErrorStackTraces
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Lib.Parser.ParserError.ParserErrorStackTraces
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Lib.Parser.ParserError.ParserErrorStackTraces
instance GHC.Classes.Ord UVMHS.Lib.Parser.ParserError.ParserErrorStackTraces
instance (UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑃 UVMHS.Core.Init.𝕊), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝕊 UVMHS.Core.Init.⇰ UVMHS.Lib.Parser.ParserError.ParserErrorStackTraces)) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.ParserError.ParserErrorStackTraces

module UVMHS.Lib.Parser.ParserContext
data ParserContext
ParserContext :: LocRange -> WindowL Doc Doc -> WindowR Doc Doc -> WindowR Doc Doc -> ParserContext
[parserContextLocRange] :: ParserContext -> LocRange
[parserContextDisplayL] :: ParserContext -> WindowL Doc Doc
[parserContextDisplayR] :: ParserContext -> WindowR Doc Doc
[parserContextError] :: ParserContext -> WindowR Doc Doc
parserContextLocRangeL :: ParserContext ⟢ LocRange
parserContextDisplayLL :: ParserContext ⟢ WindowL Doc Doc
parserContextDisplayRL :: ParserContext ⟢ WindowR Doc Doc
parserContextErrorL :: ParserContext ⟢ WindowR Doc Doc
formatParserContext :: Formats -> ParserContext -> ParserContext
data SrcCxt
SrcCxt :: 𝕊 -> LocRange -> WindowR Doc Doc -> WindowL Doc Doc -> WindowL Doc Doc -> SrcCxt
[srcCxtSourceName] :: SrcCxt -> 𝕊
[srcCxtLocRange] :: SrcCxt -> LocRange
[srcCxtPrefix] :: SrcCxt -> WindowR Doc Doc
[srcCxtContext] :: SrcCxt -> WindowL Doc Doc
[srcCxtSuffix] :: SrcCxt -> WindowL Doc Doc
srcCxt₀ :: SrcCxt
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Parser.ParserContext.ParserContext
instance GHC.Classes.Eq UVMHS.Lib.Parser.ParserContext.SrcCxt
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Parser.ParserContext.ParserContext
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Parser.ParserContext.ParserContext
instance GHC.Classes.Ord UVMHS.Lib.Parser.ParserContext.SrcCxt
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Loc.LocRange, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Window.WindowL UVMHS.Lib.Pretty.Doc.Doc UVMHS.Lib.Pretty.Doc.Doc), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Window.WindowR UVMHS.Lib.Pretty.Doc.Doc UVMHS.Lib.Pretty.Doc.Doc)) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.ParserContext.ParserContext
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.ParserContext.SrcCxt
instance GHC.Show.Show UVMHS.Lib.Parser.ParserContext.SrcCxt

module UVMHS.Lib.Parser.ParserInput
data PreParserToken t
PreParserToken :: t -> 𝔹 -> ParserContext -> PreParserToken t
[preParserTokenValue] :: PreParserToken t -> t
[preParserTokenSkip] :: PreParserToken t -> 𝔹
[preParserTokenContext] :: PreParserToken t -> ParserContext
preParserTokenValueL :: PreParserToken t ⟢ t
preParserTokenSkipL :: PreParserToken t ⟢ 𝔹
preParserTokenContextL :: PreParserToken t ⟢ ParserContext
data ParserToken t
ParserToken :: t -> 𝔹 -> ParserContext -> WindowL Doc Doc -> ParserToken t
[parserTokenValue] :: ParserToken t -> t
[parserTokenSkip] :: ParserToken t -> 𝔹
[parserTokenContext] :: ParserToken t -> ParserContext
[parserTokenSuffix] :: ParserToken t -> WindowL Doc Doc
parserTokenValueL :: ParserToken t ⟢ t
parserTokenSkipL :: ParserToken t ⟢ 𝔹
parserTokenContextL :: ParserToken t ⟢ ParserContext
parserTokenSuffixL :: ParserToken t ⟢ WindowL Doc Doc
renderNLDisplay :: Doc
renderNLError :: Doc
renderEOFDisplay :: Doc
renderEOFError :: Doc
eofContext :: AddBT Loc -> ParserContext
nlContext :: Loc -> ParserContext
charContext :: Loc -> ℂ -> ParserContext
preTokens :: 𝕊 -> 𝕍 (PreParserToken ℂ)
finalizeTokens :: 𝕍 (PreParserToken t) -> 𝕍 (ParserToken t)
tokens :: 𝕊 -> 𝕍 (ParserToken ℂ)
instance (UVMHS.Lib.Pretty.Doc.Pretty t, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔹, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.ParserContext.ParserContext, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Window.WindowL UVMHS.Lib.Pretty.Doc.Doc UVMHS.Lib.Pretty.Doc.Doc)) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.ParserInput.ParserToken t)
instance (UVMHS.Lib.Pretty.Doc.Pretty t, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔹, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.ParserContext.ParserContext) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.ParserInput.PreParserToken t)

module UVMHS.Lib.Parser.Regex
class Classified c t | t -> c
classify :: Classified c t => t -> c
data RegexResult o u
RegexResult :: ℕ64 -> Formats -> 𝑂 o -> u -> RegexResult o u
[regexResultLevel] :: RegexResult o u -> ℕ64
[regexResultFormats] :: RegexResult o u -> Formats
[regexResultOutput] :: RegexResult o u -> 𝑂 o
[regexResultUpdate] :: RegexResult o u -> u
newtype RegexInfo o u
RegexInfo :: 𝑂 (RegexResult o u) -> RegexInfo o u
[regexInfoResult] :: RegexInfo o u -> 𝑂 (RegexResult o u)
newtype Regex c t o u
Regex :: 𝐴 (RegexInfo o u) (RegexU c t o u) -> Regex c t o u
[unRegex] :: Regex c t o u -> 𝐴 (RegexInfo o u) (RegexU c t o u)
data RegexU c t o u
NullR :: RegexU c t o u
ResR :: RegexResult o u -> RegexU c t o u
AtomR :: RegexResult o u -> RegexAtom c t o u -> RegexU c t o u
SumsR :: 𝑃 (Regex c t o u) -> RegexU c t o u
SeqsR :: 𝐿 (Regex c t o u) -> RegexU c t o u
StarR :: RegexResult o u -> Regex c t o u -> RegexU c t o u
data RegexAtom c t (o :: k) (u :: k1)
TokRA :: t -> RegexAtom c t (o :: k) (u :: k1)
NTokRA :: 𝑃 t -> RegexAtom c t (o :: k) (u :: k1)
ClassRA :: c -> RegexAtom c t (o :: k) (u :: k1)
nullRegex :: Zero u => Regex c t o u
resRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => RegexResult o u -> Regex c t o u
epsRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => Regex c t o u
retRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => ℕ64 -> Formats -> 𝑂 o -> u -> Regex c t o u
outRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => ℕ64 -> Formats -> o -> Regex c t o u
lepsRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => ℕ64 -> Regex c t o u
fepsRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => Formats -> Regex c t o u
oepsRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => o -> Regex c t o u
uepsRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => u -> Regex c t o u
atomRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => RegexAtom c t o u -> Regex c t o u
tokRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => t -> Regex c t o u
ntokRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => 𝑃 t -> Regex c t o u
classRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => c -> Regex c t o u
consEpsRegex :: (Ord c, Ord t, Ord o, Ord u, Plus u) => RegexResult o u -> Regex c t o u -> Regex c t o u
consEpsRegexU :: (Ord c, Ord t, Ord o, Ord u, Plus u) => RegexResult o u -> RegexU c t o u -> RegexU c t o u
snocEpsRegex :: (Ord c, Ord t, Ord o, Ord u, Plus u) => RegexResult o u -> Regex c t o u -> Regex c t o u
snocEpsRegexU :: (Ord c, Ord t, Ord o, Ord u, Plus u) => RegexResult o u -> RegexU c t o u -> RegexU c t o u
sumRegex :: (Ord c, Ord t, Ord o, Ord u, Plus u) => Regex c t o u -> Regex c t o u -> Regex c t o u
seqRegex :: (Ord c, Ord t, Ord o, Ord u, Additive u) => Regex c t o u -> Regex c t o u -> Regex c t o u
starRegex :: (Ord c, Ord t, Ord o, Ord u, Zero u) => Regex c t o u -> Regex c t o u
derRegex :: (Ord c, Ord t, Classified c t, Ord o, Ord u, Additive u) => (t ∨ c) -> Regex c t o u -> Regex c t o u
derRegexAtom :: (Ord c, Ord t, Classified c t, Ord o, Ord u, Additive u) => (t ∨ c) -> RegexAtom c t o u -> Regex c t o u
derRegexSequence :: (Ord t, Ord c, Classified c t, Ord o, Ord u, Additive u) => (t ∨ c) -> 𝐿 (Regex c t o u) -> Regex c t o u
regexLits :: Ord t => Regex c t o u -> 𝑃 t
regexLitsAtom :: forall {k1} {k2} t c (o :: k1) (u :: k2). Ord t => RegexAtom c t o u -> 𝑃 t
data RegexState c t o u
RegexState :: ℕ64 -> (Regex c t o u ⇰ ℕ64) -> ((t ∨ c) ⇰ (ℕ64 ⇰ ℕ64)) -> (ℕ64 ⇰ 𝑂 (RegexResult o u)) -> (ℕ64 ⇰ 𝔹) -> RegexState c t o u
[regexStateNextID] :: RegexState c t o u -> ℕ64
[regexStateMap] :: RegexState c t o u -> Regex c t o u ⇰ ℕ64
[regexStateTransitions] :: RegexState c t o u -> (t ∨ c) ⇰ (ℕ64 ⇰ ℕ64)
[regexStateResults] :: RegexState c t o u -> ℕ64 ⇰ 𝑂 (RegexResult o u)
[regexStateDead] :: RegexState c t o u -> ℕ64 ⇰ 𝔹
regexStateNextIDL :: RegexState c t o u ⟢ ℕ64
regexStateMapL :: RegexState c t o u ⟢ (Regex c t o u ⇰ ℕ64)
regexStateTransitionsL :: RegexState c t o u ⟢ ((t ∨ c) ⇰ (ℕ64 ⇰ ℕ64))
regexStateResultsL :: RegexState c t o u ⟢ (ℕ64 ⇰ 𝑂 (RegexResult o u))
regexStateDeadL :: RegexState c t o u ⟢ (ℕ64 ⇰ 𝔹)
regexState₀ :: RegexState c t o u
data DFA c t o u
DFA :: 𝑃 t -> ℕ64 -> ((t ∨ c) ⇰ 𝕍 ℕ64) -> 𝕍 (𝑂 (RegexResult o u)) -> 𝕍 𝔹 -> DFA c t o u
[dfaLits] :: DFA c t o u -> 𝑃 t
[dfaStart] :: DFA c t o u -> ℕ64
[dfaTransitions] :: DFA c t o u -> (t ∨ c) ⇰ 𝕍 ℕ64
[dfaSuccess] :: DFA c t o u -> 𝕍 (𝑂 (RegexResult o u))
[dfaDead] :: DFA c t o u -> 𝕍 𝔹
compileRegex :: forall c t o u. (Pretty t, Pretty o, Pretty u, Ord c, Ord t, Classified c t, All c, Ord o, Ord u, Additive u) => Regex c t o u -> DFA c t o u
data LexDFAState t
LexDFAState :: WindowR Doc Doc -> ParserContext -> 𝑆 (ParserToken t) -> 𝐼C t -> LexDFAState t
[lexDFAStatePrefix] :: LexDFAState t -> WindowR Doc Doc
[lexDFAStateContext] :: LexDFAState t -> ParserContext
[lexDFAStateInput] :: LexDFAState t -> 𝑆 (ParserToken t)
[lexDFAStateTokens] :: LexDFAState t -> 𝐼C t
data Lexer c t o u w
Lexer :: (u -> DFA c t o u) -> (𝐼C t -> 𝑂 o -> 𝔹 ∧ w) -> u -> Lexer c t o u w
[lexerDFA] :: Lexer c t o u w -> u -> DFA c t o u
[lexerMkToken] :: Lexer c t o u w -> 𝐼C t -> 𝑂 o -> 𝔹 ∧ w
[lexerInitState] :: Lexer c t o u w -> u
tokenize :: forall c t o u w. (Show u, Ord c, Ord t, Pretty t, Classified c t, Eq o, Eq u, Plus u) => Lexer c t o u w -> 𝕊 -> 𝕍 (ParserToken t) -> Doc ∨ 𝕍 (PreParserToken w)
tokenizeFIO :: forall c t o u w w'. (Show u, Ord c, Ord t, Pretty t, Classified c t, Eq o, Eq u, Plus u) => Lexer c t o u w -> 𝕊 -> (𝕍 (PreParserToken w) -> 𝕍 (PreParserToken w')) -> 𝕍 (ParserToken t) -> IO (𝕍 (ParserToken w'))
tokenizeIO :: forall c t o u w. (Show u, Ord c, Ord t, Pretty t, Classified c t, Eq o, Eq u, Plus u) => Lexer c t o u w -> 𝕊 -> 𝕍 (ParserToken t) -> IO (𝕍 (ParserToken w))
tokenizeFIOMain :: forall c t o u w w'. (Show u, Ord c, Ord t, Pretty t, Classified c t, Eq o, Eq u, Plus u, Pretty w') => Lexer c t o u w -> 𝕊 -> (𝕍 (PreParserToken w) -> 𝕍 (PreParserToken w')) -> 𝕍 (ParserToken t) -> IO ()
tokenizeIOMain :: forall c t o u w. (Show u, Ord c, Ord t, Pretty t, Classified c t, Eq o, Eq u, Plus u, Pretty w) => Lexer c t o u w -> 𝕊 -> 𝕍 (ParserToken t) -> IO ()
data CharClass
LetterClass :: CharClass
NumberClass :: CharClass
SpaceClass :: CharClass
NewlineClass :: CharClass
OtherClass :: CharClass
lWord :: (Zero u, Ord o, Ord u, Additive u) => 𝕊 -> Regex CharClass ℂ o u
lSpaceOrNl :: (Zero u, Ord o, Ord u, Additive u) => Regex CharClass ℂ o u
lSpace :: (Zero u, Ord o, Ord u, Additive u) => Regex CharClass ℂ o u
lNl :: (Zero u, Ord o, Ord u, Additive u) => Regex CharClass ℂ o u
lName :: (Zero u, Ord u, Ord o, Additive u) => Regex CharClass ℂ o u
lNatPre :: (Zero u, Ord u, Ord o, Additive u) => Regex CharClass ℂ o u
lNat :: (Zero u, Ord u, Ord o, Additive u) => Regex CharClass ℂ o u
lNatCoded :: (Zero u, Ord u, Ord o, Additive u) => Regex CharClass ℂ o u
lIntPre :: (Zero u, Ord o, Ord u, Additive u) => Regex CharClass ℂ o u
lInt :: (Zero u, Ord o, Ord u, Additive u) => Regex CharClass ℂ o u
lDbl :: (Zero u, Ord o, Ord u, Additive u) => Regex CharClass ℂ o u
lString :: (Zero u, Ord o, Ord u, Additive u) => Regex CharClass ℂ o u
lComment :: Ord o => Regex CharClass ℂ o ℕ64
lCommentMLOpen :: Ord o => Regex CharClass ℂ o ℕ64
lCommentMLBodyOpen :: Ord o => Regex CharClass ℂ o ℕ64
lCommentMLBodyClose :: Ord o => Regex CharClass ℂ o ℕ64
lCommentMLBody :: Ord o => Regex CharClass ℂ o ℕ64
data TokenClassBasic
SpaceCBasic :: TokenClassBasic
CommentCBasic :: TokenClassBasic
SyntaxCBasic :: TokenClassBasic
StringCBasic :: TokenClassBasic
NameCBasic :: TokenClassBasic
NaturalCBasic :: TokenClassBasic
IntegerCBasic :: TokenClassBasic
DoubleCBasic :: TokenClassBasic
CharCBasic :: TokenClassBasic
spaceCBasicL :: TokenClassBasic ⌲ ()
commentCBasicL :: TokenClassBasic ⌲ ()
syntaxCBasicL :: TokenClassBasic ⌲ ()
stringCBasicL :: TokenClassBasic ⌲ ()
nameCBasicL :: TokenClassBasic ⌲ ()
naturalCBasicL :: TokenClassBasic ⌲ ()
integerCBasicL :: TokenClassBasic ⌲ ()
doubleCBasicL :: TokenClassBasic ⌲ ()
charCBasicL :: TokenClassBasic ⌲ ()
data TokenBasic
SpaceTBasic :: 𝕊 -> TokenBasic
CommentTBasic :: 𝕊 -> TokenBasic
SyntaxTBasic :: 𝕊 -> TokenBasic
StringTBasic :: 𝕊 -> TokenBasic
NameTBasic :: 𝕊 -> TokenBasic
NaturalTBasic :: ℕ -> TokenBasic
IntegerTBasic :: ℤ -> TokenBasic
DoubleTBasic :: 𝔻 -> TokenBasic
CharTBasic :: ℂ -> TokenBasic
spaceTBasicL :: TokenBasic ⌲ 𝕊
commentTBasicL :: TokenBasic ⌲ 𝕊
syntaxTBasicL :: TokenBasic ⌲ 𝕊
stringTBasicL :: TokenBasic ⌲ 𝕊
nameTBasicL :: TokenBasic ⌲ 𝕊
naturalTBasicL :: TokenBasic ⌲ ℕ
integerTBasicL :: TokenBasic ⌲ ℤ
doubleTBasicL :: TokenBasic ⌲ 𝔻
charTBasicL :: TokenBasic ⌲ ℂ
mkTokenBasic :: 𝐼C ℂ -> 𝑂 TokenClassBasic -> 𝔹 ∧ TokenBasic
data LexerBasicSyntax
LexerBasicSyntax :: 𝑃 𝕊 -> 𝑃 𝕊 -> 𝑃 𝕊 -> 𝑃 𝕊 -> LexerBasicSyntax

-- | punctuation (default color gray)
[lexerBasicSyntaxPuns] :: LexerBasicSyntax -> 𝑃 𝕊

-- | keywords (default color bold yellow)
[lexerBasicSyntaxKeys] :: LexerBasicSyntax -> 𝑃 𝕊

-- | primitives (default color blue)
[lexerBasicSyntaxPrms] :: LexerBasicSyntax -> 𝑃 𝕊

-- | operators (default color teal)
[lexerBasicSyntaxOprs] :: LexerBasicSyntax -> 𝑃 𝕊
lexerBasicSyntaxPunsL :: LexerBasicSyntax ⟢ 𝑃 𝕊
lexerBasicSyntaxKeysL :: LexerBasicSyntax ⟢ 𝑃 𝕊
lexerBasicSyntaxPrmsL :: LexerBasicSyntax ⟢ 𝑃 𝕊
lexerBasicSyntaxOprsL :: LexerBasicSyntax ⟢ 𝑃 𝕊
lSyntaxBasic :: (Ord c, Ord u, Additive u) => LexerBasicSyntax -> Regex CharClass ℂ c u
lTokenBasic :: LexerBasicSyntax -> Regex CharClass ℂ TokenClassBasic ℕ64
lCommentMLBasic :: Regex CharClass ℂ TokenClassBasic ℕ64
dfaBasic :: LexerBasicSyntax -> ℕ64 -> DFA CharClass ℂ TokenClassBasic ℕ64
lexerBasic :: LexerBasicSyntax -> Lexer CharClass ℂ TokenClassBasic ℕ64 TokenBasic
data IndentCommand
OpenIC :: IndentCommand
CloseIC :: IndentCommand
NewlineIC :: IndentCommand
blockifyTokens :: 𝐿 (AddBT Loc) -> (t -> 𝔹) -> (t -> 𝔹) -> (IndentCommand -> t) -> 𝕍 (PreParserToken t) -> 𝕍 (PreParserToken t)
blockifyTokensTL :: (t -> 𝔹) -> (t -> 𝔹) -> (IndentCommand -> t) -> 𝕍 (PreParserToken t) -> 𝕍 (PreParserToken t)
data TokenClassWSBasic
SpaceCWSBasic :: TokenClassWSBasic
NewlineCWSBasic :: TokenClassWSBasic
CommentCWSBasic :: TokenClassWSBasic
SyntaxCWSBasic :: TokenClassWSBasic
BlockCWSBasic :: TokenClassWSBasic
StringCWSBasic :: TokenClassWSBasic
NameCWSBasic :: TokenClassWSBasic
NaturalCWSBasic :: TokenClassWSBasic
IntegerCWSBasic :: TokenClassWSBasic
DoubleCWSBasic :: TokenClassWSBasic
spaceCWSBasicL :: TokenClassWSBasic ⌲ ()
newlineCWSBasicL :: TokenClassWSBasic ⌲ ()
commentCWSBasicL :: TokenClassWSBasic ⌲ ()
syntaxCWSBasicL :: TokenClassWSBasic ⌲ ()
blockCWSBasicL :: TokenClassWSBasic ⌲ ()
stringCWSBasicL :: TokenClassWSBasic ⌲ ()
nameCWSBasicL :: TokenClassWSBasic ⌲ ()
naturalCWSBasicL :: TokenClassWSBasic ⌲ ()
integerCWSBasicL :: TokenClassWSBasic ⌲ ()
doubleCWSBasicL :: TokenClassWSBasic ⌲ ()
data TokenWSBasic
SpaceTWSBasic :: 𝕊 -> TokenWSBasic
NewlineTWSBasic :: 𝕊 -> TokenWSBasic
CommentTWSBasic :: 𝕊 -> TokenWSBasic
SyntaxTWSBasic :: 𝕊 -> TokenWSBasic
BlockTWSBasic :: 𝕊 -> TokenWSBasic
StringTWSBasic :: 𝕊 -> TokenWSBasic
NameTWSBasic :: 𝕊 -> TokenWSBasic
NaturalTWSBasic :: ℕ -> TokenWSBasic
IntegerTWSBasic :: ℤ -> TokenWSBasic
DoubleTWSBasic :: 𝔻 -> TokenWSBasic
OpenTWSBasic :: TokenWSBasic
CloseTWSBasic :: TokenWSBasic
DelimiterTWSBasic :: TokenWSBasic
spaceTWSBasicL :: TokenWSBasic ⌲ 𝕊
newlineTWSBasicL :: TokenWSBasic ⌲ 𝕊
commentTWSBasicL :: TokenWSBasic ⌲ 𝕊
syntaxTWSBasicL :: TokenWSBasic ⌲ 𝕊
blockTWSBasicL :: TokenWSBasic ⌲ 𝕊
stringTWSBasicL :: TokenWSBasic ⌲ 𝕊
nameTWSBasicL :: TokenWSBasic ⌲ 𝕊
naturalTWSBasicL :: TokenWSBasic ⌲ ℕ
integerTWSBasicL :: TokenWSBasic ⌲ ℤ
doubleTWSBasicL :: TokenWSBasic ⌲ 𝔻
openTWSBasicL :: TokenWSBasic ⌲ ()
closeTWSBasicL :: TokenWSBasic ⌲ ()
delimiterTWSBasicL :: TokenWSBasic ⌲ ()
mkTokenWSBasic :: 𝐼C ℂ -> 𝑂 TokenClassWSBasic -> 𝔹 ∧ TokenWSBasic
lBlocksWSBasic :: (Ord u, Additive u) => 𝑃 𝕊 -> Regex CharClass ℂ TokenClassWSBasic u
lTokenWSBasic :: LexerWSBasicSyntax -> Regex CharClass ℂ TokenClassWSBasic ℕ64
lCommentMLWSBasic :: Regex CharClass ℂ TokenClassWSBasic ℕ64
dfaWSBasic :: LexerWSBasicSyntax -> ℕ64 -> DFA CharClass ℂ TokenClassWSBasic ℕ64
data LexerWSBasicSyntax
LexerWSBasicSyntax :: LexerBasicSyntax -> 𝑃 𝕊 -> LexerWSBasicSyntax
[lexerWSBasicSyntaxBase] :: LexerWSBasicSyntax -> LexerBasicSyntax

-- | block keywords (default color bold yellow)
[lexerWSBasicSyntaxBlocks] :: LexerWSBasicSyntax -> 𝑃 𝕊
lexerWSBasicSyntaxBaseL :: LexerWSBasicSyntax ⟢ LexerBasicSyntax
lexerWSBasicSyntaxBlocksL :: LexerWSBasicSyntax ⟢ 𝑃 𝕊
lexerWSBasic :: LexerWSBasicSyntax -> Lexer CharClass ℂ TokenClassWSBasic ℕ64 TokenWSBasic
mkIndentTokenWSBasic :: IndentCommand -> TokenWSBasic
blockifyTokensWSBasic :: 𝕍 (PreParserToken TokenWSBasic) -> 𝕍 (PreParserToken TokenWSBasic)
instance UVMHS.Core.Classes.Collections.All UVMHS.Lib.Parser.Regex.CharClass
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Parser.Regex.LexerBasicSyntax
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Parser.Regex.LexerWSBasicSyntax
instance (GHC.Classes.Ord c, GHC.Classes.Ord t, GHC.Classes.Ord o, GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Plus u) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance GHC.Classes.Ord u => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance GHC.Classes.Ord u => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance UVMHS.Lib.Parser.Regex.Classified UVMHS.Lib.Parser.Regex.CharClass UVMHS.Core.Init.ℂ
instance (GHC.Classes.Ord c, GHC.Classes.Ord t, GHC.Classes.Ord o, GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Zero u) => UVMHS.Core.Classes.Monoid.Eps (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance UVMHS.Core.Classes.Arithmetic.Zero u => UVMHS.Core.Classes.Monoid.Eps (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance UVMHS.Core.Classes.Arithmetic.Zero u => UVMHS.Core.Classes.Monoid.Eps (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance GHC.Classes.Eq UVMHS.Lib.Parser.Regex.CharClass
instance GHC.Classes.Eq UVMHS.Lib.Parser.Regex.LexerBasicSyntax
instance GHC.Classes.Eq UVMHS.Lib.Parser.Regex.LexerWSBasicSyntax
instance (GHC.Classes.Eq o, GHC.Classes.Eq u, GHC.Classes.Eq t, GHC.Classes.Eq c) => GHC.Classes.Eq (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance forall c t k1 (o :: k1) k2 (u :: k2). (GHC.Classes.Eq t, GHC.Classes.Eq c) => GHC.Classes.Eq (UVMHS.Lib.Parser.Regex.RegexAtom c t o u)
instance (GHC.Classes.Eq o, GHC.Classes.Eq u) => GHC.Classes.Eq (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance (GHC.Classes.Eq o, GHC.Classes.Eq u) => GHC.Classes.Eq (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance (GHC.Classes.Eq o, GHC.Classes.Eq u, GHC.Classes.Eq t, GHC.Classes.Eq c) => GHC.Classes.Eq (UVMHS.Lib.Parser.Regex.RegexU c t o u)
instance GHC.Classes.Eq UVMHS.Lib.Parser.Regex.TokenBasic
instance GHC.Classes.Eq UVMHS.Lib.Parser.Regex.TokenClassBasic
instance GHC.Classes.Eq UVMHS.Lib.Parser.Regex.TokenClassWSBasic
instance GHC.Classes.Eq UVMHS.Lib.Parser.Regex.TokenWSBasic
instance (GHC.Classes.Ord c, GHC.Classes.Ord t, GHC.Classes.Ord o, GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Additive u) => UVMHS.Core.Classes.Monoid.Kleene (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Parser.Regex.LexerBasicSyntax
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Parser.Regex.LexerWSBasicSyntax
instance (GHC.Classes.Ord c, GHC.Classes.Ord t, GHC.Classes.Ord o, GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Additive u) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance (GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Zero u) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance (GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Zero u) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Parser.Regex.LexerBasicSyntax
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Parser.Regex.LexerWSBasicSyntax
instance UVMHS.Core.Classes.Arithmetic.Zero u => UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance UVMHS.Core.Classes.Arithmetic.Zero u => UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance UVMHS.Core.Classes.Arithmetic.Zero u => UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance GHC.Classes.Ord UVMHS.Lib.Parser.Regex.CharClass
instance GHC.Classes.Ord UVMHS.Lib.Parser.Regex.LexerBasicSyntax
instance GHC.Classes.Ord UVMHS.Lib.Parser.Regex.LexerWSBasicSyntax
instance (GHC.Classes.Ord o, GHC.Classes.Ord u, GHC.Classes.Ord t, GHC.Classes.Ord c) => GHC.Classes.Ord (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance forall c t k1 (o :: k1) k2 (u :: k2). (GHC.Classes.Ord t, GHC.Classes.Ord c) => GHC.Classes.Ord (UVMHS.Lib.Parser.Regex.RegexAtom c t o u)
instance (GHC.Classes.Ord o, GHC.Classes.Ord u) => GHC.Classes.Ord (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance (GHC.Classes.Ord o, GHC.Classes.Ord u) => GHC.Classes.Ord (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance (GHC.Classes.Ord o, GHC.Classes.Ord u, GHC.Classes.Ord t, GHC.Classes.Ord c) => GHC.Classes.Ord (UVMHS.Lib.Parser.Regex.RegexU c t o u)
instance GHC.Classes.Ord UVMHS.Lib.Parser.Regex.TokenBasic
instance GHC.Classes.Ord UVMHS.Lib.Parser.Regex.TokenClassBasic
instance GHC.Classes.Ord UVMHS.Lib.Parser.Regex.TokenClassWSBasic
instance GHC.Classes.Ord UVMHS.Lib.Parser.Regex.TokenWSBasic
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Regex.CharClass
instance (UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑃 t), UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ64, UVMHS.Lib.Pretty.Doc.Pretty ((t UVMHS.Core.Init.∨ c) UVMHS.Core.Init.⇰ UVMHS.Core.Vector.𝕍 UVMHS.Core.Init.ℕ64), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Vector.𝕍 (UVMHS.Core.Init.𝑂 (UVMHS.Lib.Parser.Regex.RegexResult o u))), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Vector.𝕍 UVMHS.Core.Init.𝔹)) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.DFA c t o u)
instance (UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Window.WindowR UVMHS.Lib.Pretty.Doc.Doc UVMHS.Lib.Pretty.Doc.Doc), UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.ParserContext.ParserContext, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑆 (UVMHS.Lib.Parser.ParserInput.ParserToken t)), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Sized.𝐼C t)) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.LexDFAState t)
instance forall k1 k2 t c (o :: k1) (u :: k2). (UVMHS.Lib.Pretty.Doc.Pretty t, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑃 t), UVMHS.Lib.Pretty.Doc.Pretty c) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.RegexAtom c t o u)
instance UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑂 (UVMHS.Lib.Parser.Regex.RegexResult o u)) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ64, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Pretty.Annotation.Formats, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑂 o), UVMHS.Lib.Pretty.Doc.Pretty u) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance (UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.RegexResult o u), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.RegexAtom c t o u), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑃 (UVMHS.Lib.Parser.Regex.Regex c t o u)), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝐿 (UVMHS.Lib.Parser.Regex.Regex c t o u)), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.Regex c t o u)) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Regex.RegexU c t o u)
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔻, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℂ) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Regex.TokenBasic
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Regex.TokenClassBasic
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Regex.TokenClassWSBasic
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℕ, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔻) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Regex.TokenWSBasic
instance (GHC.Classes.Ord c, GHC.Classes.Ord t, GHC.Classes.Ord o, GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Additive u) => UVMHS.Core.Classes.Monoid.Seq (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance (GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Plus u) => UVMHS.Core.Classes.Monoid.Seq (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance (GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Plus u) => UVMHS.Core.Classes.Monoid.Seq (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance (GHC.Classes.Ord c, GHC.Classes.Ord t, GHC.Classes.Ord o, GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Additive u) => UVMHS.Core.Classes.Monoid.Seqoid (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance (GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Additive u) => UVMHS.Core.Classes.Monoid.Seqoid (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance (GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Additive u) => UVMHS.Core.Classes.Monoid.Seqoid (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance GHC.Show.Show UVMHS.Lib.Parser.Regex.CharClass
instance GHC.Show.Show UVMHS.Lib.Parser.Regex.LexerBasicSyntax
instance GHC.Show.Show UVMHS.Lib.Parser.Regex.LexerWSBasicSyntax
instance (GHC.Show.Show o, GHC.Show.Show u, GHC.Show.Show t, GHC.Show.Show c) => GHC.Show.Show (UVMHS.Lib.Parser.Regex.Regex c t o u)
instance forall c t k1 (o :: k1) k2 (u :: k2). (GHC.Show.Show t, GHC.Show.Show c) => GHC.Show.Show (UVMHS.Lib.Parser.Regex.RegexAtom c t o u)
instance (GHC.Show.Show o, GHC.Show.Show u) => GHC.Show.Show (UVMHS.Lib.Parser.Regex.RegexInfo o u)
instance (GHC.Show.Show o, GHC.Show.Show u) => GHC.Show.Show (UVMHS.Lib.Parser.Regex.RegexResult o u)
instance (GHC.Show.Show o, GHC.Show.Show u, GHC.Show.Show t, GHC.Show.Show c) => GHC.Show.Show (UVMHS.Lib.Parser.Regex.RegexU c t o u)
instance GHC.Show.Show UVMHS.Lib.Parser.Regex.TokenBasic
instance GHC.Show.Show UVMHS.Lib.Parser.Regex.TokenClassBasic
instance GHC.Show.Show UVMHS.Lib.Parser.Regex.TokenClassWSBasic
instance GHC.Show.Show UVMHS.Lib.Parser.Regex.TokenWSBasic
instance (GHC.Classes.Ord c, GHC.Classes.Ord t, GHC.Classes.Ord o, GHC.Classes.Ord u, UVMHS.Core.Classes.Arithmetic.Zero u) => UVMHS.Core.Classes.Monoid.Star (UVMHS.Lib.Parser.Regex.Regex c t o u)

module UVMHS.Lib.Parser.Core
data ParserEnv
ParserEnv :: 𝔹 -> Formats -> (𝕊 ∧ 𝐼 𝕊) -> 𝕊 -> ParserEnv
[parserEnvReportErrors] :: ParserEnv -> 𝔹
[parserEnvRenderFormat] :: ParserEnv -> Formats
[parserEnvErrorStack] :: ParserEnv -> 𝕊 ∧ 𝐼 𝕊
[parserEnvSourceName] :: ParserEnv -> 𝕊
parserEnvReportErrorsL :: ParserEnv ⟢ 𝔹
parserEnvRenderFormatL :: ParserEnv ⟢ Formats
parserEnvErrorStackL :: ParserEnv ⟢ (𝕊 ∧ 𝐼 𝕊)
parserEnvSourceNameL :: ParserEnv ⟢ 𝕊
parserEnv₀ :: 𝕊 -> ParserEnv
type ParserOut (t :: k) = AddNull ParserError t
data ParserState t
ParserState :: WindowR Doc Doc -> ParserContext -> ParserContext -> WindowL Doc Doc -> AddBT Loc -> 𝑆 (ParserToken t) -> ParserState t
[parserStatePrefix] :: ParserState t -> WindowR Doc Doc
[parserStateSkipContext] :: ParserState t -> ParserContext
[parserStateContext] :: ParserState t -> ParserContext
[parserStateSuffix] :: ParserState t -> WindowL Doc Doc
[parserStateEndPos] :: ParserState t -> AddBT Loc
[parserStateInput] :: ParserState t -> 𝑆 (ParserToken t)
parserStatePrefixL :: ParserState t ⟢ WindowR Doc Doc
parserStateSkipContextL :: ParserState t ⟢ ParserContext
parserStateContextL :: ParserState t ⟢ ParserContext
parserStateSuffixL :: ParserState t ⟢ WindowL Doc Doc
parserStateEndPosL :: ParserState t ⟢ AddBT Loc
parserStateInputL :: ParserState t ⟢ 𝑆 (ParserToken t)
parserState₀ :: 𝑆 (ParserToken t) -> ParserState t
newtype Parser t a
Parser :: ReaderT ParserEnv (StateT (ParserState t) (FailT ((∧) (ParserOut t)))) a -> Parser t a
[unParser] :: Parser t a -> ReaderT ParserEnv (StateT (ParserState t) (FailT ((∧) (ParserOut t)))) a
runParser :: ParserEnv -> ParserState t -> Parser t a -> ParserOut t ∧ 𝑂 (ParserState t ∧ a)
pNewExpressionContext :: Parser t a -> Parser t a
pGetContext :: Parser t ((WindowR Doc Doc ∧ ParserContext) ∧ WindowL Doc Doc)
pGetContextRendered :: Parser t SrcCxt
pWithContext :: Parser t a -> Parser t (((WindowR Doc Doc ∧ ParserContext) ∧ WindowL Doc Doc) ∧ a)
pFail :: ParserContext -> WindowL Doc Doc -> Parser t a
pErr :: 𝕊 -> Parser t a -> Parser t a
pNewErrContext :: 𝕊 -> Parser t a -> Parser t a
pNewContext :: 𝕊 -> Parser t a -> Parser t a
pWithContextRendered :: Parser t a -> Parser t (𝐴 SrcCxt a)
pRender :: Formats -> Parser t a -> Parser t a
pAdvance :: Parser t (AddBT Loc ∨ ParserToken t)
pPluck :: Parser t (ParserToken t)
pRecord :: ParserToken t -> Parser t ()
pEnd :: Parser t ()
pFinal :: Parser t a -> Parser t a
pAny :: Parser t t
pShaped :: (t -> 𝑂 a) -> Parser t a
pDie :: Parser t a
pGuard :: 𝔹 -> Parser t ()
pFailEff :: 𝑂 a -> Parser t a
pSatisfies :: (t -> 𝔹) -> Parser t t
pToken :: Eq t => t -> Parser t t
pOptional :: Parser t a -> Parser t (𝑂 a)
pMany :: Parser t a -> Parser t (𝐿 a)
pOneOrMore :: Parser t a -> Parser t (𝐿 a)
pManySepBy :: Parser t () -> Parser t a -> Parser t (𝐿 a)
pOneOrMoreSepBy :: Parser t () -> Parser t a -> Parser t (𝐿 a)
pWord :: forall s t. (Eq t, s ⇄ 𝐼 t) => s -> Parser t s
instance UVMHS.Core.Classes.Functors.Bind (UVMHS.Lib.Parser.Core.Parser t)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Parser.Core.Parser t)
instance UVMHS.Core.Effects.MonadFail (UVMHS.Lib.Parser.Core.Parser t)
instance UVMHS.Core.Classes.Functors.Monad (UVMHS.Lib.Parser.Core.Parser t)
instance UVMHS.Core.Effects.MonadReader UVMHS.Lib.Parser.Core.ParserEnv (UVMHS.Lib.Parser.Core.Parser t)
instance UVMHS.Core.Effects.MonadState (UVMHS.Lib.Parser.Core.ParserState t) (UVMHS.Lib.Parser.Core.Parser t)
instance UVMHS.Core.Effects.MonadWriter (UVMHS.Lib.Parser.Core.ParserOut t) (UVMHS.Lib.Parser.Core.Parser t)
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔹, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Pretty.Annotation.Formats, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝕊 UVMHS.Core.Init.∧ UVMHS.Core.Init.𝐼 UVMHS.Core.Init.𝕊), UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊) => UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.Core.ParserEnv
instance (UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Window.WindowR UVMHS.Lib.Pretty.Doc.Doc UVMHS.Lib.Pretty.Doc.Doc), UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Parser.ParserContext.ParserContext, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Window.WindowL UVMHS.Lib.Pretty.Doc.Doc UVMHS.Lib.Pretty.Doc.Doc), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Pointed.AddBT UVMHS.Lib.Parser.Loc.Loc), UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝑆 (UVMHS.Lib.Parser.ParserInput.ParserToken t))) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Parser.Core.ParserState t)
instance UVMHS.Core.Classes.Functors.Return (UVMHS.Lib.Parser.Core.Parser t)

module UVMHS.Lib.Parser.CParser
data CParser t a
CParser :: (t ⇰ CParser t a) -> Parser t a -> CParser t a
[cParserNext] :: CParser t a -> t ⇰ CParser t a
[cParserFallback] :: CParser t a -> Parser t a
onCParser :: (Parser t a -> Parser t a) -> CParser t a -> CParser t a
toCParser :: Parser t a -> CParser t a
frCParser :: Ord t => CParser t a -> Parser t a
cpRender :: Ord t => Formats -> CParser t a -> CParser t a
cpErr :: Ord t => 𝕊 -> CParser t a -> CParser t a
cpToken :: Ord t => t -> CParser t t
cpFinal :: Ord t => CParser t a -> CParser t a
cpShaped :: (t -> 𝑂 a) -> CParser t a
cpSatisfies :: (t -> 𝔹) -> CParser t t
cpAny :: CParser t t
cpWord :: forall s t. (Eq t, s ⇄ 𝐼 t) => s -> CParser t s
cpOptional :: Ord t => CParser t a -> CParser t (𝑂 a)
cpMany :: Ord t => CParser t a -> CParser t (𝐿 a)
cpOneOrMore :: Ord t => CParser t a -> CParser t (𝐿 a)
cpManySepBy :: Ord t => CParser t () -> CParser t a -> CParser t (𝐿 a)
cpOneOrMoreSepBy :: Ord t => CParser t () -> CParser t a -> CParser t (𝐿 a)
cpDie :: CParser t a
cpGuard :: 𝔹 -> CParser t ()
cpFailEff :: 𝑂 a -> CParser t a
cpSyntax :: 𝕊 -> CParser TokenBasic TokenBasic
cpNatN :: CParser TokenBasic ℕ
cpNat64N :: CParser TokenBasic ℕ64
cpInt :: CParser TokenBasic ℤ
cpInt64 :: CParser TokenBasic ℤ64
cpNat :: CParser TokenBasic ℕ
cpNat64 :: CParser TokenBasic ℕ64
cpDouble :: CParser TokenBasic 𝔻
cpString :: CParser TokenBasic 𝕊
cpChar :: CParser TokenBasic ℂ
cpSyntaxWS :: 𝕊 -> CParser TokenWSBasic TokenWSBasic
cpNaturalWS :: CParser TokenWSBasic ℕ
cpIntegerWS :: CParser TokenWSBasic ℤ
cpDoubleWS :: CParser TokenWSBasic 𝔻
cpStringWS :: CParser TokenWSBasic 𝕊
cpBlockWS :: 𝕊 -> CParser TokenWSBasic TokenWSBasic
cpOpenWS :: CParser TokenWSBasic ()
cpCloseWS :: CParser TokenWSBasic ()
cpDelimWS :: CParser TokenWSBasic ()
cpNewExpressionContext :: Ord t => CParser t a -> CParser t a
cpNewErrContext :: Ord t => 𝕊 -> CParser t a -> CParser t a
cpNewContext :: Ord t => 𝕊 -> CParser t a -> CParser t a
cpWithContextRendered :: Ord t => CParser t a -> CParser t (𝐴 SrcCxt a)
cpNewWithContextRendered :: Ord t => 𝕊 -> CParser t a -> CParser t (𝐴 SrcCxt a)
cpGetContextRendered :: CParser t SrcCxt
cpNewGetContextRendered :: Ord t => CParser t SrcCxt
cpManyContext :: (Ord t, Comonad f) => (forall b. () => CParser t b -> CParser t (f b)) -> CParser t a -> CParser t (𝐿 (f a))
cpOneOrMoreContext :: (Ord t, Comonad f) => (forall b. () => CParser t b -> CParser t (f b)) -> CParser t a -> CParser t (𝐿 (f a))
cpManySepByContext :: (Ord t, Comonad f) => (forall b. () => CParser t b -> CParser t (f b)) -> CParser t () -> CParser t a -> CParser t (𝐿 (f a))
cpOneOrMoreSepByContext :: (Ord t, Comonad f) => (forall b. () => CParser t b -> CParser t (f b)) -> CParser t () -> CParser t a -> CParser t (𝐿 (f a))
runParser₀ :: (ToIter (ParserToken t) ts, Ord t) => 𝕊 -> ts -> CParser t a -> ParserOut t ∧ 𝑂 (ParserState t ∧ a)
parse :: (Pretty a, ToIter (ParserToken t) ts, Ord t) => CParser t a -> 𝕊 -> ts -> Doc ∨ a
parseIO :: (Pretty a, ToIter (ParserToken t) ts, Ord t) => CParser t a -> 𝕊 -> ts -> IO a
parseIOMain :: (Pretty a, ToIter (ParserToken t) ts, Ord t) => CParser t a -> 𝕊 -> ts -> IO ()
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.CParser.CParser t a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Functors.Bind (UVMHS.Lib.Parser.CParser.CParser t)
instance UVMHS.Core.Classes.Monoid.Eps (UVMHS.Lib.Parser.CParser.CParser t ())
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Parser.CParser.CParser t)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Functors.Monad (UVMHS.Lib.Parser.CParser.CParser t)
instance GHC.Classes.Ord t => UVMHS.Core.Effects.MonadFail (UVMHS.Lib.Parser.CParser.CParser t)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Parser.CParser.CParser t a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Parser.CParser.CParser t a)
instance UVMHS.Core.Classes.Functors.Return (UVMHS.Lib.Parser.CParser.CParser t)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Seq (UVMHS.Lib.Parser.CParser.CParser t ())
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Seqoid (UVMHS.Lib.Parser.CParser.CParser t ())

module UVMHS.Lib.Parser.Mixfix
data MixesF t (f :: Type -> Type) a
MixesF :: CParser t (f a -> a) -> CParser t (f a -> a) -> CParser t (f a -> f a -> a) -> CParser t (f a -> f a -> a) -> CParser t (f a -> f a -> a) -> MixesF t (f :: Type -> Type) a
[mixesFPrefix] :: MixesF t (f :: Type -> Type) a -> CParser t (f a -> a)
[mixesFPostfix] :: MixesF t (f :: Type -> Type) a -> CParser t (f a -> a)
[mixesFInfix] :: MixesF t (f :: Type -> Type) a -> CParser t (f a -> f a -> a)
[mixesFInfixL] :: MixesF t (f :: Type -> Type) a -> CParser t (f a -> f a -> a)
[mixesFInfixR] :: MixesF t (f :: Type -> Type) a -> CParser t (f a -> f a -> a)
data MixfixF t (f :: Type -> Type) a
MixfixF :: CParser t a -> (ℕ64 ⇰ MixesF t f a) -> MixfixF t (f :: Type -> Type) a
[mixfixFTerminals] :: MixfixF t (f :: Type -> Type) a -> CParser t a
[mixfixFLevels] :: MixfixF t (f :: Type -> Type) a -> ℕ64 ⇰ MixesF t f a
onlyTerminalsF :: forall t (f :: Type -> Type) a. MixfixF t f a -> MixfixF t f a
fmixPrefix :: ℕ64 -> CParser t (f a -> a) -> MixfixF t f a
fmixPostfix :: ℕ64 -> CParser t (f a -> a) -> MixfixF t f a
fmixInfix :: ℕ64 -> CParser t (f a -> f a -> a) -> MixfixF t f a
fmixInfixL :: ℕ64 -> CParser t (f a -> f a -> a) -> MixfixF t f a
fmixInfixR :: ℕ64 -> CParser t (f a -> f a -> a) -> MixfixF t f a
fmixTerminal :: forall t a (f :: Type -> Type). CParser t a -> MixfixF t f a
fmixfix :: (Ord t, Comonad f) => (CParser t (f a) -> CParser t (f a)) -> (CParser t (f a) -> CParser t (f a)) -> (CParser t a -> CParser t (f a)) -> MixfixF t f a -> CParser t (f a)
fmixfixWithContext :: Ord t => 𝕊 -> MixfixF t (𝐴 SrcCxt) a -> CParser t (𝐴 SrcCxt a)
fmixfixWithContextSet :: Ord t => 𝕊 -> MixfixF t (𝐴 (𝑃 SrcCxt)) a -> CParser t (𝐴 (𝑃 SrcCxt) a)
data Mixes t a
Mixes :: CParser t (a -> a) -> CParser t (a -> a) -> CParser t (a -> a -> a) -> CParser t (a -> a -> a) -> CParser t (a -> a -> a) -> Mixes t a
[mixesPrefix] :: Mixes t a -> CParser t (a -> a)
[mixesPostfix] :: Mixes t a -> CParser t (a -> a)
[mixesInfix] :: Mixes t a -> CParser t (a -> a -> a)
[mixesInfixL] :: Mixes t a -> CParser t (a -> a -> a)
[mixesInfixR] :: Mixes t a -> CParser t (a -> a -> a)
data Mixfix t a
Mixfix :: CParser t a -> (ℕ64 ⇰ Mixes t a) -> Mixfix t a
[mixfixTerminals] :: Mixfix t a -> CParser t a
[mixfixLevels] :: Mixfix t a -> ℕ64 ⇰ Mixes t a
mixPrefix :: ℕ64 -> CParser t (a -> a) -> Mixfix t a
mixPostfix :: ℕ64 -> CParser t (a -> a) -> Mixfix t a
mixInfix :: ℕ64 -> CParser t (a -> a -> a) -> Mixfix t a
mixInfixL :: ℕ64 -> CParser t (a -> a -> a) -> Mixfix t a
mixInfixR :: ℕ64 -> CParser t (a -> a -> a) -> Mixfix t a
mixTerminal :: CParser t a -> Mixfix t a
mixesPure :: Ord t => Mixes t a -> MixesF t ID a
mixfixPure :: Ord t => Mixfix t a -> MixfixF t ID a
mixfix :: Ord t => Mixfix t a -> CParser t a
mixfixWithContext :: Ord t => 𝕊 -> Mixfix t a -> CParser t (𝐴 SrcCxt a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.Mixfix.Mixes t a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.Mixfix.MixesF t f a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.Mixfix.Mixfix t a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Parser.Mixfix.MixfixF t f a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Parser.Mixfix.Mixes t a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Parser.Mixfix.MixesF t f a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Parser.Mixfix.Mixfix t a)
instance GHC.Classes.Ord t => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Parser.Mixfix.MixfixF t f a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Parser.Mixfix.Mixes t a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Parser.Mixfix.MixesF t f a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Parser.Mixfix.Mixfix t a)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Parser.Mixfix.MixfixF t f a)

module UVMHS.Lib.Parser.Examples
testParsingSmall :: IO ()
testParsingMultiline :: IO ()
testParsingBranching :: IO ()
testParsingGreedy :: IO ()
testParsingGreedyAmbiguity :: IO ()
testParsingSuccess :: IO ()
testParsingErrorNewline :: IO ()
testParsingErrorEof :: IO ()
testTokenizeSimple :: IO ()
testTokenize :: IO ()
testTokenizeFailure1 :: IO ()
testTokenizeFailure2 :: IO ()

module UVMHS.Lib.Parser

module UVMHS.Lib.THLiftInstances
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (UVMHS.Core.Pointed.AddBT a)
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Pretty.Annotation.Annotation
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Pretty.Common.ChunkI
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Pretty.Color.Color
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Pretty.Color.Color3Bit
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Pretty.Doc.Doc
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (() -> a)
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Pretty.Annotation.Formats
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Parser.Loc.Loc
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Parser.Loc.LocRange
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Parser.ParserContext.SrcCxt
instance (Language.Haskell.TH.Syntax.Lift i, Language.Haskell.TH.Syntax.Lift a) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Window.WindowL i a)
instance (Language.Haskell.TH.Syntax.Lift i, Language.Haskell.TH.Syntax.Lift a) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Window.WindowR i a)
instance (Language.Haskell.TH.Syntax.Lift k, Language.Haskell.TH.Syntax.Lift v) => Language.Haskell.TH.Syntax.Lift (k UVMHS.Core.Init.⇰ v)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (a UVMHS.Core.Init.∧ b)
instance (Language.Haskell.TH.Syntax.Lift 𝒸, Language.Haskell.TH.Syntax.Lift a) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Annotated.𝐴 𝒸 a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (UVMHS.Core.Init.𝐼 a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (UVMHS.Core.Init.𝑂 a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (UVMHS.Core.Init.𝑃 a)
instance (Language.Haskell.TH.Syntax.Lift i, Language.Haskell.TH.Syntax.Lift a) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.TreeAnnote.𝑇 i a)
instance (Language.Haskell.TH.Syntax.Lift i, Language.Haskell.TH.Syntax.Lift a) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.TreeAnnote.𝑇V i a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (UVMHS.Core.Vector.𝕍 a)

module UVMHS.Lib.Testing
𝔱 :: 𝕊 -> ExpQ -> ExpQ -> Q [Dec]
data FuzzParams
FuzzParams :: ℕ64 -> ℕ64 -> ℕ64 -> ℕ64 -> ℕ64 -> FuzzParams
[fuzzParamsRadiusMax] :: FuzzParams -> ℕ64
[fuzzParamsRadiusStep] :: FuzzParams -> ℕ64
[fuzzParamsDepthMax] :: FuzzParams -> ℕ64
[fuzzParamsDepthStep] :: FuzzParams -> ℕ64
[fuzzParamsSpread] :: FuzzParams -> ℕ64
data Test
Test :: Doc -> (() -> ErrorT (() -> 𝑇A Doc) (RWST FuzzParams ℕ64 () IO) ()) -> Test
[testSrcLoc] :: Test -> Doc
[testResult] :: Test -> () -> ErrorT (() -> 𝑇A Doc) (RWST FuzzParams ℕ64 () IO) ()
fuzzParams₀ :: FuzzParams
fuzzParamsTny :: ℕ64 -> FuzzParams
fuzzParamsSml :: ℕ64 -> FuzzParams
fuzzParamsMed :: ℕ64 -> FuzzParams
fuzzParamsLrg :: ℕ64 -> FuzzParams
eqTest :: (Eq a, Pretty a) => 𝐿 𝕊 -> 𝕊 -> a -> a -> 𝑇D Test
fuzzTest :: (Pretty a, Shrinky a) => 𝐿 𝕊 -> 𝕊 -> FuzzyM a -> (a -> 𝔹) -> (a -> Doc) -> 𝑇D Test
data TestsOut
TestsOut :: (𝐿 𝕊 ⇰ 𝐼 (Doc ∧ (() -> 𝑇A Doc))) -> (𝐿 𝕊 ⇰ (ℕ64 ∧ ℕ64)) -> TestsOut
[testsOutFailures] :: TestsOut -> 𝐿 𝕊 ⇰ 𝐼 (Doc ∧ (() -> 𝑇A Doc))
[testsOutMetrics] :: TestsOut -> 𝐿 𝕊 ⇰ (ℕ64 ∧ ℕ64)
testsOutFailure :: 𝐿 𝕊 -> Doc -> (() -> 𝑇A Doc) -> TestsOut
testsOutMetricPass :: 𝐿 𝕊 -> ℕ64 -> TestsOut
testsOutMetricFail :: 𝐿 𝕊 -> ℕ64 -> TestsOut
runTests :: 𝔹 -> FuzzParams -> 𝑇D Test -> IO ()
𝔱T :: (Eq a, Pretty a) => 𝕊 -> CodeQ a -> CodeQ a -> Q [Dec]
𝔣 :: 𝕊 -> ExpQ -> ExpQ -> ExpQ -> Q [Dec]
𝔣T :: (Pretty a, Shrinky a) => 𝕊 -> CodeQ (FuzzyM a) -> CodeQ (a -> 𝔹) -> CodeQ (a -> Doc) -> Q [Dec]
buildTests :: Q [Dec]
testModules :: 𝔹 -> FuzzParams -> [𝕊] -> CodeQ (IO ())
instance UVMHS.Core.Classes.Monoid.Append UVMHS.Lib.Testing.TestsOut
instance GHC.Classes.Eq UVMHS.Lib.Testing.FuzzParams
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Testing.FuzzParams
instance UVMHS.Core.Classes.Monoid.Monoid UVMHS.Lib.Testing.TestsOut
instance UVMHS.Core.Classes.Monoid.Null UVMHS.Lib.Testing.TestsOut
instance GHC.Classes.Ord UVMHS.Lib.Testing.FuzzParams
instance GHC.Show.Show UVMHS.Lib.Testing.FuzzParams

module UVMHS.Lib.Substitution.Var
data 𝕎
𝕎 :: 𝑂 ℕ64 -> 𝕊 -> 𝕎
[varMark] :: 𝕎 -> 𝑂 ℕ64
[varName] :: 𝕎 -> 𝕊
varMarkL :: 𝕎 ⟢ 𝑂 ℕ64
varNameL :: 𝕎 ⟢ 𝕊
var :: 𝕊 -> 𝕎
gensymVar :: (Monad m, MonadState s m) => (s ⟢ ℕ64) -> 𝕊 -> m 𝕎
syntaxVar :: LexerBasicSyntax
cpVar :: CParser TokenBasic 𝕎
cpVarWS :: CParser TokenWSBasic 𝕎
syntaxDVar :: LexerBasicSyntax
cpDVarRaw :: CParser TokenBasic ℕ64
cpDVarRawInf :: CParser TokenBasic (𝑂 ℕ64)
cpDVar :: CParser TokenBasic ℕ64
cpDVarInf :: CParser TokenBasic (𝑂 ℕ64)
data 𝕏
D_SVar :: ℕ64 -> 𝕏
N_SVar :: ℕ64 -> 𝕎 -> 𝕏
G_SVar :: 𝕎 -> 𝕏
d_SVarL :: 𝕏 ⌲ ℕ64
n_SVarL :: 𝕏 ⌲ (ℕ64 ∧ 𝕎)
g_SVarL :: 𝕏 ⌲ 𝕎
znsvar :: 𝕎 -> 𝕏
znsvarL :: 𝕏 ⌲ 𝕎
gensymSVar :: (Monad m, MonadState s m) => (s ⟢ ℕ64) -> 𝕊 -> m 𝕏
cpZNSVar :: CParser TokenBasic 𝕏
cpGSVar :: CParser TokenBasic 𝕏
cpNSVarWS :: CParser TokenWSBasic 𝕏
cpGSVarWS :: CParser TokenWSBasic 𝕏
syntaxSVar :: LexerBasicSyntax
cpSVarNGVarTail :: CParser TokenBasic (𝑂 ℕ64)
cpSVarNGVar :: CParser TokenBasic ((ℕ64 ∧ 𝕎) ∨ 𝕎)
cpSVarNGVarInfTail :: CParser TokenBasic (𝑂 (𝑂 ℕ64))
cpSVarNGVarInf :: CParser TokenBasic ((𝑂 ℕ64 ∧ 𝕎) ∨ 𝕎)
cpSVarRaw :: CParser TokenBasic 𝕏
cpSVarRawInf :: CParser TokenBasic (𝕏 ∨ 𝑂 𝕎)
cpSVar :: CParser TokenBasic 𝕏
cpSVarInf :: CParser TokenBasic (𝕏 ∨ 𝑂 𝕎)
ppDVar :: 𝕊 -> Doc
ppNVar :: Doc -> Doc -> Doc
class SVarView s e | e -> s
svarL :: SVarView s e => s -> e ⌲ 𝕏
svarScopeL :: SVarView s e => s -> 𝑂 𝕎 -> e ⌲ ℕ64
instance GHC.Classes.Eq UVMHS.Lib.Substitution.Var.𝕎
instance GHC.Classes.Eq UVMHS.Lib.Substitution.Var.𝕏
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Lib.Substitution.Var.𝕎
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Lib.Substitution.Var.𝕏
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Substitution.Var.𝕎
instance Language.Haskell.TH.Syntax.Lift UVMHS.Lib.Substitution.Var.𝕏
instance GHC.Classes.Ord UVMHS.Lib.Substitution.Var.𝕎
instance GHC.Classes.Ord UVMHS.Lib.Substitution.Var.𝕏
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Substitution.Var.𝕎
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Substitution.Var.𝕏
instance GHC.Show.Show UVMHS.Lib.Substitution.Var.𝕎
instance GHC.Show.Show UVMHS.Lib.Substitution.Var.𝕏
instance UVMHS.Lib.Shrinky.Shrinky UVMHS.Lib.Substitution.Var.𝕎
instance UVMHS.Lib.Shrinky.Shrinky UVMHS.Lib.Substitution.Var.𝕏

module UVMHS.Lib.Substitution.SubstElem
data SubstElem s e
SubstElem :: (s ⇰ ℕ64) -> 𝑂 e -> SubstElem s e

-- | delayed renaming , substElemValue ∷ () → 𝑂 e -- ^ delayed element
[substElemIntro] :: SubstElem s e -> s ⇰ ℕ64
[substelemValue] :: SubstElem s e -> 𝑂 e
substElemIntroL :: SubstElem s e ⟢ (s ⇰ ℕ64)
substelemValueL :: SubstElem s e ⟢ 𝑂 e
interpSubstElem :: ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SubstElem s e -> 𝑂 e
canonSubstElem :: ((s ⇰ ℕ64) -> e -> 𝑂 e) -> (e -> e) -> SubstElem s e -> SubstElem s e
eqSubstElem :: Eq e => ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SubstElem s e -> SubstElem s e -> 𝔹
compareSubstElem :: Ord e => ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SubstElem s e -> SubstElem s e -> Ordering
introSubstElem :: Ord s => (s ⇰ ℕ64) -> SubstElem s e -> SubstElem s e
substSubstElemE :: ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SubstElem s e -> 𝑂 e
substSubstElem :: ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SubstElem s e -> SubstElem s e
ppSubstElemNamed :: Pretty e => ((s ⇰ ℕ64) -> Doc) -> SubstElem s e -> Doc
data SSubstElem s e
Var_SSE :: ℕ64 -> SSubstElem s e
Trm_SSE :: SubstElem s e -> SSubstElem s e
mkSSubstElem :: (e ⌲ ℕ64) -> 𝑂 e -> SSubstElem s e
interpSSubstElem :: (e ⌲ ℕ64) -> ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SSubstElem s e -> 𝑂 e
canonSSubstElem :: (e ⌲ ℕ64) -> ((s ⇰ ℕ64) -> e -> 𝑂 e) -> (e -> e) -> SSubstElem s e -> SSubstElem s e
eqSSubstElem :: Eq e => (e ⌲ ℕ64) -> ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SSubstElem s e -> SSubstElem s e -> 𝔹
compareSSubstElem :: Ord e => (e ⌲ ℕ64) -> ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SSubstElem s e -> SSubstElem s e -> Ordering
introSSubstElem :: Ord s => s -> (s ⇰ ℕ64) -> SSubstElem s e -> SSubstElem s e
substSSubstElem :: (e ⌲ ℕ64) -> ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SSubstElem s e -> SSubstElem s e
ppSSubstElemNamed :: Pretty e => ((s ⇰ ℕ64) -> Doc) -> (𝕊 -> Doc) -> SSubstElem s e -> Doc
instance (GHC.Classes.Eq s, GHC.Classes.Eq e) => GHC.Classes.Eq (UVMHS.Lib.Substitution.SubstElem.SSubstElem s e)
instance (GHC.Classes.Eq s, GHC.Classes.Eq e) => GHC.Classes.Eq (UVMHS.Lib.Substitution.SubstElem.SubstElem s e)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Substitution.SubstElem.SSubstElem s)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Substitution.SubstElem.SubstElem s)
instance (GHC.Classes.Ord s, UVMHS.Lib.Fuzzy.Fuzzy s, UVMHS.Lib.Fuzzy.Fuzzy e) => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Lib.Substitution.SubstElem.SSubstElem s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Fuzzy.Fuzzy s, UVMHS.Lib.Fuzzy.Fuzzy e) => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Lib.Substitution.SubstElem.SubstElem s e)
instance (Language.Haskell.TH.Syntax.Lift s, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Substitution.SubstElem.SSubstElem s e)
instance (Language.Haskell.TH.Syntax.Lift s, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Substitution.SubstElem.SubstElem s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => GHC.Classes.Ord (UVMHS.Lib.Substitution.SubstElem.SSubstElem s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => GHC.Classes.Ord (UVMHS.Lib.Substitution.SubstElem.SubstElem s e)
instance (UVMHS.Lib.Pretty.Doc.Pretty s, UVMHS.Lib.Pretty.Doc.Pretty e) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Substitution.SubstElem.SSubstElem s e)
instance (UVMHS.Lib.Pretty.Doc.Pretty s, UVMHS.Lib.Pretty.Doc.Pretty e) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Substitution.SubstElem.SubstElem s e)
instance (GHC.Show.Show s, GHC.Show.Show e) => GHC.Show.Show (UVMHS.Lib.Substitution.SubstElem.SSubstElem s e)
instance (GHC.Show.Show s, GHC.Show.Show e) => GHC.Show.Show (UVMHS.Lib.Substitution.SubstElem.SubstElem s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Shrinky.Shrinky e) => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lib.Substitution.SubstElem.SSubstElem s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Shrinky.Shrinky e) => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lib.Substitution.SubstElem.SubstElem s e)

module UVMHS.Lib.Substitution.SubstScoped
data SubstScoped s e
SubstScoped :: ℕ64 -> 𝕍 (SSubstElem s e) -> ℤ64 -> SubstScoped s e

-- | ρ: De Bruijn indices lower than this number will be untouched by this
--   substitution. Think of it as a substitution working over all natural
--   numbers being shifted to the right to ignore this many first indices.
[substScopedShift] :: SubstScoped s e -> ℕ64

-- | es: Instantiates as many of the first indices (post-shift by ρ) as the
--   length of this vector with the values in the vector.
[substScopeElems] :: SubstScoped s e -> 𝕍 (SSubstElem s e)

-- | ι: Starting at the nameless variable index after all the shifts (ρ)
--   and all the instantiations (es), simulate an introduction of this many
--   new nameless variables by bumping all subsequent indices by this much.
[substScopeIntro] :: SubstScoped s e -> ℤ64
substScopedShiftL :: SubstScoped s e ⟢ ℕ64
substScopeElemsL :: SubstScoped s e ⟢ 𝕍 (SSubstElem s e)
substScopeIntroL :: SubstScoped s e ⟢ ℤ64
lookupSubstScoped :: SubstScoped s e -> ℕ64 -> SSubstElem s e
interpSubstScoped :: (e ⌲ ℕ64) -> ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SubstScoped s e -> ℕ64 -> 𝑂 e
wfSubstScoped :: SubstScoped s e -> 𝔹
canonSubstScoped :: (Eq s, Eq e) => (e ⌲ ℕ64) -> ((s ⇰ ℕ64) -> e -> 𝑂 e) -> (e -> e) -> SubstScoped s e -> SubstScoped s e
isNullSubstScoped :: SubstScoped s e -> 𝔹
introSubstScoped :: ℕ64 -> SubstScoped s e
shiftSubstScoped :: Ord s => (s ⇰ ℕ64) -> s -> SubstScoped s e -> SubstScoped s e
bindSubstScoped :: 𝕍 e -> SubstScoped s e
substSubstScoped :: (e ⌲ ℕ64) -> ((s ⇰ ℕ64) -> e -> 𝑂 e) -> SubstScoped s e -> SubstScoped s e
ppSubstScoped :: (Pretty s, Pretty e) => ((s ⇰ ℕ64) -> Doc) -> (𝕊 -> Doc) -> SubstScoped s e -> 𝐼 (Doc ∧ Doc)
ppSubstScopedNamed :: (Pretty s, Pretty e) => ((s ⇰ ℕ64) -> Doc) -> 𝕊 -> SubstScoped s e -> 𝐼 (Doc ∧ Doc)
instance (GHC.Classes.Eq s, GHC.Classes.Eq e) => GHC.Classes.Eq (UVMHS.Lib.Substitution.SubstScoped.SubstScoped s e)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Substitution.SubstScoped.SubstScoped s)
instance (GHC.Classes.Ord s, UVMHS.Lib.Fuzzy.Fuzzy s, UVMHS.Lib.Fuzzy.Fuzzy e) => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Lib.Substitution.SubstScoped.SubstScoped s e)
instance (Language.Haskell.TH.Syntax.Lift s, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Substitution.SubstScoped.SubstScoped s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => GHC.Classes.Ord (UVMHS.Lib.Substitution.SubstScoped.SubstScoped s e)
instance (UVMHS.Lib.Pretty.Doc.Pretty e, UVMHS.Lib.Pretty.Doc.Pretty s) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Substitution.SubstScoped.SubstScoped s e)
instance (GHC.Show.Show s, GHC.Show.Show e) => GHC.Show.Show (UVMHS.Lib.Substitution.SubstScoped.SubstScoped s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Shrinky.Shrinky e) => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lib.Substitution.SubstScoped.SubstScoped s e)

module UVMHS.Lib.Substitution.SubstSpaced
data SubstSpaced sU sS e
SubstSpaced :: (sU ⇰ SubstElem sS e) -> (sS ⇰ SubstScoped sS e) -> SubstSpaced sU sS e
[substSpacedUnscoped] :: SubstSpaced sU sS e -> sU ⇰ SubstElem sS e
[substSpacedScoped] :: SubstSpaced sU sS e -> sS ⇰ SubstScoped sS e
substSpacedUnscopedL :: SubstSpaced sU sS e ⟢ (sU ⇰ SubstElem sS e)
substSpacedScopedL :: SubstSpaced sU sS e ⟢ (sS ⇰ SubstScoped sS e)
wfSubstSpaced :: Ord sS => SubstSpaced sU sS e -> 𝔹
canonSubstSpaced :: (Ord sS, Eq e) => (sS -> e ⌲ ℕ64) -> ((sS ⇰ ℕ64) -> e -> 𝑂 e) -> (e -> e) -> SubstSpaced sU sS e -> SubstSpaced sU sS e
shiftSubstSpaced :: Ord sS => (sS ⇰ ℕ64) -> SubstSpaced sU sS e -> SubstSpaced sU sS e
introSubstSpaced :: (sS ⇰ ℕ64) -> SubstSpaced sU sS e
sbindsSubstSpaced :: (sS ⇰ 𝕍 e) -> SubstSpaced sU sS e
ubindsSubstSpaced :: (sU ⇰ e) -> SubstSpaced sU sS e
substSpacedExtended :: (Ord sU, Ord sS) => (sS -> e ⌲ ℕ64) -> (SubstSpaced sU sS e -> e -> 𝑂 e) -> SubstSpaced sU sS e -> (sS ⇰ ℕ64) -> e -> 𝑂 e
substSubstElemSpacedE :: (Ord sU, Ord sS) => (sS -> e ⌲ ℕ64) -> (SubstSpaced sU sS e -> e -> 𝑂 e) -> SubstSpaced sU sS e -> SubstElem sS e -> 𝑂 e
substSubstElemSpaced :: (Ord sU, Ord sS) => (sS -> e ⌲ ℕ64) -> (SubstSpaced sU sS e -> e -> 𝑂 e) -> SubstSpaced sU sS e -> SubstElem sS e -> SubstElem sS e
substSSubstElemSpaced :: (Ord sU, Ord sS) => (sS -> e ⌲ ℕ64) -> (SubstSpaced sU sS e -> e -> 𝑂 e) -> SubstSpaced sU sS e -> sS -> SSubstElem sS e -> SSubstElem sS e
appendSubstSpaced :: (Ord sU, Ord sS) => (sS -> e ⌲ ℕ64) -> (SubstSpaced sU sS e -> e -> 𝑂 e) -> SubstSpaced sU sS e -> SubstSpaced sU sS e -> SubstSpaced sU sS e
instance (GHC.Classes.Eq sU, GHC.Classes.Eq sS, GHC.Classes.Eq e) => GHC.Classes.Eq (UVMHS.Lib.Substitution.SubstSpaced.SubstSpaced sU sS e)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Substitution.SubstSpaced.SubstSpaced sU sS)
instance (GHC.Classes.Ord sU, GHC.Classes.Ord sS, UVMHS.Lib.Fuzzy.Fuzzy sU, UVMHS.Lib.Fuzzy.Fuzzy sS, UVMHS.Lib.Fuzzy.Fuzzy e) => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Lib.Substitution.SubstSpaced.SubstSpaced sU sS e)
instance (Language.Haskell.TH.Syntax.Lift s₁, Language.Haskell.TH.Syntax.Lift s₂, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Substitution.SubstSpaced.SubstSpaced s₁ s₂ e)
instance (GHC.Classes.Ord sU, GHC.Classes.Ord sS, GHC.Classes.Ord e) => GHC.Classes.Ord (UVMHS.Lib.Substitution.SubstSpaced.SubstSpaced sU sS e)
instance (UVMHS.Lib.Pretty.Doc.Pretty s₁, UVMHS.Lib.Pretty.Doc.Pretty s₂, UVMHS.Lib.Pretty.Doc.Pretty e) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Substitution.SubstSpaced.SubstSpaced s₁ s₂ e)
instance (GHC.Show.Show sU, GHC.Show.Show sS, GHC.Show.Show e) => GHC.Show.Show (UVMHS.Lib.Substitution.SubstSpaced.SubstSpaced sU sS e)
instance (GHC.Classes.Ord sU, GHC.Classes.Ord sS, UVMHS.Lib.Shrinky.Shrinky e) => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lib.Substitution.SubstSpaced.SubstSpaced sU sS e)

module UVMHS.Lib.Substitution.Subst
newtype Subst s e
Subst :: SubstSpaced (s ∧ 𝕎) (s ∧ 𝑂 𝕎) e -> Subst s e
[unSubst] :: Subst s e -> SubstSpaced (s ∧ 𝕎) (s ∧ 𝑂 𝕎) e
unSubstL :: Subst s e ⟢ SubstSpaced (s ∧ 𝕎) (s ∧ 𝑂 𝕎) e
wfSubst :: Ord s => Subst s e -> 𝔹
canonSubstWith :: (Ord s, Eq e) => ((s ∧ 𝑂 𝕎) -> e ⌲ ℕ64) -> (((s ∧ 𝑂 𝕎) ⇰ ℕ64) -> e -> 𝑂 e) -> (e -> e) -> Subst s e -> Subst s e
shiftDSsSubst :: Ord s => (s ⇰ ℕ64) -> Subst s e -> Subst s e
shiftDSSubst :: Ord s => s -> ℕ64 -> Subst s e -> Subst s e
shiftDSubst :: ℕ64 -> Subst () e -> Subst () e
shiftNsSsSubst :: Ord s => (s ⇰ (𝕎 ⇰ ℕ64)) -> Subst s e -> Subst s e
shiftNsSSubst :: Ord s => s -> (𝕎 ⇰ ℕ64) -> Subst s e -> Subst s e
shiftNsSubst :: (𝕎 ⇰ ℕ64) -> Subst () e -> Subst () e
shiftNSSubst :: Ord s => s -> 𝕎 -> ℕ64 -> Subst s e -> Subst s e
shiftNSubst :: 𝕎 -> ℕ64 -> Subst () e -> Subst () e
introDSsSubst :: Ord s => (s ⇰ ℕ64) -> Subst s e
introDSSubst :: Ord s => s -> ℕ64 -> Subst s e
introDSubst :: ℕ64 -> Subst () e
introNsSsSubst :: Ord s => (s ⇰ (𝕎 ⇰ ℕ64)) -> Subst s e
introNsSSubst :: Ord s => s -> (𝕎 ⇰ ℕ64) -> Subst s e
introNsSubst :: (𝕎 ⇰ ℕ64) -> Subst () e
introNSSubst :: Ord s => s -> 𝕎 -> ℕ64 -> Subst s e
introNSubst :: 𝕎 -> ℕ64 -> Subst () e
bindsDSsSubst :: Ord s => (s ⇰ 𝕍 e) -> Subst s e
bindsDSSubst :: Ord s => s -> 𝕍 e -> Subst s e
bindsDSubst :: 𝕍 e -> Subst () e
bindDSsSubst :: Ord s => (s ⇰ e) -> Subst s e
bindDSSubst :: Ord s => s -> e -> Subst s e
bindDSubst :: e -> Subst () e
bindsNsSsSubst :: Ord s => (s ⇰ (𝕎 ⇰ 𝕍 e)) -> Subst s e
bindsNsSSubst :: Ord s => s -> (𝕎 ⇰ 𝕍 e) -> Subst s e
bindsNsSubst :: (𝕎 ⇰ 𝕍 e) -> Subst () e
bindsNSSubst :: Ord s => s -> 𝕎 -> 𝕍 e -> Subst s e
bindsNSubst :: 𝕎 -> 𝕍 e -> Subst () e
bindNsSsSubst :: Ord s => (s ⇰ (𝕎 ⇰ e)) -> Subst s e
bindNsSSubst :: Ord s => s -> (𝕎 ⇰ e) -> Subst s e
bindNsSubst :: (𝕎 ⇰ e) -> Subst () e
bindNSSubst :: Ord s => s -> 𝕎 -> e -> Subst s e
bindNSubst :: 𝕎 -> e -> Subst () e
bindGsSsSubst :: Ord s => (s ⇰ (𝕎 ⇰ e)) -> Subst s e
bindGsSSubst :: Ord s => s -> (𝕎 ⇰ e) -> Subst s e
bindGsSubst :: (𝕎 ⇰ e) -> Subst () e
bindGSSubst :: Ord s => s -> 𝕎 -> e -> Subst s e
bindGSubst :: 𝕎 -> e -> Subst () e
newtype MetaSubst s e
MetaSubst :: ((s ∧ 𝕎) ⇰ SubstElem (s ∧ 𝑂 𝕎) e) -> MetaSubst s e
[unMetaSubst] :: MetaSubst s e -> (s ∧ 𝕎) ⇰ SubstElem (s ∧ 𝑂 𝕎) e
unMetaSubstL :: MetaSubst s e ⟢ ((s ∧ 𝕎) ⇰ SubstElem (s ∧ 𝑂 𝕎) e)
bindMsSsSubst :: Ord s => (s ⇰ (𝕎 ⇰ e)) -> MetaSubst s e
bindMsSSubst :: Ord s => s -> (𝕎 ⇰ e) -> MetaSubst s e
bindMsSubst :: (𝕎 ⇰ e) -> MetaSubst () e
bindMSSubst :: Ord s => s -> 𝕎 -> e -> MetaSubst s e
bindMSubst :: 𝕎 -> e -> MetaSubst () e
instance (GHC.Classes.Eq s, GHC.Classes.Eq e) => GHC.Classes.Eq (UVMHS.Lib.Substitution.Subst.MetaSubst s e)
instance (GHC.Classes.Eq s, GHC.Classes.Eq e) => GHC.Classes.Eq (UVMHS.Lib.Substitution.Subst.Subst s e)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Substitution.Subst.Subst s)
instance (GHC.Classes.Ord s, UVMHS.Lib.Fuzzy.Fuzzy s, UVMHS.Lib.Fuzzy.Fuzzy e) => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Lib.Substitution.Subst.MetaSubst s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Fuzzy.Fuzzy s, UVMHS.Lib.Fuzzy.Fuzzy e) => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Lib.Substitution.Subst.Subst s e)
instance (Language.Haskell.TH.Syntax.Lift s, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Substitution.Subst.Subst s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => GHC.Classes.Ord (UVMHS.Lib.Substitution.Subst.MetaSubst s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => GHC.Classes.Ord (UVMHS.Lib.Substitution.Subst.Subst s e)
instance (UVMHS.Lib.Pretty.Doc.Pretty s, UVMHS.Lib.Pretty.Doc.Pretty e) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Substitution.Subst.MetaSubst s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Pretty.Doc.Pretty s, UVMHS.Lib.Pretty.Doc.Pretty e) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Substitution.Subst.Subst s e)
instance (GHC.Show.Show s, GHC.Show.Show e) => GHC.Show.Show (UVMHS.Lib.Substitution.Subst.MetaSubst s e)
instance (GHC.Show.Show s, GHC.Show.Show e) => GHC.Show.Show (UVMHS.Lib.Substitution.Subst.Subst s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Shrinky.Shrinky e) => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lib.Substitution.Subst.MetaSubst s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Shrinky.Shrinky e) => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lib.Substitution.Subst.Subst s e)

module UVMHS.Lib.Substitution.UVar
data 𝕐 s e
S_UVar :: 𝕏 -> 𝕐 s e
M_UVar :: 𝕎 -> Subst s e -> 𝕐 s e
s_UVarL :: 𝕐 s e ⌲ 𝕏
m_UVarL :: 𝕐 s e ⌲ (𝕎 ∧ Subst s e)
wfUVar :: Ord s => 𝕐 s e -> 𝔹
duvarL :: 𝕐 s e ⌲ ℕ64
duvar :: ℕ64 -> 𝕐 s e
nuvarL :: 𝕐 s e ⌲ (ℕ64 ∧ 𝕎)
nuvar :: ℕ64 -> 𝕎 -> 𝕐 s e
znuvarL :: 𝕐 s e ⌲ 𝕎
znuvar :: 𝕎 -> 𝕐 s e
guvarL :: 𝕐 s e ⌲ 𝕎
guvar :: 𝕎 -> 𝕐 s e
gensymUVar :: (Monad m, MonadState s m) => (s ⟢ ℕ64) -> 𝕊 -> m (𝕐 s e)
instance (GHC.Classes.Eq s, GHC.Classes.Eq e) => GHC.Classes.Eq (UVMHS.Lib.Substitution.UVar.𝕐 s e)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Substitution.UVar.𝕐 s)
instance (UVMHS.Lib.Pretty.Doc.Pretty e, UVMHS.Lib.Pretty.Doc.Pretty s, GHC.Classes.Ord s, UVMHS.Lib.Fuzzy.Fuzzy s, UVMHS.Lib.Fuzzy.Fuzzy e) => UVMHS.Lib.Fuzzy.Fuzzy (UVMHS.Lib.Substitution.UVar.𝕐 s e)
instance (Language.Haskell.TH.Syntax.Lift s, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (UVMHS.Lib.Substitution.UVar.𝕐 s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => GHC.Classes.Ord (UVMHS.Lib.Substitution.UVar.𝕐 s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Pretty.Doc.Pretty e, UVMHS.Lib.Pretty.Doc.Pretty s) => UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lib.Substitution.UVar.𝕐 s e)
instance (GHC.Show.Show s, GHC.Show.Show e) => GHC.Show.Show (UVMHS.Lib.Substitution.UVar.𝕐 s e)

module UVMHS.Lib.Substitution.Substy
data FreeVarsAction s e
FreeVarsAction :: (s -> 𝕐 s e -> 𝔹) -> ((s ∧ 𝑂 𝕎) ⇰ ℕ64) -> FreeVarsAction s e
[freeVarsActionFilter] :: FreeVarsAction s e -> s -> 𝕐 s e -> 𝔹
[freeVarsActionScope] :: FreeVarsAction s e -> (s ∧ 𝑂 𝕎) ⇰ ℕ64
freeVarsActionFilterL :: FreeVarsAction s e ⟢ (s -> 𝕐 s e -> 𝔹)
freeVarsActionScopeL :: FreeVarsAction s e ⟢ ((s ∧ 𝑂 𝕎) ⇰ ℕ64)
data RebindAction
ID_RA :: RebindAction
AllNameless_RA :: RebindAction
AllNamed_RA :: RebindAction
data SubstAction s e
SubstAction :: RebindAction -> Subst s e -> SubstAction s e
[substActionRebind] :: SubstAction s e -> RebindAction
[substActionSubst] :: SubstAction s e -> Subst s e
substActionRebindL :: SubstAction s e ⟢ RebindAction
substActionSubstL :: SubstAction s e ⟢ Subst s e
data SubstyAction s e
FreeVars_SA :: FreeVarsAction s e -> SubstyAction s e
Subst_SA :: SubstAction s e -> SubstyAction s e
MetaSubst_SA :: MetaSubst s e -> SubstyAction s e
freeVars_SAL :: SubstyAction s e ⌲ FreeVarsAction s e
subst_SAL :: SubstyAction s e ⌲ SubstAction s e
metaSubst_SAL :: SubstyAction s e ⌲ MetaSubst s e
newtype SubstyM s e a
SubstyM :: UContT (ReaderT (SubstyAction s e) (FailT (WriterT (s ⇰ 𝑃 (𝕐 s e)) ID))) a -> SubstyM s e a
[unSubstyM] :: SubstyM s e a -> UContT (ReaderT (SubstyAction s e) (FailT (WriterT (s ⇰ 𝑃 (𝕐 s e)) ID))) a
mkSubstM :: (forall u. () => SubstyAction s e -> (a -> SubstyAction s e -> (s ⇰ 𝑃 (𝕐 s e)) ∧ 𝑂 u) -> (s ⇰ 𝑃 (𝕐 s e)) ∧ 𝑂 u) -> SubstyM s e a
runSubstM :: SubstyAction s e -> (a -> SubstyAction s e -> (s ⇰ 𝑃 (𝕐 s e)) ∧ 𝑂 u) -> SubstyM s e a -> (s ⇰ 𝑃 (𝕐 s e)) ∧ 𝑂 u
evalSubstM :: SubstyAction s e -> SubstyM s e a -> (s ⇰ 𝑃 (𝕐 s e)) ∧ 𝑂 a
class SVarView s e => Substy s e a | a -> e, e -> s
substy :: Substy s e a => a -> SubstyM s e a
fvsWith :: Substy s e a => (s -> 𝕐 s e -> 𝔹) -> a -> s ⇰ 𝑃 (𝕐 s e)
fvsSMetas :: (Ord s, Ord e, Substy s e a) => 𝑃 s -> a -> s ⇰ 𝑃 (𝕎 ∧ Subst s e)
fvsMetas :: (Ord s, Ord e, Substy s e a) => s -> a -> 𝑃 (𝕎 ∧ Subst s e)
fvs :: Substy s e a => a -> s ⇰ 𝑃 (𝕐 s e)
todbr :: Substy s e a => a -> 𝑂 a
tonmd :: Substy s e a => a -> 𝑂 a
subst :: Substy s e a => Subst s e -> a -> 𝑂 a
msubst :: Substy s e a => MetaSubst s e -> a -> 𝑂 a
canonSubst :: (Ord s, Eq e, Substy s e e) => (e -> e) -> Subst s e -> Subst s e
canonUVar :: (Ord s, Eq e, Substy s e e) => (e -> e) -> 𝕐 s e -> 𝕐 s e
nullSubst :: Subst s e
appendSubst :: (Ord s, Substy s e e) => Subst s e -> Subst s e -> Subst s e
substyDBdr :: (Ord s, Ord e) => s -> SubstyM s e ()
substyNBdr :: (Ord s, Ord e) => s -> 𝕎 -> SubstyM s e ()
substyBdr :: (Ord s, Ord e, Substy s e e) => s -> (𝕐 s e' -> e) -> 𝕎 -> SubstyM s e ()
substyVar :: (Ord s, Ord e, Substy s e e) => 𝑂 𝕎 -> s -> (ℕ64 -> e) -> ℕ64 -> SubstyM s e e
substyDVar :: (Ord s, Ord e, Substy s e e) => s -> (ℕ64 -> e) -> ℕ64 -> SubstyM s e e
substyNVar :: (Ord s, Ord e, Substy s e e) => s -> (ℕ64 -> e) -> 𝕎 -> ℕ64 -> SubstyM s e e
substyGVar :: (Ord s, Ord e, Substy s e e) => s -> (𝕎 -> e) -> 𝕎 -> SubstyM s e e
substyMVar :: (Ord s, Ord e, Pretty e, Pretty s, Substy s e e) => s -> (𝕎 -> Subst s e -> e) -> 𝕎 -> Subst s e -> SubstyM s e e
substy𝕏 :: (Ord s, Ord e, Pretty e, Pretty s, Substy s e e) => s -> (𝕏 -> e) -> 𝕏 -> SubstyM s e e
substy𝕐 :: (Ord s, Ord e, Pretty e, Pretty s, Substy s e e) => s -> (𝕐 s e -> e) -> 𝕐 s e -> SubstyM s e e
syntaxUVar :: LexerBasicSyntax
data ParseSubstAction e
ParseSubstAction :: 𝐼 ℕ64 -> (𝑂 ℕ64 ⇰ 𝐼 e) -> 𝐼 (ℕ64 ∧ ℤ64) -> ParseSubstAction e
[parseSubstActionShfts] :: ParseSubstAction e -> 𝐼 ℕ64
[parseSubstActionElems] :: ParseSubstAction e -> 𝑂 ℕ64 ⇰ 𝐼 e
[parseSubstActionIncrs] :: ParseSubstAction e -> 𝐼 (ℕ64 ∧ ℤ64)
parseSubstActionShftsL :: ParseSubstAction e ⟢ 𝐼 ℕ64
parseSubstActionElemsL :: ParseSubstAction e ⟢ (𝑂 ℕ64 ⇰ 𝐼 e)
parseSubstActionIncrsL :: ParseSubstAction e ⟢ 𝐼 (ℕ64 ∧ ℤ64)
parseSubstActionShft :: ℕ64 -> ParseSubstAction e
parseSubstActionElem :: 𝑂 ℕ64 -> e -> ParseSubstAction e
parseSubstActionIncr :: ℕ64 -> ℤ64 -> ParseSubstAction e
type ParseSubstActions e = 𝑂 𝕎 ∧ 𝔹 ⇰ ParseSubstAction e
cpSubst :: (Eq e, Substy () e e) => (() -> CParser TokenBasic e) -> CParser TokenBasic (Subst () e)
cpUVarNGMVar :: (Eq e, Substy () e e) => (() -> CParser TokenBasic e) -> CParser TokenBasic (𝕐 () e)
cpUVar :: (Eq e, Substy () e e) => (() -> CParser TokenBasic e) -> CParser TokenBasic (𝕐 () e)
cpUVarRaw :: (Eq e, Substy () e e) => (() -> CParser TokenBasic e) -> CParser TokenBasic (𝕐 () e)
instance UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Substitution.Substy.ParseSubstAction e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Substitution.Substy.Substy s e e) => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.Substitution.Subst.Subst s e)
instance UVMHS.Core.Classes.Functors.Bind (UVMHS.Lib.Substitution.Substy.SubstyM s e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (UVMHS.Lib.Substitution.Substy.ParseSubstAction e)
instance GHC.Classes.Eq UVMHS.Lib.Substitution.Substy.RebindAction
instance (GHC.Classes.Eq s, GHC.Classes.Eq e) => GHC.Classes.Eq (UVMHS.Lib.Substitution.Substy.SubstAction s e)
instance UVMHS.Core.Classes.Functors.Functor (UVMHS.Lib.Substitution.Substy.SubstyM s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => UVMHS.Core.Effects.MonadFail (UVMHS.Lib.Substitution.Substy.SubstyM s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => UVMHS.Core.Effects.MonadReader (UVMHS.Lib.Substitution.Substy.SubstyAction s e) (UVMHS.Lib.Substitution.Substy.SubstyM s e)
instance UVMHS.Core.Classes.Functors.Monad (UVMHS.Lib.Substitution.Substy.SubstyM s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => UVMHS.Core.Effects.MonadUCont (UVMHS.Lib.Substitution.Substy.SubstyM s e)
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => UVMHS.Core.Effects.MonadWriter (s UVMHS.Core.Init.⇰ UVMHS.Core.Init.𝑃 (UVMHS.Lib.Substitution.UVar.𝕐 s e)) (UVMHS.Lib.Substitution.Substy.SubstyM s e)
instance UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Substitution.Substy.ParseSubstAction e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Substitution.Substy.Substy s e e) => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.Substitution.Subst.Subst s e)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Substitution.Substy.ParseSubstAction e)
instance UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.Substitution.Subst.Subst s e)
instance GHC.Classes.Ord e => GHC.Classes.Ord (UVMHS.Lib.Substitution.Substy.ParseSubstAction e)
instance GHC.Classes.Ord UVMHS.Lib.Substitution.Substy.RebindAction
instance (GHC.Classes.Ord s, GHC.Classes.Ord e) => GHC.Classes.Ord (UVMHS.Lib.Substitution.Substy.SubstAction s e)
instance UVMHS.Core.Classes.Functors.Return (UVMHS.Lib.Substitution.Substy.SubstyM s e)
instance GHC.Show.Show e => GHC.Show.Show (UVMHS.Lib.Substitution.Substy.ParseSubstAction e)
instance GHC.Show.Show UVMHS.Lib.Substitution.Substy.RebindAction
instance (GHC.Show.Show s, GHC.Show.Show e) => GHC.Show.Show (UVMHS.Lib.Substitution.Substy.SubstAction s e)
instance (GHC.Classes.Ord s, UVMHS.Lib.Shrinky.Shrinky e) => UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lib.Substitution.UVar.𝕐 s e)

module UVMHS.Lib.Substitution
data 𝕎
𝕎 :: 𝑂 ℕ64 -> 𝕊 -> 𝕎
[varMark] :: 𝕎 -> 𝑂 ℕ64
[varName] :: 𝕎 -> 𝕊
varMarkL :: 𝕎 ⟢ 𝑂 ℕ64
varNameL :: 𝕎 ⟢ 𝕊
var :: 𝕊 -> 𝕎
gensymVar :: (Monad m, MonadState s m) => (s ⟢ ℕ64) -> 𝕊 -> m 𝕎
data 𝕏
D_SVar :: ℕ64 -> 𝕏
N_SVar :: ℕ64 -> 𝕎 -> 𝕏
G_SVar :: 𝕎 -> 𝕏
class SVarView s e | e -> s
svarL :: SVarView s e => s -> e ⌲ 𝕏
data 𝕐 s e
S_UVar :: 𝕏 -> 𝕐 s e
M_UVar :: 𝕎 -> Subst s e -> 𝕐 s e
s_UVarL :: 𝕐 s e ⌲ 𝕏
data Subst s e
data MetaSubst s e
class SVarView s e => Substy s e a | a -> e, e -> s
substy :: Substy s e a => a -> SubstyM s e a
wfUVar :: Ord s => 𝕐 s e -> 𝔹
canonUVar :: (Ord s, Eq e, Substy s e e) => (e -> e) -> 𝕐 s e -> 𝕐 s e
wfSubst :: Ord s => Subst s e -> 𝔹
canonSubst :: (Ord s, Eq e, Substy s e e) => (e -> e) -> Subst s e -> Subst s e
introDSubst :: ℕ64 -> Subst () e
subst :: Substy s e a => Subst s e -> a -> 𝑂 a
substyDBdr :: (Ord s, Ord e) => s -> SubstyM s e ()
substyBdr :: (Ord s, Ord e, Substy s e e) => s -> (𝕐 s e' -> e) -> 𝕎 -> SubstyM s e ()
substy𝕏 :: (Ord s, Ord e, Pretty e, Pretty s, Substy s e e) => s -> (𝕏 -> e) -> 𝕏 -> SubstyM s e e
substy𝕐 :: (Ord s, Ord e, Pretty e, Pretty s, Substy s e e) => s -> (𝕐 s e -> e) -> 𝕐 s e -> SubstyM s e e
syntaxUVar :: LexerBasicSyntax
cpVar :: CParser TokenBasic 𝕎
cpUVarRaw :: (Eq e, Substy () e e) => (() -> CParser TokenBasic e) -> CParser TokenBasic (𝕐 () e)

module UVMHS.Lib.MMSP
newtype MMSP
MMSP :: MMSPMaxs -> MMSP
[mmspMaxs] :: MMSP -> MMSPMaxs
data MMSPMaxs
MMSPMaxs :: ℕ -> 𝑃 MMSPMins -> MMSPMaxs
[mmspMaxsConstant] :: MMSPMaxs -> ℕ
[mmspMaxsMins] :: MMSPMaxs -> 𝑃 MMSPMins
data MMSPMins
MMSPMins :: AddTop ℕ -> 𝑃 MMSPSums -> MMSPMins
[mmspMinsConstant] :: MMSPMins -> AddTop ℕ
[mmspMinsSums] :: MMSPMins -> 𝑃 MMSPSums
data MMSPSums
MMSPSums :: ℕ -> (MMSPProds ⇰ ℕ) -> MMSPSums
[mmspSumsConstant] :: MMSPSums -> ℕ
[mmspSumsPRods] :: MMSPSums -> MMSPProds ⇰ ℕ
data MMSPProds
MMSPProds :: (MMSPAtom ⇰ ℕ) -> MMSPProds
[mmspProdsExps] :: MMSPProds -> MMSPAtom ⇰ ℕ
data MMSPAtom
Var_MMSPAtom :: 𝐴 (𝑃 SrcCxt) 𝕎 -> MMSPAtom
var_MMSPAtomL :: MMSPAtom ⌲ 𝐴 (𝑃 SrcCxt) 𝕎
maxsMMSPL :: MMSP ⌲ MMSPMaxs
minsMMSPL :: MMSP ⌲ MMSPMins
sumsMMSPL :: MMSP ⌲ MMSPSums
prodsMMSPL :: MMSP ⌲ MMSPProds
atomMMSPL :: MMSP ⌲ MMSPAtom
varMMSPL :: MMSP ⌲ 𝐴 (𝑃 SrcCxt) 𝕎
litMMSPL :: MMSP ⌲ ℕ
topMMSPL :: MMSP ⌲ ()
littMMSPL :: MMSP ⌲ AddTop ℕ
maxsMMSP :: MMSPMaxs -> MMSP
minsMMSP :: MMSPMins -> MMSP
sumsMMSP :: MMSPSums -> MMSP
prodsMMSP :: MMSPProds -> MMSP
atomMMSP :: MMSPAtom -> MMSP
varMMSP :: 𝐴 (𝑃 SrcCxt) 𝕎 -> MMSP
litMMSP :: ℕ -> MMSP
topMMSP :: MMSP
joinMMSP :: MMSP -> MMSP -> MMSP
meetMMSP :: MMSP -> MMSP -> MMSP
plusMMSP :: MMSP -> MMSP -> MMSP
timesMMSP :: MMSP -> MMSP -> MMSP
ponMMSP :: MMSP -> ℕ -> MMSP
zeroMaxsMins :: 𝑃 MMSPMins
joinMaxsMins :: 𝑃 MMSPMins -> 𝑃 MMSPMins -> 𝑃 MMSPMins
cmeetMaxsMins :: AddTop ℕ -> 𝑃 MMSPMins -> 𝑃 MMSPMins
meetMaxsMins :: 𝑃 MMSPMins -> 𝑃 MMSPMins -> 𝑃 MMSPMins
cplusMaxsMins :: ℕ -> 𝑃 MMSPMins -> 𝑃 MMSPMins
plusMaxsMins :: 𝑃 MMSPMins -> 𝑃 MMSPMins -> 𝑃 MMSPMins
ctimesMaxsMins :: ℕ -> 𝑃 MMSPMins -> 𝑃 MMSPMins
timesMaxsMins :: 𝑃 MMSPMins -> 𝑃 MMSPMins -> 𝑃 MMSPMins
joinMaxs :: MMSPMaxs -> MMSPMaxs -> MMSPMaxs
meetMaxs :: MMSPMaxs -> MMSPMaxs -> MMSPMaxs
plusMaxs :: MMSPMaxs -> MMSPMaxs -> MMSPMaxs
timesMaxs :: MMSPMaxs -> MMSPMaxs -> MMSPMaxs
infMinsSums :: 𝑃 MMSPSums
meetMinsSums :: 𝑃 MMSPSums -> 𝑃 MMSPSums -> 𝑃 MMSPSums
cplusMinsSums :: ℕ -> 𝑃 MMSPSums -> 𝑃 MMSPSums
plusMinsSums :: 𝑃 MMSPSums -> 𝑃 MMSPSums -> 𝑃 MMSPSums
ctimesMinsSums :: ℕ -> 𝑃 MMSPSums -> 𝑃 MMSPSums
timesMinsSums :: 𝑃 MMSPSums -> 𝑃 MMSPSums -> 𝑃 MMSPSums
cmeetMins :: AddTop ℕ -> MMSPMins -> MMSPMins
meetMins :: MMSPMins -> MMSPMins -> MMSPMins
cplusMins :: ℕ -> MMSPMins -> MMSPMins
plusMins :: MMSPMins -> MMSPMins -> MMSPMins
ctimesMins :: ℕ -> MMSPMins -> MMSPMins
timesMins :: MMSPMins -> MMSPMins -> MMSPMins
zeroSumsProds :: MMSPProds ⇰ ℕ
plusSumsProds :: (MMSPProds ⇰ ℕ) -> (MMSPProds ⇰ ℕ) -> MMSPProds ⇰ ℕ
ctimesSumsProds :: ℕ -> (MMSPProds ⇰ ℕ) -> MMSPProds ⇰ ℕ
timesSumsProds :: (MMSPProds ⇰ ℕ) -> (MMSPProds ⇰ ℕ) -> MMSPProds ⇰ ℕ
cplusSums :: ℕ -> MMSPSums -> MMSPSums
plusSums :: MMSPSums -> MMSPSums -> MMSPSums
timesSums :: MMSPSums -> MMSPSums -> MMSPSums
timesProds :: MMSPProds -> MMSPProds -> MMSPProds
instance UVMHS.Core.Classes.Arithmetic.Additive UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Lattice.Bot UVMHS.Lib.MMSP.MMSP
instance GHC.Classes.Eq UVMHS.Lib.MMSP.MMSP
instance GHC.Classes.Eq UVMHS.Lib.MMSP.MMSPAtom
instance GHC.Classes.Eq UVMHS.Lib.MMSP.MMSPMaxs
instance GHC.Classes.Eq UVMHS.Lib.MMSP.MMSPMins
instance GHC.Classes.Eq UVMHS.Lib.MMSP.MMSPProds
instance GHC.Classes.Eq UVMHS.Lib.MMSP.MMSPSums
instance UVMHS.Core.Classes.Lattice.JoinLattice UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Lattice.Join UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Lattice.MeetLattice UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Lattice.Meet UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Arithmetic.Multiplicative UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Arithmetic.One UVMHS.Lib.MMSP.MMSP
instance GHC.Classes.Ord UVMHS.Lib.MMSP.MMSP
instance GHC.Classes.Ord UVMHS.Lib.MMSP.MMSPAtom
instance GHC.Classes.Ord UVMHS.Lib.MMSP.MMSPMaxs
instance GHC.Classes.Ord UVMHS.Lib.MMSP.MMSPMins
instance GHC.Classes.Ord UVMHS.Lib.MMSP.MMSPProds
instance GHC.Classes.Ord UVMHS.Lib.MMSP.MMSPSums
instance UVMHS.Core.Classes.Arithmetic.Plus UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Arithmetic.Pon UVMHS.Lib.MMSP.MMSP
instance GHC.Show.Show UVMHS.Lib.MMSP.MMSP
instance GHC.Show.Show UVMHS.Lib.MMSP.MMSPAtom
instance GHC.Show.Show UVMHS.Lib.MMSP.MMSPMaxs
instance GHC.Show.Show UVMHS.Lib.MMSP.MMSPMins
instance GHC.Show.Show UVMHS.Lib.MMSP.MMSPProds
instance GHC.Show.Show UVMHS.Lib.MMSP.MMSPSums
instance UVMHS.Core.Classes.Arithmetic.Times UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Lattice.Top UVMHS.Lib.MMSP.MMSP
instance UVMHS.Core.Classes.Arithmetic.Zero UVMHS.Lib.MMSP.MMSP

module UVMHS.Lib.Errors
oops :: (Monad m, MonadReader r m, HasLens r e, MonadError e m) => m a
data GError
GError :: (() -> 𝕊) -> (() -> 𝑃 SrcCxt) -> (() -> 𝕊) -> (() -> Doc) -> GError
[gerrorTyp] :: GError -> () -> 𝕊
[gerrorLoc] :: GError -> () -> 𝑃 SrcCxt
[gerrorMsg] :: GError -> () -> 𝕊
[gerrorCxt] :: GError -> () -> Doc
gerrorTypL :: GError ⟢ (() -> 𝕊)
gerrorLocL :: GError ⟢ (() -> 𝑃 SrcCxt)
gerrorMsgL :: GError ⟢ (() -> 𝕊)
gerrorCxtL :: GError ⟢ (() -> Doc)
gerror₀ :: GError
gerrorFromIO :: IOError -> GError
errSetTyp :: (Monad m, MonadReader r m, HasLens r GError) => (() -> 𝕊) -> m a -> m a
errSetLoc :: (Monad m, MonadReader r m, HasLens r GError) => (() -> 𝑃 SrcCxt) -> m a -> m a
errSetMsg :: (Monad m, MonadReader r m, HasLens r GError) => (() -> 𝕊) -> m a -> m a
errSetCxt :: (Monad m, MonadReader r m, HasLens r GError) => (() -> Doc) -> m a -> m a
errModCxt :: (Monad m, MonadReader r m, HasLens r GError) => (Doc -> Doc) -> m a -> m a
errTyp :: (Monad m, MonadReader r m, HasLens r GError) => m 𝕊
errLoc :: (Monad m, MonadReader r m, HasLens r GError) => m (𝑃 SrcCxt)
errMsg :: (Monad m, MonadReader r m, HasLens r GError) => m 𝕊
errCxt :: (Monad m, MonadReader r m, HasLens r GError) => m Doc
instance UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Lib.Errors.GError

module UVMHS.Lang.ULC
newtype ULCExp 𝒸
ULCExp :: 𝐴 𝒸 (ULCExp_R 𝒸) -> ULCExp 𝒸
[unULCExp] :: ULCExp 𝒸 -> 𝐴 𝒸 (ULCExp_R 𝒸)
onULCExp :: (𝐴 𝒸 (ULCExp_R 𝒸) -> 𝐴 𝒸' (ULCExp_R 𝒸')) -> ULCExp 𝒸 -> ULCExp 𝒸'
data ULCExp_R 𝒸
Var_ULC :: 𝕐 () (ULCExp 𝒸) -> ULCExp_R 𝒸
Lam_ULC :: 𝑂 𝕎 -> ULCExp 𝒸 -> ULCExp_R 𝒸
App_ULC :: ULCExp 𝒸 -> ULCExp 𝒸 -> ULCExp_R 𝒸
var_ULCL :: ULCExp_R 𝒸 ⌲ 𝕐 () (ULCExp 𝒸)
lam_ULCL :: ULCExp_R 𝒸 ⌲ (𝑂 𝕎 ∧ ULCExp 𝒸)
app_ULCL :: ULCExp_R 𝒸 ⌲ (ULCExp 𝒸 ∧ ULCExp 𝒸)
type ULCExpSrc = ULCExp 𝑃 SrcCxt
type ULCExpRaw = ULCExp ()
wfULC :: ULCExp 𝒸 -> 𝔹
canonULC :: Null 𝒸 => ULCExp 𝒸 -> ULCExp 𝒸
syntaxULC :: LexerBasicSyntax
lexULCExp :: Lexer CharClass ℂ TokenClassBasic ℕ64 TokenBasic
pULCExp :: CParser TokenBasic ULCExpSrc
ulc :: QuasiQuoter
instance GHC.Classes.Eq (UVMHS.Lang.ULC.ULCExp 𝒸)
instance GHC.Classes.Eq (UVMHS.Lang.ULC.ULCExp_R 𝒸)
instance UVMHS.Lib.Fuzzy.Fuzzy UVMHS.Lang.ULC.ULCExpRaw
instance GHC.Generics.Generic (UVMHS.Lang.ULC.ULCExp 𝒸)
instance GHC.Generics.Generic (UVMHS.Lang.ULC.ULCExp_R 𝒸)
instance Language.Haskell.TH.Syntax.Lift 𝒸 => Language.Haskell.TH.Syntax.Lift (UVMHS.Lang.ULC.ULCExp 𝒸)
instance Language.Haskell.TH.Syntax.Lift 𝒸 => Language.Haskell.TH.Syntax.Lift (UVMHS.Lang.ULC.ULCExp_R 𝒸)
instance GHC.Classes.Ord (UVMHS.Lang.ULC.ULCExp 𝒸)
instance GHC.Classes.Ord (UVMHS.Lang.ULC.ULCExp_R 𝒸)
instance UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lang.ULC.ULCExp 𝒸)
instance UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Lang.ULC.ULCExp_R 𝒸)
instance UVMHS.Core.Classes.Monoid.Null 𝒸 => UVMHS.Lib.Substitution.Var.SVarView () (UVMHS.Lang.ULC.ULCExp 𝒸)
instance GHC.Show.Show 𝒸 => GHC.Show.Show (UVMHS.Lang.ULC.ULCExp 𝒸)
instance GHC.Show.Show 𝒸 => GHC.Show.Show (UVMHS.Lang.ULC.ULCExp_R 𝒸)
instance UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lang.ULC.ULCExp 𝒸)
instance UVMHS.Lib.Shrinky.Shrinky (UVMHS.Lang.ULC.ULCExp_R 𝒸)
instance UVMHS.Core.Classes.Monoid.Null 𝒸 => UVMHS.Lib.Substitution.Substy.Substy () (UVMHS.Lang.ULC.ULCExp 𝒸) (UVMHS.Lang.ULC.ULCExp 𝒸)

module UVMHS.Lib.Substitution.Tests
g__TESTS__UVMHS__Lib__Substitution__Tests :: 𝑇D Test

module UVMHS

module Examples.Lang.SExp
syntax :: LexerBasicSyntax
lexer :: Lexer CharClass ℂ TokenClassBasic ℕ64 TokenBasic
testSExpTokenizerSuccess :: IO ()
testSExpTokenizerFailure1 :: IO ()
testSExpTokenizerFailure2 :: IO ()
data Lit
IntegerL :: ℤ -> Lit
DoubleL :: 𝔻 -> Lit
StringL :: 𝕊 -> Lit
data Atom
LitA :: Lit -> Atom
NameA :: 𝕊 -> Atom
KeyA :: Atom
PrimA :: Atom
PlusA :: Atom
type Exp = 𝐴 SrcCxt ExpPre
data ExpPre
AtomE :: Atom -> ExpPre
ListE :: 𝐿 Exp -> ExpPre
cpLit :: CParser TokenBasic Lit
cpAtom :: CParser TokenBasic Atom
cpExp :: CParser TokenBasic Exp
cpList :: CParser TokenBasic (𝐿 Exp)
testSExpParserSuccess :: IO ()
testSExpParserFailure1 :: IO ()
testSExpParserFailure2 :: IO ()
testSExpParserFailure3 :: IO ()
instance (UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.SExp.Lit, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.SExp.Atom
instance (UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.SExp.Atom, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝐿 Examples.Lang.SExp.Exp)) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.SExp.ExpPre
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔻, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.SExp.Lit

module Examples.Lang.ArithBlocks
syntax :: LexerWSBasicSyntax
lexer :: Lexer CharClass ℂ TokenClassWSBasic ℕ64 TokenWSBasic
testTokenizerSuccess :: IO ()
data Lit
IntegerL :: ℤ -> Lit
DoubleL :: 𝔻 -> Lit
StringL :: 𝕊 -> Lit
data Atom
LitA :: Lit -> Atom
NameA :: 𝕊 -> Atom
type Exp = 𝐴 SrcCxt ExpPre
data ExpPre
AtomE :: Atom -> ExpPre
PlusE :: Exp -> Exp -> ExpPre
TimesE :: Exp -> Exp -> ExpPre
ExpoE :: Exp -> Exp -> ExpPre
FactE :: Exp -> ExpPre
NegateE :: Exp -> ExpPre
EqualE :: Exp -> Exp -> ExpPre
BlockE :: 𝐿 Exp -> ExpPre
atomEL :: ExpPre ⌲ Atom
plusEL :: ExpPre ⌲ (Exp ∧ Exp)
timesEL :: ExpPre ⌲ (Exp ∧ Exp)
expoEL :: ExpPre ⌲ (Exp ∧ Exp)
factEL :: ExpPre ⌲ Exp
negateEL :: ExpPre ⌲ Exp
equalEL :: ExpPre ⌲ (Exp ∧ Exp)
blockEL :: ExpPre ⌲ 𝐿 Exp
cpLit :: CParser TokenWSBasic Lit
cpAtom :: CParser TokenWSBasic Atom
cpBlock :: CParser TokenWSBasic (𝐿 Exp)
cpExp :: CParser TokenWSBasic Exp
cpExpList :: CParser TokenWSBasic (𝐿 Exp)
testParserSuccess :: IO ()
testParserFailure :: IO ()
instance (UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.ArithBlocks.Lit, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.ArithBlocks.Atom
instance (UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.ArithBlocks.Atom, UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.ArithBlocks.Exp, UVMHS.Lib.Pretty.Doc.Pretty (UVMHS.Core.Init.𝐿 Examples.Lang.ArithBlocks.Exp)) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.ArithBlocks.ExpPre
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔻, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.ArithBlocks.Lit

module Examples.Lang.Arith
syntax :: LexerBasicSyntax
lexer :: Lexer CharClass ℂ TokenClassBasic ℕ64 TokenBasic
testTokenizerSuccess :: IO ()
data Lit
IntegerL :: ℤ -> Lit
DoubleL :: 𝔻 -> Lit
StringL :: 𝕊 -> Lit
data Atom
LitA :: Lit -> Atom
NameA :: 𝕊 -> Atom
type Exp = 𝐴 SrcCxt ExpPre
data ExpPre
AtomE :: Atom -> ExpPre
PlusE :: Exp -> Exp -> ExpPre
TimesE :: Exp -> Exp -> ExpPre
ExpoE :: Exp -> Exp -> ExpPre
FactE :: Exp -> ExpPre
NegateE :: Exp -> ExpPre
EqualE :: Exp -> Exp -> ExpPre
atomEL :: ExpPre ⌲ Atom
plusEL :: ExpPre ⌲ (Exp ∧ Exp)
timesEL :: ExpPre ⌲ (Exp ∧ Exp)
expoEL :: ExpPre ⌲ (Exp ∧ Exp)
factEL :: ExpPre ⌲ Exp
negateEL :: ExpPre ⌲ Exp
equalEL :: ExpPre ⌲ (Exp ∧ Exp)
cpLit :: CParser TokenBasic Lit
cpAtom :: CParser TokenBasic Atom
cpExp :: CParser TokenBasic Exp
testParserSuccess :: IO ()
testParserFailure1 :: IO ()
testParserFailure2 :: IO ()
instance (UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.Arith.Lit, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.Arith.Atom
instance (UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.Arith.Atom, UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.Arith.Exp) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.Arith.ExpPre
instance (UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.ℤ, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝔻, UVMHS.Lib.Pretty.Doc.Pretty UVMHS.Core.Init.𝕊) => UVMHS.Lib.Pretty.Doc.Pretty Examples.Lang.Arith.Lit

module UVMHS.Lib.ZerInf
data AddZer a
Zer :: AddZer a
AddZer :: a -> AddZer a
elimAddZer :: b -> (a -> b) -> AddZer a -> b
data AddInf a
Inf :: AddInf a
AddInf :: a -> AddInf a
elimAddInf :: b -> (a -> b) -> AddInf a -> b
data AddZI a
ZerZI :: AddZI a
InfZI :: AddZI a
AddZI :: a -> AddZI a
instance UVMHS.Core.Classes.Monoid.Append a => UVMHS.Core.Classes.Monoid.Append (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Lib.ZerInf.AddInf
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Lib.ZerInf.AddZI
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Lib.ZerInf.AddZer
instance UVMHS.Core.Classes.Lattice.Bot a => UVMHS.Core.Classes.Lattice.Bot (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Lattice.Bot (UVMHS.Lib.ZerInf.AddZI a)
instance UVMHS.Core.Classes.Lattice.Bot (UVMHS.Lib.ZerInf.AddZer a)
instance (UVMHS.Core.Classes.Arithmetic.DivMod a, UVMHS.Core.Classes.Arithmetic.Zero a) => UVMHS.Core.Classes.Arithmetic.DivMod (UVMHS.Lib.ZerInf.AddInf a)
instance (UVMHS.Core.Classes.Arithmetic.DivMod a, UVMHS.Core.Classes.Lattice.Top a) => UVMHS.Core.Classes.Arithmetic.DivMod (UVMHS.Lib.ZerInf.AddZer a)
instance (UVMHS.Core.Classes.Arithmetic.Divide a, UVMHS.Core.Classes.Arithmetic.Zero a, GHC.Classes.Eq a) => UVMHS.Core.Classes.Arithmetic.Divide (UVMHS.Lib.ZerInf.AddInf a)
instance (UVMHS.Core.Classes.Arithmetic.Divide a, UVMHS.Core.Classes.Lattice.Top a) => UVMHS.Core.Classes.Arithmetic.Divide (UVMHS.Lib.ZerInf.AddZer a)
instance (UVMHS.Core.Classes.Arithmetic.Efn a, UVMHS.Core.Classes.Arithmetic.One a) => UVMHS.Core.Classes.Arithmetic.Efn (UVMHS.Lib.ZerInf.AddInf a)
instance (UVMHS.Core.Classes.Arithmetic.Efn a, UVMHS.Core.Classes.Arithmetic.One a) => UVMHS.Core.Classes.Arithmetic.Efn (UVMHS.Lib.ZerInf.AddZer a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Lib.ZerInf.AddInf a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Lib.ZerInf.AddZI a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Lib.ZerInf.AddInf
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Lib.ZerInf.AddZI
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Lib.ZerInf.AddZer
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Lib.ZerInf.AddInf
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Lib.ZerInf.AddZI
instance UVMHS.Core.Classes.Functors.FunctorM UVMHS.Lib.ZerInf.AddZer
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Lib.ZerInf.AddZI a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.Join (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Lattice.JoinLattice a => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Lib.ZerInf.AddZI a)
instance UVMHS.Core.Classes.Lattice.Join a => UVMHS.Core.Classes.Lattice.JoinLattice (UVMHS.Lib.ZerInf.AddZer a)
instance (UVMHS.Core.Classes.Lattice.JoinLattice a, UVMHS.Core.Classes.Lattice.Meet a) => UVMHS.Core.Classes.Lattice.Lattice (UVMHS.Lib.ZerInf.AddInf a)
instance (UVMHS.Core.Classes.Lattice.Join a, UVMHS.Core.Classes.Lattice.Meet a) => UVMHS.Core.Classes.Lattice.Lattice (UVMHS.Lib.ZerInf.AddZI a)
instance (UVMHS.Core.Classes.Lattice.Join a, UVMHS.Core.Classes.Lattice.MeetLattice a) => UVMHS.Core.Classes.Lattice.Lattice (UVMHS.Lib.ZerInf.AddZer a)
instance (UVMHS.Core.Classes.Arithmetic.Log a, UVMHS.Core.Classes.Lattice.Top a, UVMHS.Core.Classes.Arithmetic.Minus a) => UVMHS.Core.Classes.Arithmetic.Log (UVMHS.Lib.ZerInf.AddInf a)
instance (UVMHS.Core.Classes.Arithmetic.Log a, UVMHS.Core.Classes.Lattice.Top a, UVMHS.Core.Classes.Arithmetic.Minus a) => UVMHS.Core.Classes.Arithmetic.Log (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Lib.ZerInf.AddZI a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.Meet (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.MeetLattice (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Lattice.Meet a => UVMHS.Core.Classes.Lattice.MeetLattice (UVMHS.Lib.ZerInf.AddZI a)
instance UVMHS.Core.Classes.Lattice.MeetLattice a => UVMHS.Core.Classes.Lattice.MeetLattice (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Lib.ZerInf.AddInf
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Lib.ZerInf.AddZI
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Lib.ZerInf.AddZer
instance UVMHS.Core.Classes.Monoid.Monoid a => UVMHS.Core.Classes.Monoid.Monoid (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Monoid.Null a => UVMHS.Core.Classes.Monoid.Null (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Arithmetic.One a => UVMHS.Core.Classes.Arithmetic.One (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Arithmetic.One a => UVMHS.Core.Classes.Arithmetic.One (UVMHS.Lib.ZerInf.AddZer a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Lib.ZerInf.AddInf a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Lib.ZerInf.AddZI a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Arithmetic.Plus a => UVMHS.Core.Classes.Arithmetic.Plus (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Arithmetic.Plus a => UVMHS.Core.Classes.Arithmetic.Plus (UVMHS.Lib.ZerInf.AddZer a)
instance (UVMHS.Core.Classes.Arithmetic.Pon a, UVMHS.Core.Classes.Arithmetic.One a) => UVMHS.Core.Classes.Arithmetic.Pon (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Arithmetic.Pon a => UVMHS.Core.Classes.Arithmetic.Pon (UVMHS.Lib.ZerInf.AddZer a)
instance (UVMHS.Core.Classes.Arithmetic.Pow a, UVMHS.Core.Classes.Arithmetic.One a) => UVMHS.Core.Classes.Arithmetic.Pow (UVMHS.Lib.ZerInf.AddInf a)
instance (UVMHS.Core.Classes.Arithmetic.Pow a, UVMHS.Core.Classes.Arithmetic.One a) => UVMHS.Core.Classes.Arithmetic.Pow (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Functors.Return UVMHS.Lib.ZerInf.AddInf
instance UVMHS.Core.Classes.Functors.Return UVMHS.Lib.ZerInf.AddZI
instance UVMHS.Core.Classes.Functors.Return UVMHS.Lib.ZerInf.AddZer
instance UVMHS.Core.Classes.Arithmetic.Root a => UVMHS.Core.Classes.Arithmetic.Root (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Arithmetic.Root a => UVMHS.Core.Classes.Arithmetic.Root (UVMHS.Lib.ZerInf.AddZer a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Lib.ZerInf.AddInf a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Lib.ZerInf.AddZI a)
instance GHC.Show.Show a => GHC.Show.Show (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Arithmetic.Times a => UVMHS.Core.Classes.Arithmetic.Times (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Arithmetic.Times a => UVMHS.Core.Classes.Arithmetic.Times (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Lattice.Top (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Lattice.Top (UVMHS.Lib.ZerInf.AddZI a)
instance UVMHS.Core.Classes.Lattice.Top a => UVMHS.Core.Classes.Lattice.Top (UVMHS.Lib.ZerInf.AddZer a)
instance UVMHS.Core.Classes.Arithmetic.Zero a => UVMHS.Core.Classes.Arithmetic.Zero (UVMHS.Lib.ZerInf.AddInf a)
instance UVMHS.Core.Classes.Arithmetic.Zero (UVMHS.Lib.ZerInf.AddZer a)

module UVMHS.Tests.Core
g__TESTS__UVMHS__Tests__Core :: 𝑇D Test
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Tests.Core.CR
instance UVMHS.Core.Classes.Functors.Bind UVMHS.Tests.Core.UR
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Tests.Core.CR
instance UVMHS.Core.Classes.Functors.Functor UVMHS.Tests.Core.UR
instance UVMHS.Core.Effects.MonadCont UVMHS.Core.Init.ℕ64 UVMHS.Tests.Core.CR
instance UVMHS.Core.Effects.MonadReader (UVMHS.Core.Init.ℕ64 UVMHS.Core.Init.∧ UVMHS.Core.Init.ℕ64) UVMHS.Tests.Core.CR
instance UVMHS.Core.Effects.MonadReader (UVMHS.Core.Init.ℕ64 UVMHS.Core.Init.∧ UVMHS.Core.Init.ℕ64) UVMHS.Tests.Core.UR
instance UVMHS.Core.Effects.MonadUCont UVMHS.Tests.Core.UR
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Tests.Core.CR
instance UVMHS.Core.Classes.Functors.Monad UVMHS.Tests.Core.UR
instance UVMHS.Core.Classes.Functors.Return UVMHS.Tests.Core.CR
instance UVMHS.Core.Classes.Functors.Return UVMHS.Tests.Core.UR

module UVMHSMain
main :: IO ()
