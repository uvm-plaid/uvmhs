# David's Notes for Fixes, Improvements and Enhancements

Testing Framework:
- Add "prop" in addition "test" and "fuzz", which is like "fuzz" but you just
  provide the one element. This lets you do a "test" but have a custom way to
  pretty print the results.

Parsing Framework:
- Modify Blockify to support parsing `let x = e in e` style blocks
  - need to teach it that block keywords like `let` can come with a set of
    block terminating keywords like `in`.
- Support explicit brackets that ignore layout logic, e.g., `let { x = e } in e`

Fix:
- Pretty Printer. I think it's buggy. There is a branch where I'm most the way
  through solving it. Consider refactoring and adding test suite along the way.

Refactor:
- Parser Library:
  - Reorganize, document, and give better variable names to things.
- For core data structures (e.g., Iter), split out:
  - Public API (in tutorial style)
  - Test Suite
- Make `Monad` a super class of all of the monad effect classes (via Val)
- Replace all the template haskell stuff with Generics
- Fuzzing Library:
  - Rename `Shrinky` to `Shrink`

Improve:
- Work on Chunky
- Rethink tohs/frhs, consider `toChars` and `fromChars`.

New Feature:
- Pretty Printer Library:
  - add a flag to the pretty printer context for "in block" vs "not in block".
    E.g., when printing an application, you can print this:
    
        thing1 thing2 thinge

    as:

        thing1
        thing2
        thing3

    when not in a block, but when in a block, you should print as

        thing1
          thing2
          thing3

- Parser Library: 
  - allow for two categories of errors, "invalid token" error (as
    is not), and "validation error". Validation error should underline in red
    '^'s the piece of syntax that failed to validate, in addition to a message
    as to why.
  - when color is off, print red '^'s as '!'s. (Requires new feature in pretty
    printer that allows pretty printers to change their behavior for when color
    is turned off.)
  - combine `<parser>` and `<parser>WS` functionality into a single interface
    (likely some sort of typeclass)
  - lexer doesn't properly support character tokens
  - teach the lexer blockifier about parentheses
- Substitution Library:
  - in SubstElem type, support delayed shifts in addition to delayed incrs.
    Right now the representation is `s ‚á∞ ‚Ñï64`, which means "for each ‚ü®s,n‚ü©, do
    an increment substitution in scope s for number of variables n" This should
    really be `s ‚á∞ ‚Ñï64 ‚á∞ ‚Ñï64` which means "for each ‚ü®s,œÅ,n‚ü©, do a shifted
    increment substitution in scope s for shift level œÅ and number of variables
    n".
  - Support the ability for the user's expression type to embed SSubstElem (or
    SubstElem, and combined with the usual var type, provide a prism into
    SSubstElem). This would allow applying an increment substitution to an
    expression to lazily evaluate it, so you could do `canon $ incr 1 $ incr 1
    e` and it would only traverse the expression once to push through the
    increment logic.
  - Make substitution failure a proper error type with Doc error message that
    describes failure, rather than just an option
  - change printing and parsing of "x:0‚Ä¶x:4" to be "x:0‚Ä¶4"
  - add something like:

        dbindUnusedSubst ‚à∑ (Ord s) ‚áí s ‚Üí Subst s e

    to go along with the current

        dbindSubst ‚à∑ (Ord s) ‚áí s ‚Üí e ‚Üí Subst s e

    (+ variants for named substitutions...)
    and where `dbindUnusedSubst` just puts a `None` in the substitution vector.
  - longer term, would e good to differentiate between "substitution failed"
    and "we expect this variable to not exist in whatever we apply this
    substitution to", as after adopting prior bullet, these are both
    represented as `None` in the substitution vector.
- Streams and Iterators that perform monadic actions "as they go"

Test Suite Needed:
- Parser Library
- Pretty Printer Library

Other:
- Turn on QualifiedDo

Naming Conventions:
  - convThingAToThingB -- A ‚Üí B
  - convThingBToThingA -- B ‚Üí A

  - makeThingAFrThingB -- B ‚Üí A
  - viewThingBInThingA -- A ‚Üí ùëÇ B
  - thingAToThingBL    -- A ‚å≤ B

  - projThingAToThingB -- A ‚Üí B
  - altrThingBInThingA -- (B ‚Üí B) ‚Üí A ‚Üí A
  - thingAToThingBL    -- A ‚ü¢ B

  - fieldNameL
  - constNameL

  - when deviating from a standard haskell name for something, have a good
    reason for it
    - map instead of fmap: a good reason
    - each instead of for_: a good reason
    - exchange -> rename back to sequence

Small things to fix:
  - whenM should take a delayed argument
  - make lazy lists instance of csized

Things to Rename:
  - don't name anything:
    - errMsg
    - range
    - rng
  - powùëÉ -> pow
  - deconflict `cpName` in `CParser.hs` with `pName` and notion of `Name` in
    substitution library

## Notes on List/Iter/Stream Datatypes

## Notes on RebindableSyntax and fromInteger:

It would be nice to define:

fromInteger ‚à∑ Integer ‚Üí ‚Ñï64
negate ‚à∑ ‚Ñï64 ‚Üí ‚Ñ§64

This would cause `5` to always be type `‚Ñï64` and `-5` to always be type `‚Ñ§64`,
which in 80%+ cases, is probably just what you want, and it avoids the
ambiguity of literals being overloaded. (Note that `-5` syntax desugars to
`negate (fromInteger 5)` when RebindableSyntax is turned on, and desugars I
think just to fromInteger (-5) when Rebindablesyntax is not turned on.)

However, issues pop up when using Template Haskell, and in particular the
`Lift` typeclass that is used in quotes/splicing:

1. Haskell quoted expressions in general do not "remember" what the correct
   definition of `fromInteger` should be in quoted expressions, and also in
   general negative literals are not desugared to use `negate`, but just
   `fromInteger` (see small note on this above). 
   - This is not necessarily intended, but arises from the design intension
     that [| 1 |] when written by the uses should adapt to the
     `fromInteger`/RebindableSyntax context at splice time, and the (I think
     buggy and unfortunate) instance of `liftTyped` for `Int` (and other
     numeric types) that quotes `1` just as [| 1 |], and not some other Haskell
     AST construction that pins the AST to be just a raw `Int` lit, and not
     affected by the splice context's use of RebindableSyntax.
2. This means that if you splice something that under the hood is using `lift`
  or `liftTyped` in a module with RebindableSyntax enabled and the
  `fromInteger`/`negate` types declared at the top of this note, they will give
  you the wrong thing.
3. Even worse, negative literals will silently turn into undrflowed natural
  numbers without any compile-time or run-time error (although you may get a
  compile-time warning).

Potential solutions:

2. Is navigable by newtype wrapping things, both for raw numeric types, and for
   any datastructure whose values encode raw numeric types, as is the case for
   Data.Map and Data.Set.

3. Is much much harder to navigate, as it prevents you from using quoted
   expressions that have numeric literals in them without being explicit about
   avoiding the issue, and in the failure case where you don't avoid the issue,
   you may just get bad underflowed natural number types. This in itself could
   be somewhat mitigated by choosing a "safe" natural number type that throws
   errors on underflow, so at least you'd get a runtime (at compile time) error
   whenever you did this.

NOTE:

It's possible to override the type class instance that is used for types. I'm
sure this is probably not something that should be relied on, but if you
introduce a type class dictionary into scope that is more local than the
existing one, GHC will use that one instead. E.g., you can define this
instance:

    newtype ‚Ñ§64Wrapper = ‚Ñ§64Wrapper { un‚Ñ§64Wrapper ‚à∑ ‚Ñ§64 }
    
    instance TH.Lift ‚Ñ§64Wrapper where
      liftTyped ‚à∑ ‚àÄ m. (TH.Quote m) ‚áí ‚Ñ§64Wrapper ‚Üí TH.Code m ‚Ñ§64Wrapper
      liftTyped (‚Ñ§64Wrapper i) = TH.unsafeCodeCoerce $ 
        let n = zabs $ int i
        in
        if i ‚â• ùï´64 0
        then [| ùï´64 n |]
        else [| neg $ ùï´64 n |]
    
    wLift‚Ñ§64Wrapper ‚à∑ W (TH.Lift ‚Ñ§64Wrapper)
    wLift‚Ñ§64Wrapper = W
    
    useBetter‚Ñ§64LiftInstance ‚à∑ W (TH.Lift ‚Ñ§64)
    useBetter‚Ñ§64LiftInstance = 
      coerce_UNSAFE @(W (TH.Lift ‚Ñ§64Wrapper)) @(W (TH.Lift ‚Ñ§64))wLift‚Ñ§64Wrapper

And then this quote will use the custom instance for `liftTyped` instead of the
one that comes with `Language.Haskell.TH`:

    $(let i = (-11)
      in 
      with otherLift‚Ñ§64Wrapper 
        [d| thing = i |])

Conclusion: 
- Probably just stick with using the `fromInteger` and `negate` from Prelude
  until a number of fixes occur in GHC, including `lift` and `liftTyped`
  instances that "pin" their quoted expressions to be robust to splicing
  contexts that use RebindableSyntax.
- Maybe just newtype wrap all of the things that are or include numeric types,
  and then define a "safe nat" type that throws a runtime exception on
  underflow.
- Maybe defining this "safe nat" type is a good thing to do anyways... and it
  sounds like this is what Rust does:

  https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/
